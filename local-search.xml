<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>编译安装openresty</title>
    <link href="/2024/05/22/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85openresty/"/>
    <url>/2024/05/22/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85openresty/</url>
    
    <content type="html"><![CDATA[<h2 id="OpenResty-源码编译安装脚本："><a href="#OpenResty-源码编译安装脚本：" class="headerlink" title="OpenResty 源码编译安装脚本："></a>OpenResty 源码编译安装脚本：</h2><p>如果是debian系  yum改成apt-get</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">set</span> -e<br><br>zlib_version=1.3.1<br>pcre_version=8.45<br>openssl_version=1.1.1t<br>openresty_version=1.25.3.1<br><br>openssl_prefix=/usr/<span class="hljs-built_in">local</span>/openresty/openssl111<br>zlib_prefix=/usr/<span class="hljs-built_in">local</span>/openresty/zlib<br>pcre_prefix=/usr/<span class="hljs-built_in">local</span>/openresty/pcre<br>openresty_prefix=/usr/<span class="hljs-built_in">local</span>/openresty<br><br><br>yum install -y ccache bzip2 patch gcc make  <br>mkdir openresty-source<br><span class="hljs-built_in">cd</span> openresty-source<br><br>wget https://github.com/madler/zlib/releases/download/v<span class="hljs-variable">$&#123;zlib_version&#125;</span>/zlib-<span class="hljs-variable">$&#123;zlib_version&#125;</span>.tar.xz<br>wget https://sourceforge.net/projects/pcre/files/pcre/<span class="hljs-variable">$&#123;pcre_version&#125;</span>/pcre-<span class="hljs-variable">$&#123;pcre_version&#125;</span>.tar.bz2<br>wget https://www.openssl.org/<span class="hljs-built_in">source</span>/openssl-<span class="hljs-variable">$&#123;openssl_version&#125;</span>.tar.gz<br>wget https://raw.githubusercontent.com/openresty/openresty/master/patches/openssl-1.1.1f-sess_set_get_cb_yield.patch<br>wget https://openresty.org/download/openresty-<span class="hljs-variable">$&#123;openresty_version&#125;</span>.tar.gz<br><br><br>tar -xJf zlib-<span class="hljs-variable">$&#123;zlib_version&#125;</span>.tar.xz<br><span class="hljs-built_in">cd</span> zlib-<span class="hljs-variable">$&#123;zlib_version&#125;</span><br>./configure --prefix=<span class="hljs-variable">$&#123;zlib_prefix&#125;</span><br>make -j`nproc` CFLAGS=<span class="hljs-string">'-O3 -fPIC -D_LARGEFILE64_SOURCE=1 -DHAVE_HIDDEN -g3'</span> \<br>    SFLAGS=<span class="hljs-string">'-O3 -fPIC -D_LARGEFILE64_SOURCE=1 -DHAVE_HIDDEN -g3'</span> \<br>    &gt; /dev/stderr<br>make install<br><span class="hljs-built_in">cd</span> ..<br><br><br>tar -xjf pcre-<span class="hljs-variable">$&#123;pcre_version&#125;</span>.tar.bz2<br><span class="hljs-built_in">cd</span> pcre-<span class="hljs-variable">$&#123;pcre_version&#125;</span><br><span class="hljs-built_in">export</span> CC=<span class="hljs-string">"ccache gcc -fdiagnostics-color=always"</span><br>./configure \<br>  --prefix=<span class="hljs-variable">$&#123;pcre_prefix&#125;</span> \<br>  --libdir=<span class="hljs-variable">$&#123;pcre_prefix&#125;</span>/lib \<br>  --<span class="hljs-built_in">disable</span>-cpp \<br>  --<span class="hljs-built_in">enable</span>-jit \<br>  --<span class="hljs-built_in">enable</span>-utf \<br>  --<span class="hljs-built_in">enable</span>-unicode-properties<br>make -j`nproc` V=1 &gt; /dev/stderr<br>make install<br><span class="hljs-built_in">cd</span> ..<br><br>tar zxf openssl-<span class="hljs-variable">$&#123;openssl_version&#125;</span>.tar.gz<br><span class="hljs-built_in">cd</span> openssl-<span class="hljs-variable">$&#123;openssl_version&#125;</span>/<br>patch -p1 &lt;  ../openssl-1.1.1f-sess_set_get_cb_yield.patch<br><br>./config \<br>    shared zlib -g3 \<br>    <span class="hljs-built_in">enable</span>-camellia <span class="hljs-built_in">enable</span>-seed <span class="hljs-built_in">enable</span>-rfc3779 \<br>    <span class="hljs-built_in">enable</span>-cms <span class="hljs-built_in">enable</span>-md2 <span class="hljs-built_in">enable</span>-rc5 \<br>    <span class="hljs-built_in">enable</span>-weak-ssl-ciphers \<br>    <span class="hljs-built_in">enable</span>-ssl3 <span class="hljs-built_in">enable</span>-ssl3-method \<br>    --prefix=<span class="hljs-variable">$&#123;openssl_prefix&#125;</span> \<br>    --libdir=lib \<br>    -I<span class="hljs-variable">$&#123;zlib_prefix&#125;</span>/include \<br>    -L<span class="hljs-variable">$&#123;zlib_prefix&#125;</span>/lib \<br>    -Wl,-rpath,<span class="hljs-variable">$&#123;zlib_prefix&#125;</span>/lib:<span class="hljs-variable">$&#123;openssl_prefix&#125;</span>/lib<br><br>make CC=<span class="hljs-string">'ccache gcc -fdiagnostics-color=always'</span> -j`nproc`<br>make install<br><span class="hljs-built_in">cd</span> ..<br><br><span class="hljs-comment"># 插件看需求</span><br>tar zxf openresty-<span class="hljs-variable">$&#123;openresty_version&#125;</span>.tar.gz<br><span class="hljs-built_in">cd</span> openresty-<span class="hljs-variable">$&#123;openresty_version&#125;</span><br>./configure \<br>--prefix=<span class="hljs-string">"<span class="hljs-variable">$&#123;openresty_prefix&#125;</span>"</span> \<br>--with-cc=<span class="hljs-string">'ccache gcc -fdiagnostics-color=always'</span> \<br>--with-cc-opt=<span class="hljs-string">"-DNGX_LUA_ABORT_AT_PANIC -I<span class="hljs-variable">$&#123;zlib_prefix&#125;</span>/include -I<span class="hljs-variable">$&#123;pcre_prefix&#125;</span>/include -I<span class="hljs-variable">$&#123;openssl_prefix&#125;</span>/include"</span> \<br>--with-ld-opt=<span class="hljs-string">"-L<span class="hljs-variable">$&#123;zlib_prefix&#125;</span>/lib -L<span class="hljs-variable">$&#123;pcre_prefix&#125;</span>/lib -L<span class="hljs-variable">$&#123;openssl_prefix&#125;</span>/lib -Wl,-rpath,<span class="hljs-variable">$&#123;zlib_prefix&#125;</span>/lib:<span class="hljs-variable">$&#123;pcre_prefix&#125;</span>/lib:<span class="hljs-variable">$&#123;openssl_prefix&#125;</span>/lib"</span> \<br>--with-pcre-jit \<br>--without-http_rds_json_module \<br>--without-http_rds_csv_module \<br>--without-lua_rds_parser \<br>--with-stream \<br>--with-stream_ssl_module \<br>--with-stream_ssl_preread_module \<br>--with-http_v2_module \<br>--without-mail_pop3_module \<br>--without-mail_imap_module \<br>--without-mail_smtp_module \<br>--with-http_stub_status_module \<br>--with-http_realip_module \<br>--with-http_addition_module \<br>--with-http_auth_request_module \<br>--with-http_secure_link_module \<br>--with-http_random_index_module \<br>--with-http_gzip_static_module \<br>--with-http_sub_module \<br>--with-http_dav_module \<br>--with-http_flv_module \<br>--with-http_mp4_module \<br>--with-http_gunzip_module \<br>--with-threads \<br>--with-compat \<br>--with-luajit-xcflags=<span class="hljs-string">'-DLUAJIT_NUMMODE=2 -DLUAJIT_ENABLE_LUA52COMPAT'</span> \<br>-j`nproc`<br><br>make -j`nproc`<br>make install<br><span class="hljs-built_in">cd</span> ..<br><br>cat &lt;&lt;EOF &gt; /etc/systemd/system/openresty.service<br>[Unit]<br>Description=The nginx HTTP and reverse proxy server<br>After=network.target remote-fs.target nss-lookup.target<br><br>[Service]<br>Type=forking<br>PIDFile=/usr/<span class="hljs-built_in">local</span>/openresty/nginx/logs/nginx.pid<br>ExecStartPre=/usr/bin/rm -f /usr/<span class="hljs-built_in">local</span>/openresty/nginx/logs/nginx.pid<br>ExecStartPre=/usr/<span class="hljs-built_in">local</span>/openresty/nginx/sbin/nginx -t<br>ExecStart=/usr/<span class="hljs-built_in">local</span>/openresty/nginx/sbin/nginx<br>ExecReload=/bin/<span class="hljs-built_in">kill</span> -s HUP <span class="hljs-variable">$MAINPID</span><br>KillSignal=SIGQUIT<br>TimeoutStopSec=5<br>KillMode=process<br>PrivateTmp=<span class="hljs-literal">true</span><br><br>[Install]<br>WantedBy=multi-user.target<br>EOF<br><br>chmod 644 /etc/systemd/system/openresty.service<br>systemctl daemon-reload<br>systemctl <span class="hljs-built_in">enable</span> openresty.service<br>systemctl start openresty.service<br>systemctl status openresty.service<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>acme使用</title>
    <link href="/2024/05/09/acme%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/05/09/acme%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>最近有需求白嫖免费证书，找了一下基本都推荐<a href="https://github.com/acmesh-official/acme.sh" target="_blank" rel="noopener">ACME</a>。</p><p>acme.sh 实现了 acme 协议, 可以从 letsencrypt 生成免费的证书.</p><p>主要步骤:</p><p>1、安装 acme.sh</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">curl http<span class="hljs-variable">s:</span>//<span class="hljs-built_in">get</span>.acme.<span class="hljs-keyword">sh</span> | <span class="hljs-keyword">sh</span><br></code></pre></div></td></tr></table></figure><p>2、去证书颁发机构去申请账号 <a href="https://app.zerossl.com/dashboard" target="_blank" rel="noopener">https://app.zerossl.com/dashboard</a><br><img src="/img/newimg/2024-05-10-01.png" srcset="/img/loading.gif" alt="通过邮箱注册，并且申请key"></p><p>编辑 /root/.acme/account.conf 中 ACCOUNT_EMAIL字段。为刚刚注册的邮箱 </p><p><img src="/img/newimg/2024-05-10-02.png" srcset="/img/loading.gif" alt="通过邮箱注册，并且申请key"></p><p>然后执行绑定token</p><figure class="highlight brainfuck"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs brainfuck"><span class="hljs-comment">acme</span><span class="hljs-string">.</span><span class="hljs-comment">sh</span> --<span class="hljs-comment">register</span><span class="hljs-literal">-</span><span class="hljs-comment">account</span> --<span class="hljs-comment">server</span> <span class="hljs-comment">zerossl</span> --<span class="hljs-comment">eab</span><span class="hljs-literal">-</span><span class="hljs-comment">kid</span> <span class="hljs-comment">XeKV6sssjfkjlaksdbK6AxZNw</span> --<span class="hljs-comment">eab</span><span class="hljs-literal">-</span><span class="hljs-comment">hmac</span><span class="hljs-literal">-</span><span class="hljs-comment">key</span> <span class="hljs-comment">f</span><span class="hljs-literal">-</span><span class="hljs-comment">7eMg4PX15Z3aumWYeyeUsww33FJejp</span><span class="hljs-literal">-</span><span class="hljs-comment">DyLin4xn2UKtGt4xZNWUrnaklhsdkahskjfalsdjlasdl</span><br></code></pre></div></td></tr></table></figure><p>3、从域名管理厂商拿到相应的api，acme.sh 实现了 acme 协议支持的所有验证协议. 一般有两种方式验证: http 和 dns 验证. 本次文档是通过dns方式证明域名所有权后自动申请证书。<br><img src="/img/newimg/2024-05-10-03.png" srcset="/img/loading.gif" alt="goggy申请key"><br><img src="/img/newimg/2024-05-10-04.png" srcset="/img/loading.gif" alt="goggy申请key"></p><p>通过环境变量的方式 将刚刚生成的key和Secret导入到环境变量。</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">GD_Key</span>=<span class="hljs-string">"key123456"</span><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">GD_Secret</span>=<span class="hljs-string">"secret123456"</span><br></code></pre></div></td></tr></table></figure><p>4、生成证书</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">泛域名方式：<br>acme<span class="hljs-selector-class">.sh</span> --issue --dns dns_gd -d *<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.com</span> <br><br>多域名方式：<br>acme<span class="hljs-selector-class">.sh</span> --issue --dns dns_gd -d <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.com</span>  -d  <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.com</span>   -d c<span class="hljs-selector-class">.example</span>.com<br></code></pre></div></td></tr></table></figure><p>5、将证书导出到nginx目录（证书会被定期renew）</p><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle">mkdir -p <span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/ssl/</span>example.com<br>acme.sh --install-cert  -d <span class="hljs-string">'*.example.com'</span> \<br>--key-<span class="hljs-keyword">file</span>       <span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/ssl/</span>example.com<span class="hljs-regexp">/key.pem  \</span><br><span class="hljs-regexp">--fullchain-file /</span>etc<span class="hljs-regexp">/nginx/</span>ssl<span class="hljs-regexp">/example.com/</span>cert.pem \<br>--reloadcmd     <span class="hljs-string">"service nginx force-reload"</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>prometheus远端存储改用Tdengin</title>
    <link href="/2022/12/26/prometheus%E8%BF%9C%E7%AB%AF%E5%AD%98%E5%82%A8%E6%94%B9%E7%94%A8Tdengin/"/>
    <url>/2022/12/26/prometheus%E8%BF%9C%E7%AB%AF%E5%AD%98%E5%82%A8%E6%94%B9%E7%94%A8Tdengin/</url>
    
    <content type="html"><![CDATA[<h3 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h3><p>prometheus 在监控方面的能力是有目共睹的，我们在实施监控方案时，为满足大规模应用集群的监控及数据的高效查询能力，通常也会考虑将prometheus的部署扩展为集群。对于prometheus集群的搭建，常见的是官方推荐的联邦模式，但该模式是一种分层结构，在查询监控数据时，仍对下层的Prometheus有一定性能影响。根据官方文档的阅读及个人对集群的理解，我设计了一个基于Tdengine 的prometheus读写分离方案。 该方案结合了Prometheus的远程读写功能及tdengine 的高性能查询及数据压缩能力，有效控制了prometheus集群部署的规模和数据存储压缩的问题，相对规模化数据也提升了查询性能。对于prometheus 的远端存储方案，网上很多文章都是基于influxdb的,当前方案选用的Tdengine是一款开源、云原生的时序数据库，相对influxdb，其提供了优秀的查询和集群能力，更多优点可见：<a href="https://www.taosdata.com/engineering/5969.html" target="_blank" rel="noopener">TDengine和InfluxDB的性能对比报告</a></p><p>得益于Prometheus 提供了 remote_write 和 remote_read 接口来利用其它数据库产品作为它的存储引擎。为了让 Prometheus 生态圈的用户能够利用 TDengine 的高效写入和查询，TDengine 也提供了对这两个接口的支持。</p><p>通过适当的配置， Prometheus 的数据可以通过 remote_write 接口存储到 TDengine 中，也可以通过 remote_read 接口来查询存储在 TDengine 中的数据，充分利用 TDengine 对时序数据的高效存储查询性能和集群处理能力。<br><img src="/img/newimg/008vxvgGgy1h9gzchcypgj319e0tc76x.jpg" srcset="/img/loading.gif" alt=""><br>通过图中读写分离的方案，可以高效的实现监控数据以及监控组件的分离、横向扩容等。</p><h3 id="taosAdapter"><a href="#taosAdapter" class="headerlink" title="taosAdapter"></a>taosAdapter</h3><p>其中Tdengine 支持 prometheus 是通过其内建组件taosAdapter 实现的，taosAdapter是 TDengine 集群和应用程序之间的桥梁和适配器。其不仅支持Prometheus数据的远程读写，还支持如下功能：</p><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">RESTful 接口<br>兼容 InfluxDB <span class="hljs-built_in">v1</span> 写接口<br>兼容 OpenTSDB <span class="hljs-keyword">JSON </span>和 telnet 格式写入<br>无缝连接到 Telegraf<br>无缝连接到 collectd<br>无缝连接到 StatsD<br></code></pre></div></td></tr></table></figure><p><img src="/img/newimg/008vxvgGgy1h9gzf94gdqj31i60jg416.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="部署方案"><a href="#部署方案" class="headerlink" title="部署方案"></a>部署方案</h3><h4 id="部署Tdengine集群"><a href="#部署Tdengine集群" class="headerlink" title="部署Tdengine集群"></a>部署Tdengine集群</h4><p>本次测试使用<code>docker-compose</code>部署单机多实例的Tdengine节点模拟生产环境正常集群情况<br>taosAdapter 在 TDengine 容器中默认是启动的。如果想要禁用它，在启动时指定环境变量 TAOS_DISABLE_ADAPTER=true<br>同时为了部署灵活起见，可以在独立的容器中启动 taosAdapter<br>如果要部署多个 taosAdapter 来提高吞吐量并提供高可用性，推荐配置方式为使用 nginx 等反向代理来提供统一的访问入口。具体配置方法请参考 nginx 的官方文档。如下是示例：</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs"><span class="hljs-attribute">version</span>: "3"<br><br><span class="hljs-attribute">networks:</span><br>  inter:<br><br><span class="hljs-attribute">services:</span><br>  td-1:<br>    image: tdengine/tdengine:$VERSION<br>    networks:<br>      - inter<br>    environment:<br>      TAOS_FQDN: "td-1"<br>      TAOS_FIRST_EP: "td-1"<br>    volumes:<br>      - taosdata-td1:/var/lib/taos/<br>      - taoslog-td1:/var/log/taos/<br>  td-2:<br>    image: tdengine/tdengine:$VERSION<br>    networks:<br>      - inter<br>    environment:<br>      TAOS_FQDN: "td-2"<br>      TAOS_FIRST_EP: "td-1"<br>    volumes:<br>      - taosdata-td2:/var/lib/taos/<br>      - taoslog-td2:/var/log/taos/<br>  adapter:<br>    image: tdengine/tdengine:$VERSION<br>    entrypoint: "taosadapter"<br>    networks:<br>      - inter<br>    environment:<br>      TAOS_FIRST_EP: "td-1"<br>      TAOS_SECOND_EP: "td-2"<br>    deploy:<br>      replicas: 4<br>  nginx:<br>    image: nginx<br>    depends_on:<br>      - adapter<br>    networks:<br>      - inter<br>    ports:<br>      - 6041:6041<br>      - 6044:6044/udp<br>    command: [<br>        "sh",<br>        "-c",<br>        "while true;<br>        do curl -s http://adapter:6041/-/ping &gt;/dev/null &amp;&amp; break;<br>        done;<br>        printf 'server&#123;listen 6041;location /&#123;proxy_pass http://adapter:6041;&#125;&#125;'<br>        &gt; /etc/nginx/conf.d/rest.conf;<br>        printf 'stream&#123;server&#123;listen 6044 udp;proxy_pass adapter:6044;&#125;&#125;'<br>        &gt;&gt; /etc/nginx/nginx.conf;cat /etc/nginx/nginx.conf;<br>        nginx -g 'daemon off;'",<br>      ]<br><span class="hljs-attribute">volumes:</span><br>  taosdata-td1:<br>  taoslog-td1:<br>  taosdata-td2:<br>  taoslog-td2:<br></code></pre></div></td></tr></table></figure><p>查看部署状态</p><figure class="highlight vala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vala">tdengin默认账号密码 root:taosdata<br><span class="hljs-meta"># 进入容器环境</span><br>docker exec -it tdengine /bin/bash<br><span class="hljs-meta"># 进入taos 数据库控制台</span><br>taos<br><span class="hljs-meta"># 创建prometheus数据库</span><br><span class="hljs-meta"># keep 数据保留180 天,默认为3650天，days 每10天为一个数据文件，</span><br><span class="hljs-meta"># comp 数据文件的压缩程度为1，0：关闭，1:一阶段压缩，2:两阶段压缩。默认为2</span><br>create database prometheus keep <span class="hljs-number">180</span> days <span class="hljs-number">10</span> comp <span class="hljs-number">1</span>;<br><span class="hljs-meta"># 退出</span><br>quit<br><br><span class="hljs-meta"># 用默认密码测试，在返回结果中可以看到 prometheus 数据库</span><br>curl -u root:taosdata -d <span class="hljs-string">'show databases'</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6041</span>/rest/sql<br><br><span class="hljs-meta"># 也可以修改数据库参数</span><br>alter database prometheus keep <span class="hljs-number">90</span>;<br></code></pre></div></td></tr></table></figure><p><img src="/img/newimg/008vxvgGgy1h9h00nhoxlj31980u0dif.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="Prometheus部署"><a href="#Prometheus部署" class="headerlink" title="Prometheus部署"></a>Prometheus部署</h4><p>对于开启prometheus的remote_write 是非常简单的，只需在配置文件中添加如下配置即可:</p><p>新建目录 prometheus，编辑配置文件prometheus.yml</p><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">mkdir <span class="hljs-string">/etc/prometheus</span><br><span class="hljs-keyword">cd</span> <span class="hljs-string">/etc/prometheus/</span><br>vim prometheus.yml<br></code></pre></div></td></tr></table></figure><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-meta"># 远程写，对只读prometheus 配置时，屏蔽掉远程写配置即可</span><br><span class="hljs-symbol">remote_write:</span><br>- url: <span class="hljs-string">"http://x.x.x.x:6041/prometheus/v1/remote_write/prometheus"</span><br><span class="hljs-symbol">  basic_auth:</span><br><span class="hljs-symbol">    username:</span> root<br><span class="hljs-symbol">    password:</span> taosdata<br><br><span class="hljs-meta"># 远程读</span><br><span class="hljs-symbol">remote_read:</span><br>  - url: <span class="hljs-string">"http://x.x.x.x:6041/prometheus/v1/remote_read/prometheus"</span><br><span class="hljs-symbol">    basic_auth:</span><br><span class="hljs-symbol">      username:</span> root<br><span class="hljs-symbol">      password:</span> taosdata<br></code></pre></div></td></tr></table></figure><p>查看Prometheus配置<br><img src="/img/newimg/008vxvgGgy1h9h03ikt0rj30w20u0acs.jpg" srcset="/img/loading.gif" alt=""></p><p>启动prometheus</p><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">docker</span> <span class="hljs-string">run  -d \</span><br>  <span class="hljs-meta">-p</span> <span class="hljs-string">9090:9090 \</span><br>  <span class="hljs-meta">-v</span> <span class="hljs-string">/etc/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml  \</span><br>  <span class="hljs-attr">prom/prometheus</span><br></code></pre></div></td></tr></table></figure><p>进入tdengin容器节点，查看数据是否进入<br><img src="/img/newimg/008vxvgGgy1h9h0b6wke2j30u00wbtdj.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>kafka常用管理命令和脚本</title>
    <link href="/2022/12/14/kafka%E5%B8%B8%E7%94%A8%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4%E5%92%8C%E8%84%9A%E6%9C%AC/"/>
    <url>/2022/12/14/kafka%E5%B8%B8%E7%94%A8%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4%E5%92%8C%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h3 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h3><h4 id="启动-Kafka"><a href="#启动-Kafka" class="headerlink" title="启动 Kafka"></a>启动 Kafka</h4><p><code>-daemon</code> 参数可以让 Kafka 在后台运行。</p><blockquote><p>kafka-server-start.sh -daemon /usr/local/kafka/config/server.properties</p></blockquote><h4 id="指定-JMX-端口启动"><a href="#指定-JMX-端口启动" class="headerlink" title="指定 JMX 端口启动"></a>指定 JMX 端口启动</h4><p>JMX 的全称为 Java Management Extensions。顾名思义，是管理 Java 的一种扩展，通过 JMX 可以方便我们监控 Kafka 的内存，线程，CPU 的使用情况，以及生产和消费消息的指标。</p><blockquote><p>JMX_PORT=9999 kafka-server-start.sh -daemon /usr/local/kafka/config/server.properties</p></blockquote><h4 id="停止-Kafka"><a href="#停止-Kafka" class="headerlink" title="停止 Kafka"></a>停止 Kafka</h4><blockquote><p>kafka-server-stop.sh </p></blockquote><h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><h4 id="创建Topic"><a href="#创建Topic" class="headerlink" title="创建Topic"></a>创建Topic</h4><blockquote><p>kafka-topics.sh –create  –bootstrap-server <zk-service>:9092 –replication-factor 3 –partitions 3 –topic <topic-name></p></blockquote><h4 id="列出所有-Topic"><a href="#列出所有-Topic" class="headerlink" title="列出所有 Topic"></a>列出所有 Topic</h4><blockquote><p>kafka-topics.sh  –bootstrap-server <zk-service>:9092 –list</p></blockquote><h4 id="查看指定-Topic"><a href="#查看指定-Topic" class="headerlink" title="查看指定 Topic"></a>查看指定 Topic</h4><blockquote><p>kafka-topics.sh –bootstrap-server <zk-service>:9092 –describe –topic <topic-name></p></blockquote><h4 id="删除指定-Topic"><a href="#删除指定-Topic" class="headerlink" title="删除指定 Topic"></a>删除指定 Topic</h4><blockquote><p>kafka-topics.sh –bootstrap-server  <zk-service>:9092 –delete –topic <topic-name></p></blockquote><h4 id="扩展-Topic-的-Partition-数量"><a href="#扩展-Topic-的-Partition-数量" class="headerlink" title="扩展 Topic 的 Partition 数量"></a>扩展 Topic 的 Partition 数量</h4><p>artition 数量只能扩大不能缩小。</p><blockquote><p>kafka-topics.sh –bootstrap-server <zk-service>:9092 –topic app –alter –partitions 30</p></blockquote><h4 id="扩展-topic-每个-partition-的副本数量"><a href="#扩展-topic-每个-partition-的副本数量" class="headerlink" title="扩展 topic 每个 partition 的副本数量"></a>扩展 topic 每个 partition 的副本数量</h4><p>replication factor 可以扩大也可以缩小，最多不能超过 broker 数量。先创建一个文件名为 increace-factor.json，这里要扩展的是 mysql-audit-log 这个 topic 的 partition 到 15 个：0，1，2 为 broker id。</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<span class="hljs-attr">"version"</span>:<span class="hljs-number">1</span>,<br><span class="hljs-attr">"partitions"</span>:[<br>&#123;<span class="hljs-attr">"topic"</span>:<span class="hljs-string">"mysql-audit-log"</span>,<span class="hljs-attr">"partition"</span>:<span class="hljs-number">0</span>,<span class="hljs-attr">"replicas"</span>:[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]&#125;,<br>&#123;<span class="hljs-attr">"topic"</span>:<span class="hljs-string">"mysql-audit-log"</span>,<span class="hljs-attr">"partition"</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">"replicas"</span>:[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]&#125;,<br>&#123;<span class="hljs-attr">"topic"</span>:<span class="hljs-string">"mysql-audit-log"</span>,<span class="hljs-attr">"partition"</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">"replicas"</span>:[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]&#125;,<br>&#123;<span class="hljs-attr">"topic"</span>:<span class="hljs-string">"mysql-audit-log"</span>,<span class="hljs-attr">"partition"</span>:<span class="hljs-number">3</span>,<span class="hljs-attr">"replicas"</span>:[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]&#125;,<br>&#123;<span class="hljs-attr">"topic"</span>:<span class="hljs-string">"mysql-audit-log"</span>,<span class="hljs-attr">"partition"</span>:<span class="hljs-number">4</span>,<span class="hljs-attr">"replicas"</span>:[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]&#125;,<br>&#123;<span class="hljs-attr">"topic"</span>:<span class="hljs-string">"mysql-audit-log"</span>,<span class="hljs-attr">"partition"</span>:<span class="hljs-number">5</span>,<span class="hljs-attr">"replicas"</span>:[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]&#125;,<br>&#123;<span class="hljs-attr">"topic"</span>:<span class="hljs-string">"mysql-audit-log"</span>,<span class="hljs-attr">"partition"</span>:<span class="hljs-number">6</span>,<span class="hljs-attr">"replicas"</span>:[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]&#125;,<br>&#123;<span class="hljs-attr">"topic"</span>:<span class="hljs-string">"mysql-audit-log"</span>,<span class="hljs-attr">"partition"</span>:<span class="hljs-number">7</span>,<span class="hljs-attr">"replicas"</span>:[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]&#125;,<br>&#123;<span class="hljs-attr">"topic"</span>:<span class="hljs-string">"mysql-audit-log"</span>,<span class="hljs-attr">"partition"</span>:<span class="hljs-number">8</span>,<span class="hljs-attr">"replicas"</span>:[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]&#125;,<br>&#123;<span class="hljs-attr">"topic"</span>:<span class="hljs-string">"mysql-audit-log"</span>,<span class="hljs-attr">"partition"</span>:<span class="hljs-number">9</span>,<span class="hljs-attr">"replicas"</span>:[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]&#125;,<br>&#123;<span class="hljs-attr">"topic"</span>:<span class="hljs-string">"mysql-audit-log"</span>,<span class="hljs-attr">"partition"</span>:<span class="hljs-number">10</span>,<span class="hljs-attr">"replicas"</span>:[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]&#125;,<br>&#123;<span class="hljs-attr">"topic"</span>:<span class="hljs-string">"mysql-audit-log"</span>,<span class="hljs-attr">"partition"</span>:<span class="hljs-number">11</span>,<span class="hljs-attr">"replicas"</span>:[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]&#125;,<br>&#123;<span class="hljs-attr">"topic"</span>:<span class="hljs-string">"mysql-audit-log"</span>,<span class="hljs-attr">"partition"</span>:<span class="hljs-number">12</span>,<span class="hljs-attr">"replicas"</span>:[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]&#125;,<br>&#123;<span class="hljs-attr">"topic"</span>:<span class="hljs-string">"mysql-audit-log"</span>,<span class="hljs-attr">"partition"</span>:<span class="hljs-number">13</span>,<span class="hljs-attr">"replicas"</span>:[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]&#125;,<br>&#123;<span class="hljs-attr">"topic"</span>:<span class="hljs-string">"mysql-audit-log"</span>,<span class="hljs-attr">"partition"</span>:<span class="hljs-number">14</span>,<span class="hljs-attr">"replicas"</span>:[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]&#125;<br>]&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>kafka-reassign-partitions.sh –zookeeper <zk-service>:2181 –reassignment-json-file  increace-factor.json –execute </p></blockquote><h4 id="查看-Topic-数据大小"><a href="#查看-Topic-数据大小" class="headerlink" title="查看 Topic 数据大小"></a>查看 Topic 数据大小</h4><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript"><span class="hljs-comment">#方法一</span><br>kafka-log-dirs.sh <span class="hljs-string">\</span><br>  --bootstrap-server <span class="hljs-number">192.168</span>.<span class="hljs-number">1.87</span>:<span class="hljs-number">9092</span> <span class="hljs-string">\</span><br>  --topic-<span class="hljs-keyword">list</span> mytopic <span class="hljs-string">\</span><br>  --describe <span class="hljs-string">\</span><br>  | grep -oP <span class="hljs-string">'(?&lt;=size":)\d+'</span>  <span class="hljs-string">\</span><br>  | awk <span class="hljs-string">'&#123; sum += $1 &#125; END &#123; print sum &#125;'</span><br>  <br><span class="hljs-comment">#返回结果，单位 Byte</span><br><span class="hljs-number">648</span><br><br><span class="hljs-comment">#方法二，需要安装 jq</span><br>kafka-log-dirs.sh <span class="hljs-string">\</span><br>    --bootstrap-server <span class="hljs-number">192.168</span>.<span class="hljs-number">1.87</span>:<span class="hljs-number">9092</span> <span class="hljs-string">\</span><br>    --topic-<span class="hljs-keyword">list</span> mytopic <span class="hljs-string">\</span><br>    --describe <span class="hljs-string">\</span><br>  | grep <span class="hljs-string">'^&#123;'</span> <span class="hljs-string">\</span><br>  | jq <span class="hljs-string">'[ ..|.size? | numbers ] | add'</span><br><br><span class="hljs-comment">#返回结果，单位 Byte</span><br><span class="hljs-number">648</span><br></code></pre></div></td></tr></table></figure><h3 id="消费者组-Consumer-Group"><a href="#消费者组-Consumer-Group" class="headerlink" title="消费者组 Consumer Group"></a>消费者组 Consumer Group</h3><h4 id="列出所有的-Consumer-Group"><a href="#列出所有的-Consumer-Group" class="headerlink" title="列出所有的 Consumer Group"></a>列出所有的 Consumer Group</h4><blockquote><p> kafka-consumer-groups.sh –bootstrap-server <zk-service>:9092 –list</p></blockquote><h4 id="查看指定-Consumer-Group-详情"><a href="#查看指定-Consumer-Group-详情" class="headerlink" title="查看指定 Consumer Group 详情"></a>查看指定 Consumer Group 详情</h4><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">GROUP:消费者 group<br>TOPIC:话题 id<br>PARTITION:分区 id<br>CURRENT-OFFSET:当前已消费的条数<br>LOG-END-OFFSET:总条数<br>LAG:未消费的条数<br>CONSUMER-ID:消费者 id<br>HOST:消费者<span class="hljs-built_in"> ip </span>地址<br>CLIENT-ID:客户端 id<br></code></pre></div></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">#这里查看的是 logstash_mysql 这个消费者 group 的消费情况<br>kafka-consumer-groups.sh --bootstrap-server <span class="hljs-number">10.37</span><span class="hljs-number">.62</span><span class="hljs-number">.20</span>:<span class="hljs-number">9092</span> --describe --group logstash_mysql<br><br>#返回结果<br>GROUP           TOPIC           PARTITION  CURRENT-OFFSET  LOG-END-OFFSET  LAG             CONSUMER-ID                                      HOST            CLIENT-ID<br>logstash_mysql  mysql-audit-log <span class="hljs-number">11</span>         <span class="hljs-number">1312115</span>         <span class="hljs-number">1312857</span>         <span class="hljs-number">742</span>             logstash<span class="hljs-number">-5</span><span class="hljs-number">-0545</span>a8a7-f7bd<span class="hljs-number">-430</span>c-b619<span class="hljs-number">-7</span>a2b206addd2  /<span class="hljs-number">10.37</span><span class="hljs-number">.62</span><span class="hljs-number">.24</span>    logstash<span class="hljs-number">-5</span><br>logstash_mysql  mysql-audit-log <span class="hljs-number">1</span>          <span class="hljs-number">1312593</span>         <span class="hljs-number">1313345</span>         <span class="hljs-number">752</span>             logstash<span class="hljs-number">-0</span>-d86bd51a-d010<span class="hljs-number">-45</span>de-aa6f-f6da8542b779  /<span class="hljs-number">10.37</span><span class="hljs-number">.62</span><span class="hljs-number">.23</span>    logstash<span class="hljs-number">-0</span><br>logstash_mysql  mysql-audit-log <span class="hljs-number">2</span>          <span class="hljs-number">1309548</span>         <span class="hljs-number">1310317</span>         <span class="hljs-number">769</span>             logstash<span class="hljs-number">-1</span><span class="hljs-number">-496340</span>ea<span class="hljs-number">-935</span>d<span class="hljs-number">-444</span>d-a184<span class="hljs-number">-51</span>d42e225054  /<span class="hljs-number">10.37</span><span class="hljs-number">.62</span><span class="hljs-number">.24</span>    logstash<span class="hljs-number">-1</span><br>logstash_mysql  mysql-audit-log <span class="hljs-number">12</span>         <span class="hljs-number">1313083</span>         <span class="hljs-number">1313194</span>         <span class="hljs-number">111</span>             logstash<span class="hljs-number">-6</span><span class="hljs-number">-806</span>b20cb-a9af<span class="hljs-number">-49</span>c1-b37d-ccb33a646ab2  /<span class="hljs-number">10.37</span><span class="hljs-number">.62</span><span class="hljs-number">.24</span>    logstash<span class="hljs-number">-6</span><br>logstash_mysql  mysql-audit-log <span class="hljs-number">6</span>          <span class="hljs-number">1310984</span>         <span class="hljs-number">1311192</span>         <span class="hljs-number">208</span>             logstash<span class="hljs-number">-13</span><span class="hljs-number">-8</span>d474bf6-e8d0<span class="hljs-number">-4</span>b8a-b319-cf5e2e6cc078 /<span class="hljs-number">10.37</span><span class="hljs-number">.62</span><span class="hljs-number">.24</span>    logstash<span class="hljs-number">-13</span><br>logstash_mysql  mysql-audit-log <span class="hljs-number">9</span>          <span class="hljs-number">1312998</span>         <span class="hljs-number">1313768</span>         <span class="hljs-number">770</span>             logstash<span class="hljs-number">-3</span><span class="hljs-number">-29863f</span>b0<span class="hljs-number">-6708</span><span class="hljs-number">-4f</span>b1<span class="hljs-number">-9e28</span>-bd81c30ce8ef  /<span class="hljs-number">10.37</span><span class="hljs-number">.62</span><span class="hljs-number">.24</span>    logstash<span class="hljs-number">-3</span><br>logstash_mysql  mysql-audit-log <span class="hljs-number">4</span>          <span class="hljs-number">1315150</span>         <span class="hljs-number">1315276</span>         <span class="hljs-number">126</span>             logstash<span class="hljs-number">-11</span><span class="hljs-number">-6</span>d66a188<span class="hljs-number">-85</span>b7<span class="hljs-number">-476</span>b-bd89<span class="hljs-number">-5423</span>ef48cd01 /<span class="hljs-number">10.37</span><span class="hljs-number">.62</span><span class="hljs-number">.24</span>    logstash<span class="hljs-number">-11</span><br>logstash_mysql  mysql-audit-log <span class="hljs-number">0</span>          <span class="hljs-number">22770935522</span>     <span class="hljs-number">22770935650</span>     <span class="hljs-number">128</span>             logstash<span class="hljs-number">-0</span><span class="hljs-number">-7</span>be475d6-a49e<span class="hljs-number">-4f</span>f9-bf83<span class="hljs-number">-6</span>b83f6067306  /<span class="hljs-number">10.37</span><span class="hljs-number">.62</span><span class="hljs-number">.24</span>    logstash<span class="hljs-number">-0</span><br>logstash_mysql  mysql-audit-log <span class="hljs-number">8</span>          <span class="hljs-number">1309956</span>         <span class="hljs-number">1310103</span>         <span class="hljs-number">147</span>             logstash<span class="hljs-number">-2</span><span class="hljs-number">-3</span>c313c6f<span class="hljs-number">-8</span>c98<span class="hljs-number">-4333</span><span class="hljs-number">-8</span>bad<span class="hljs-number">-2f</span>9696457d7d  /<span class="hljs-number">10.37</span><span class="hljs-number">.62</span><span class="hljs-number">.24</span>    logstash<span class="hljs-number">-2</span><br>logstash_mysql  mysql-audit-log <span class="hljs-number">13</span>         <span class="hljs-number">1314659</span>         <span class="hljs-number">1314775</span>         <span class="hljs-number">116</span>             logstash<span class="hljs-number">-7</span>-e98fd14e-e7f6<span class="hljs-number">-45e5</span><span class="hljs-number">-8</span>ccf<span class="hljs-number">-2442058f</span>0bc9  /<span class="hljs-number">10.37</span><span class="hljs-number">.62</span><span class="hljs-number">.24</span>    logstash<span class="hljs-number">-7</span><br>logstash_mysql  mysql-audit-log <span class="hljs-number">14</span>         <span class="hljs-number">1313145</span>         <span class="hljs-number">1313250</span>         <span class="hljs-number">105</span>             logstash<span class="hljs-number">-8</span><span class="hljs-number">-2</span>c3345a8-f8f1<span class="hljs-number">-4f</span>08-a18e<span class="hljs-number">-333</span>dff2f0d65  /<span class="hljs-number">10.37</span><span class="hljs-number">.62</span><span class="hljs-number">.24</span>    logstash<span class="hljs-number">-8</span><br>logstash_mysql  mysql-audit-log <span class="hljs-number">5</span>          <span class="hljs-number">1314037</span>         <span class="hljs-number">1314297</span>         <span class="hljs-number">260</span>             logstash<span class="hljs-number">-12</span>-ce018227<span class="hljs-number">-9e59</span><span class="hljs-number">-4137</span>-a23f<span class="hljs-number">-5</span>ccc0c7d4f6a /<span class="hljs-number">10.37</span><span class="hljs-number">.62</span><span class="hljs-number">.24</span>    logstash<span class="hljs-number">-12</span><br>logstash_mysql  mysql-audit-log <span class="hljs-number">10</span>         <span class="hljs-number">1312883</span>         <span class="hljs-number">1312962</span>         <span class="hljs-number">79</span>              logstash<span class="hljs-number">-4</span><span class="hljs-number">-9</span>eb84ae4<span class="hljs-number">-3351</span><span class="hljs-number">-4083</span><span class="hljs-number">-9</span>b1f<span class="hljs-number">-288910</span>a6c3b8  /<span class="hljs-number">10.37</span><span class="hljs-number">.62</span><span class="hljs-number">.24</span>    logstash<span class="hljs-number">-4</span><br>logstash_mysql  mysql-audit-log <span class="hljs-number">7</span>          <span class="hljs-number">1312476</span>         <span class="hljs-number">1313200</span>         <span class="hljs-number">724</span>             logstash<span class="hljs-number">-14</span><span class="hljs-number">-680</span>c982e<span class="hljs-number">-5</span>cf3<span class="hljs-number">-406</span>b<span class="hljs-number">-810</span>a<span class="hljs-number">-4</span>d5c96b5bdee /<span class="hljs-number">10.37</span><span class="hljs-number">.62</span><span class="hljs-number">.24</span>    logstash<span class="hljs-number">-14</span><br>logstash_mysql  mysql-audit-log <span class="hljs-number">3</span>          <span class="hljs-number">1313227</span>         <span class="hljs-number">1313328</span>         <span class="hljs-number">101</span><br></code></pre></div></td></tr></table></figure><h4 id="删除指定-Consumer-Group"><a href="#删除指定-Consumer-Group" class="headerlink" title="删除指定 Consumer Group"></a>删除指定 Consumer Group</h4><blockquote><p>kafka-topics.sh –bootstrap-server <zk-service>:9092 –delete –topic pgw-nginx</p></blockquote><h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><h4 id="生产消息"><a href="#生产消息" class="headerlink" title="生产消息"></a>生产消息</h4><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">kafka-console-producer.sh --broker-list <span class="hljs-number">11.8</span><span class="hljs-number">.36</span><span class="hljs-number">.125</span>:<span class="hljs-number">9092</span> --topic mytopic<br>&gt;<span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> my topic<br></code></pre></div></td></tr></table></figure><h4 id="生产消息指定-Key"><a href="#生产消息指定-Key" class="headerlink" title="生产消息指定 Key"></a>生产消息指定 Key</h4><p><code>key.separator=</code>, 指定以逗号作为 key 和 value 的分隔符。</p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">kafka-console-producer.sh --broker-list kafka1:<span class="hljs-number">9092</span> --topic cr7-topic --<span class="hljs-keyword">property</span><span class="hljs-title"> </span>parse.<span class="hljs-attr">key=</span><span class="hljs-literal">true</span> --<span class="hljs-keyword">property</span><span class="hljs-title"> </span>key.<span class="hljs-attr">separator=</span>,<br><br>&gt;mykey,&#123;<span class="hljs-string">"orderAmount"</span>:<span class="hljs-number">1000</span>,<span class="hljs-string">"orderId"</span>:<span class="hljs-number">1</span>,<span class="hljs-string">"productId"</span>:<span class="hljs-number">101</span>,<span class="hljs-string">"productNum"</span>:<span class="hljs-number">1</span>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h4><h5 id="从头开始消费"><a href="#从头开始消费" class="headerlink" title="从头开始消费"></a>从头开始消费</h5><p>从头开始消费是可以消费到之前的消息的，通过 <code>--from-beginning</code> 指定：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">kafka-console-consumer.sh --bootstrap-server <span class="hljs-number">11.8</span><span class="hljs-number">.36</span><span class="hljs-number">.125</span>:<span class="hljs-number">9092</span> --topic mytopic --<span class="hljs-keyword">from</span>-beginning<br><span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> my topic<br></code></pre></div></td></tr></table></figure><h5 id="从尾部开始消费"><a href="#从尾部开始消费" class="headerlink" title="从尾部开始消费"></a>从尾部开始消费</h5><p><code>--offset latest</code> 指定从尾部开始消费，另外还需要指定 partition，可以指定多个：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">kafka-console-consumer.sh --bootstrap-server <span class="hljs-number">11.8</span><span class="hljs-number">.36</span><span class="hljs-number">.125</span>:<span class="hljs-number">9092</span> --topic mytopic  --offset latest  --partition <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><h5 id="消费指定条数的消息"><a href="#消费指定条数的消息" class="headerlink" title="消费指定条数的消息"></a>消费指定条数的消息</h5><p><code>--max-messages</code> 指定取的个数：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">kafka-console-consumer.sh --bootstrap-server <span class="hljs-number">11.8</span><span class="hljs-number">.36</span><span class="hljs-number">.125</span>:<span class="hljs-number">9092</span> --topic mytopic  --offset latest  --partition <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> --max-messages <span class="hljs-number">2</span><br>bobo<br><span class="hljs-number">1111</span><br>Processed a total of <span class="hljs-number">2</span> messages<br></code></pre></div></td></tr></table></figure><h5 id="指定消费组进行消费"><a href="#指定消费组进行消费" class="headerlink" title="指定消费组进行消费"></a>指定消费组进行消费</h5><p><code>--consumer-property group.id=&lt;消费者组名&gt;</code>执行消费者组进行消费：</p><blockquote><p>kafka-console-consumer.sh –bootstrap-server  kafka1:9092 –topic test_partition –consumer-property  group.id=test_group –from-beginning </p></blockquote><h5 id="查看消息具体内容"><a href="#查看消息具体内容" class="headerlink" title="查看消息具体内容"></a>查看消息具体内容</h5><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">kafka-dump-log.sh --files cr7-topic<span class="hljs-number">-0</span>/<span class="hljs-number">00000000000000000000.</span>log  -deep-iteration --print-data-log<br> <br> #输出结果<br>| offset: <span class="hljs-number">1080</span> CreateTime: <span class="hljs-number">1615020877664</span> keysize: <span class="hljs-number">1</span> valuesize: <span class="hljs-number">63</span> sequence: <span class="hljs-number">-1</span> headerKeys: [] key: <span class="hljs-number">1</span> payload: &#123;<span class="hljs-string">"orderAmount"</span>:<span class="hljs-number">1000</span>,<span class="hljs-string">"orderId"</span>:<span class="hljs-number">1</span>,<span class="hljs-string">"productId"</span>:<span class="hljs-number">101</span>,<span class="hljs-string">"productNum"</span>:<span class="hljs-number">1</span>&#125;<br>| offset: <span class="hljs-number">1081</span> CreateTime: <span class="hljs-number">1615020877677</span> keysize: <span class="hljs-number">1</span> valuesize: <span class="hljs-number">63</span> sequence: <span class="hljs-number">-1</span> headerKeys: [] key: <span class="hljs-number">5</span> payload: &#123;<span class="hljs-string">"orderAmount"</span>:<span class="hljs-number">1000</span>,<span class="hljs-string">"orderId"</span>:<span class="hljs-number">5</span>,<span class="hljs-string">"productId"</span>:<span class="hljs-number">105</span>,<span class="hljs-string">"productNum"</span>:<span class="hljs-number">5</span>&#125;<br>| offset: <span class="hljs-number">1082</span> CreateTime: <span class="hljs-number">1615020877677</span> keysize: <span class="hljs-number">1</span> valuesize: <span class="hljs-number">63</span> sequence: <span class="hljs-number">-1</span> headerKeys: [] key: <span class="hljs-number">7</span> payload: &#123;<span class="hljs-string">"orderAmount"</span>:<span class="hljs-number">1000</span>,<span class="hljs-string">"orderId"</span>:<span class="hljs-number">7</span>,<span class="hljs-string">"productId"</span>:<span class="hljs-number">107</span>,<span class="hljs-string">"productNum"</span>:<span class="hljs-number">7</span>&#125;<br>| offset: <span class="hljs-number">1083</span> CreateTime: <span class="hljs-number">1615020877677</span> keysize: <span class="hljs-number">1</span> valuesize: <span class="hljs-number">63</span> sequence: <span class="hljs-number">-1</span> headerKeys: [] key: <span class="hljs-number">8</span> payload: &#123;<span class="hljs-string">"orderAmount"</span>:<span class="hljs-number">1000</span>,<span class="hljs-string">"orderId"</span>:<span class="hljs-number">8</span>,<span class="hljs-string">"productId"</span>:<span class="hljs-number">108</span>,<span class="hljs-string">"productNum"</span>:<span class="hljs-number">8</span>&#125;<br>| offset: <span class="hljs-number">1084</span> CreateTime: <span class="hljs-number">1615020877677</span> keysize: <span class="hljs-number">2</span> valuesize: <span class="hljs-number">65</span> sequence: <span class="hljs-number">-1</span> headerKeys: [] key: <span class="hljs-number">11</span> payload: &#123;<span class="hljs-string">"orderAmount"</span>:<span class="hljs-number">1000</span>,<span class="hljs-string">"orderId"</span>:<span class="hljs-number">11</span>,<span class="hljs-string">"productId"</span>:<span class="hljs-number">111</span>,<span class="hljs-string">"productNum"</span>:<span class="hljs-number">11</span>&#125;<br>| offset: <span class="hljs-number">1085</span> CreateTime: <span class="hljs-number">1615020877677</span> keysize: <span class="hljs-number">2</span> valuesize: <span class="hljs-number">65</span> sequence: <span class="hljs-number">-1</span> headerKeys: [] key: <span class="hljs-number">15</span> payload: &#123;<span class="hljs-string">"orderAmount"</span>:<span class="hljs-number">1000</span>,<span class="hljs-string">"orderId"</span>:<span class="hljs-number">15</span>,<span class="hljs-string">"productId"</span>:<span class="hljs-number">115</span>,<span class="hljs-string">"productNum"</span>:<span class="hljs-number">15</span>&#125;<br>| offset: <span class="hljs-number">1086</span> CreateTime: <span class="hljs-number">1615020877678</span> keysize: <span class="hljs-number">2</span> valuesize: <span class="hljs-number">65</span> sequence: <span class="hljs-number">-1</span> headerKeys: [] key: <span class="hljs-number">17</span> payload: &#123;<span class="hljs-string">"orderAmount"</span>:<span class="hljs-number">1000</span>,<span class="hljs-string">"orderId"</span>:<span class="hljs-number">17</span>,<span class="hljs-string">"productId"</span>:<span class="hljs-number">117</span>,<span class="hljs-string">"productNum"</span>:<span class="hljs-number">17</span>&#125;<br>| offset: <span class="hljs-number">1087</span> CreateTime: <span class="hljs-number">1615020877678</span> keysize: <span class="hljs-number">2</span> valuesize: <span class="hljs-number">65</span> sequence: <span class="hljs-number">-1</span> headerKeys: [] key: <span class="hljs-number">21</span> payload: &#123;<span class="hljs-string">"orderAmount"</span>:<span class="hljs-number">1000</span>,<span class="hljs-string">"orderId"</span>:<span class="hljs-number">21</span>,<span class="hljs-string">"productId"</span>:<span class="hljs-number">121</span>,<span class="hljs-string">"productNum"</span>:<span class="hljs-number">21</span>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="查看-Topic-中当前消息总数"><a href="#查看-Topic-中当前消息总数" class="headerlink" title="查看 Topic 中当前消息总数"></a>查看 Topic 中当前消息总数</h5><p>Kafka 自带的命令没有直接提供这样的功能，要使用 Kafka 提供的工具类 GetOffsetShell 来计算给定 Topic 每个分区当前最早位移和最新位移，差值就是每个分区的当前的消息总数，将该 Topic 所有分区的消息总数累加就能得到该 Topic 总的消息数。</p><p>首先查询 Topic 中每个分区 offset 的最小值（起始位置），使用 <code>--time -2</code>参数。一个分区的起始位置并不是每时每刻都为 0 ，因为日志清理的动作会清理旧的数据，所以分区的起始位置会自然而然地增加。</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">kafka-run-class</span><span class="hljs-selector-class">.sh</span> <span class="hljs-selector-tag">kafka</span><span class="hljs-selector-class">.tools</span><span class="hljs-selector-class">.GetOffsetShell</span> <span class="hljs-selector-tag">--broker-list</span> <span class="hljs-selector-tag">kafka1</span><span class="hljs-selector-pseudo">:9092</span> <span class="hljs-selector-tag">-topic</span> <span class="hljs-selector-tag">test-topic</span>  <span class="hljs-selector-tag">--time</span> <span class="hljs-selector-tag">-2</span><br><br>#前面是分区号，后面是 <span class="hljs-selector-tag">offset</span><br><span class="hljs-selector-tag">test-topic</span><span class="hljs-selector-pseudo">:0</span><span class="hljs-selector-pseudo">:0</span><br><span class="hljs-selector-tag">test-topic</span><span class="hljs-selector-pseudo">:1</span><span class="hljs-selector-pseudo">:0</span><br></code></pre></div></td></tr></table></figure><p>然后使用<code>--time -1</code>参数查询 Topic 各个分区的 offset 的最大值。</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">kafka-run-class</span><span class="hljs-selector-class">.sh</span> <span class="hljs-selector-tag">kafka</span><span class="hljs-selector-class">.tools</span><span class="hljs-selector-class">.GetOffsetShell</span> <span class="hljs-selector-tag">--broker-list</span> <span class="hljs-selector-tag">kafka1</span><span class="hljs-selector-pseudo">:9092</span> <span class="hljs-selector-tag">--time</span> <span class="hljs-selector-tag">-1</span> <span class="hljs-selector-tag">--topic</span> <span class="hljs-selector-tag">test-topic</span><br><br>#输出结果<br><span class="hljs-selector-tag">test-topic</span><span class="hljs-selector-pseudo">:0</span><span class="hljs-selector-pseudo">:5500000</span><br><span class="hljs-selector-tag">test-topic</span><span class="hljs-selector-pseudo">:1</span><span class="hljs-selector-pseudo">:5500000</span><br></code></pre></div></td></tr></table></figure><p>对于本例来说，test-topic 中当前总的消息数为 (5500000 - 0) + （5500000 - 0），等于 1100 万条。如果只是要获取 Topic 中总的消息数（包括已经从 Kafka 删除的消息），那么只需要将 Topic 中每个 Partition 的 Offset 累加即可。</p><h3 id="Offset"><a href="#Offset" class="headerlink" title="Offset"></a>Offset</h3><h4 id="重置消费者-Offset"><a href="#重置消费者-Offset" class="headerlink" title="重置消费者 Offset"></a>重置消费者 Offset</h4><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">#查看消费者组消费情况<br>#目前的 <span class="hljs-number">0</span> 分区 <span class="hljs-keyword">CURRENT</span>-<span class="hljs-keyword">OFFSET</span> 是 <span class="hljs-number">4</span>，<span class="hljs-number">2</span> 分区 <span class="hljs-keyword">CURRENT</span>-<span class="hljs-keyword">OFFSET</span> 是 <span class="hljs-number">6</span><br>kafka-consumer-<span class="hljs-keyword">groups</span>.sh <span class="hljs-comment">--bootstrap-server kafka1:9092 --describe --group my-consumer-group</span><br><br>#返回结果<br>Consumer <span class="hljs-keyword">group</span> <span class="hljs-string">'my-consumer-group'</span> has <span class="hljs-keyword">no</span> active members.<br><br><span class="hljs-keyword">GROUP</span>             TOPIC                 <span class="hljs-keyword">PARTITION</span>  <span class="hljs-keyword">CURRENT</span>-<span class="hljs-keyword">OFFSET</span>  <span class="hljs-keyword">LOG</span>-<span class="hljs-keyword">END</span>-<span class="hljs-keyword">OFFSET</span>  LAG             CONSUMER-ID     HOST            CLIENT-ID<br>my-consumer-<span class="hljs-keyword">group</span> <span class="hljs-keyword">transaction</span>-topic-msg <span class="hljs-number">2</span>          <span class="hljs-number">6</span>               <span class="hljs-number">6</span>               <span class="hljs-number">0</span>               -               -               -<br>my-consumer-<span class="hljs-keyword">group</span> <span class="hljs-keyword">transaction</span>-topic-msg <span class="hljs-number">1</span>          <span class="hljs-number">0</span>               <span class="hljs-number">0</span>               <span class="hljs-number">0</span>               -               -               -<br>my-consumer-<span class="hljs-keyword">group</span> <span class="hljs-keyword">transaction</span>-topic-msg <span class="hljs-number">0</span>          <span class="hljs-number">4</span>               <span class="hljs-number">4</span>               <span class="hljs-number">0</span>               -               -               -         -<br><br>#重置消费者组 <span class="hljs-keyword">offset</span> 为 <span class="hljs-number">3</span>，重置是所有分区一起重置<br>kafka-consumer-<span class="hljs-keyword">groups</span>.sh <span class="hljs-comment">--bootstrap-server kafka1:9092 --group my-consumer-group --reset-offsets --execute --to-offset 3 --topic transaction-topic-msg</span><br><br>#返回结果<br>[<span class="hljs-number">2021</span><span class="hljs-number">-06</span><span class="hljs-number">-25</span> <span class="hljs-number">10</span>:<span class="hljs-number">44</span>:<span class="hljs-number">51</span>,<span class="hljs-number">848</span>] WARN <span class="hljs-built_in">New</span> <span class="hljs-keyword">offset</span> (<span class="hljs-number">3</span>) <span class="hljs-keyword">is</span> higher than latest <span class="hljs-keyword">offset</span> <span class="hljs-keyword">for</span> topic <span class="hljs-keyword">partition</span> <span class="hljs-keyword">transaction</span>-topic-msg<span class="hljs-number">-1.</span> <span class="hljs-keyword">Value</span> will be <span class="hljs-keyword">set</span> <span class="hljs-keyword">to</span> <span class="hljs-number">0</span> (kafka.<span class="hljs-keyword">admin</span>.ConsumerGroupCommand$)<br><br><span class="hljs-keyword">GROUP</span>                          TOPIC                          <span class="hljs-keyword">PARTITION</span>  <span class="hljs-built_in">NEW</span>-<span class="hljs-keyword">OFFSET</span>     <br>my-consumer-<span class="hljs-keyword">group</span>              <span class="hljs-keyword">transaction</span>-topic-msg          <span class="hljs-number">0</span>          <span class="hljs-number">3</span>              <br>my-consumer-<span class="hljs-keyword">group</span>              <span class="hljs-keyword">transaction</span>-topic-msg          <span class="hljs-number">1</span>          <span class="hljs-number">0</span>              <br>my-consumer-<span class="hljs-keyword">group</span>              <span class="hljs-keyword">transaction</span>-topic-msg          <span class="hljs-number">2</span>          <span class="hljs-number">3</span>              <br><br>#可以看到 <span class="hljs-number">0</span> 分区和 <span class="hljs-number">2</span> 分区的 <span class="hljs-keyword">CURRENT</span>-<span class="hljs-keyword">OFFSET</span> 都变为 <span class="hljs-number">3</span> 了<br>kafka-consumer-<span class="hljs-keyword">groups</span>.sh <span class="hljs-comment">--bootstrap-server kafka1:9092 --describe --group my-consumer-group</span><br><br>#返回结果<br>Consumer <span class="hljs-keyword">group</span> <span class="hljs-string">'my-consumer-group'</span> has <span class="hljs-keyword">no</span> active members.<br><br><span class="hljs-keyword">GROUP</span>             TOPIC                 <span class="hljs-keyword">PARTITION</span>  <span class="hljs-keyword">CURRENT</span>-<span class="hljs-keyword">OFFSET</span>  <span class="hljs-keyword">LOG</span>-<span class="hljs-keyword">END</span>-<span class="hljs-keyword">OFFSET</span>  LAG             CONSUMER-ID     HOST            CLIENT-ID<br>my-consumer-<span class="hljs-keyword">group</span> <span class="hljs-keyword">transaction</span>-topic-msg <span class="hljs-number">2</span>          <span class="hljs-number">3</span>               <span class="hljs-number">6</span>               <span class="hljs-number">3</span>               -               -               -<br>my-consumer-<span class="hljs-keyword">group</span> <span class="hljs-keyword">transaction</span>-topic-msg <span class="hljs-number">1</span>          <span class="hljs-number">0</span>               <span class="hljs-number">0</span>               <span class="hljs-number">0</span>               -               -               -<br>my-consumer-<span class="hljs-keyword">group</span> <span class="hljs-keyword">transaction</span>-topic-msg <span class="hljs-number">0</span>          <span class="hljs-number">3</span>               <span class="hljs-number">4</span>               <span class="hljs-number">1</span>               -               -               -<br><br>#可以重新消费到之前的数据<br>kafka-console-consumer.sh <span class="hljs-comment">--bootstrap-server kafka1:9092 --topic transaction-topic-msg  --group my-consumer-group </span><br><br>#返回结果<br>message<span class="hljs-number">-111111</span><br>message<span class="hljs-number">-333333</span><br></code></pre></div></td></tr></table></figure><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">--num-records <span class="hljs-number">10000000</span>: 向指定主题发送了 <span class="hljs-number">1</span> 千万条消息。<br>--record-size <span class="hljs-number">1024</span>: 每条消息的大小为 <span class="hljs-number">1024</span>KB。<br>--throughput <span class="hljs-number">-1</span>: 不限制吞吐量。<br>--producer-props: 指定生产者参数。<br>    acks=<span class="hljs-number">-1</span>: 这要求 ISR 列表里跟 leader 保持同步的那些 follower 都要把消息同步过去，才能认为这条消息是写入成功。<br>    linger.ms=<span class="hljs-number">2000</span>: batch.size 和 linger.ms 是对 kafka producer 性能影响比较大的两个参数。batch.size 是 producer 批量发送的基本单位，默认是 <span class="hljs-number">16384</span>Bytes，即 <span class="hljs-number">16</span>kB；lingger.ms 是 sender 线程在检查 batch 是否 ready 时候，判断有没有过期的参数，默认大小是 <span class="hljs-number">0</span>ms。<br>    compression.type=lz4: 使用 lz4 压缩算法。<br></code></pre></div></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">[root@kafka1 ~]<span class="hljs-comment"># kafka-producer-perf-test.sh --topic test_producer_perf --num-records 10000000 --throughput -1 --record-size 1024 --producer-props bootstrap.servers=kafka1:9092 acks=-1 linger.ms=2000 compression.type=lz4</span><br><br><span class="hljs-comment">#输出结果</span><br><span class="hljs-number">705600</span> records sent, <span class="hljs-number">141063.6</span> records/sec (<span class="hljs-number">137.76</span> MB/sec), <span class="hljs-number">54.8</span> <span class="hljs-keyword">ms</span> <span class="hljs-title">avg</span> latency, <span class="hljs-number">557.0</span> <span class="hljs-keyword">ms</span> <span class="hljs-title">max</span> latency.<br><span class="hljs-number">1204178</span> records sent, <span class="hljs-number">240739.3</span> records/sec (<span class="hljs-number">235.10</span> MB/sec), <span class="hljs-number">44.1</span> <span class="hljs-keyword">ms</span> <span class="hljs-title">avg</span> latency, <span class="hljs-number">402.0</span> <span class="hljs-keyword">ms</span> <span class="hljs-title">max</span> latency.<br><span class="hljs-number">1370938</span> records sent, <span class="hljs-number">274187.6</span> records/sec (<span class="hljs-number">267.76</span> MB/sec), <span class="hljs-number">27.9</span> <span class="hljs-keyword">ms</span> <span class="hljs-title">avg</span> latency, <span class="hljs-number">311.0</span> <span class="hljs-keyword">ms</span> <span class="hljs-title">max</span> latency.<br><span class="hljs-number">1464605</span> records sent, <span class="hljs-number">292628.4</span> records/sec (<span class="hljs-number">285.77</span> MB/sec), <span class="hljs-number">19.2</span> <span class="hljs-keyword">ms</span> <span class="hljs-title">avg</span> latency, <span class="hljs-number">139.0</span> <span class="hljs-keyword">ms</span> <span class="hljs-title">max</span> latency.<br><span class="hljs-number">1477239</span> records sent, <span class="hljs-number">295447.8</span> records/sec (<span class="hljs-number">288.52</span> MB/sec), <span class="hljs-number">31.8</span> <span class="hljs-keyword">ms</span> <span class="hljs-title">avg</span> latency, <span class="hljs-number">290.0</span> <span class="hljs-keyword">ms</span> <span class="hljs-title">max</span> latency.<br><span class="hljs-number">1446682</span> records sent, <span class="hljs-number">289336.4</span> records/sec (<span class="hljs-number">282.56</span> MB/sec), <span class="hljs-number">26.4</span> <span class="hljs-keyword">ms</span> <span class="hljs-title">avg</span> latency, <span class="hljs-number">281.0</span> <span class="hljs-keyword">ms</span> <span class="hljs-title">max</span> latency.<br><span class="hljs-number">1555098</span> records sent, <span class="hljs-number">311019.6</span> records/sec (<span class="hljs-number">303.73</span> MB/sec), <span class="hljs-number">37.6</span> <span class="hljs-keyword">ms</span> <span class="hljs-title">avg</span> latency, <span class="hljs-number">344.0</span> <span class="hljs-keyword">ms</span> <span class="hljs-title">max</span> latency.<br><span class="hljs-number">10000000</span> records sent, <span class="hljs-number">263894.020162</span> records/sec (<span class="hljs-number">257.71</span> MB/sec), <span class="hljs-number">32.60</span> <span class="hljs-keyword">ms</span> <span class="hljs-title">avg</span> latency, <span class="hljs-number">557.00</span> <span class="hljs-keyword">ms</span> <span class="hljs-title">max</span> latency, <span class="hljs-number">12</span> <span class="hljs-keyword">ms</span> <span class="hljs-title">50th</span>, <span class="hljs-number">140</span> <span class="hljs-keyword">ms</span> <span class="hljs-title">95th</span>, <span class="hljs-number">262</span> <span class="hljs-keyword">ms</span> <span class="hljs-title">99th</span>, <span class="hljs-number">396</span> <span class="hljs-keyword">ms</span> <span class="hljs-title">99</span>.<span class="hljs-number">9</span>th.<br></code></pre></div></td></tr></table></figure><p>我们应该关心延时的概率分布情况，仅仅知道一个平均值是没有意义的。这就是这里计算分位数的原因。通常我们关注到 99th 分位就可以了。比如在上面的输出中，99th 值是 262 ms，这表明测试生产者生产的消息中，有 99% 消息的延时都在 262 ms 以内。你完全可以把这个数据当作这个生产者对外承诺的 SLA。</p><h5 id="消费者性能测试"><a href="#消费者性能测试" class="headerlink" title="消费者性能测试"></a>消费者性能测试</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-attr">[root@kafka1 ~]</span># <span class="hljs-selector-tag">kafka-consumer-perf-test</span><span class="hljs-selector-class">.sh</span> <span class="hljs-selector-tag">--broker-list</span> <span class="hljs-selector-tag">kafka1</span><span class="hljs-selector-pseudo">:9092</span> <span class="hljs-selector-tag">--messages</span> 10000000 <span class="hljs-selector-tag">--topic</span> <span class="hljs-selector-tag">test_producer_perf</span><br><br>#输出结果<br><span class="hljs-selector-tag">start</span><span class="hljs-selector-class">.time</span>, <span class="hljs-selector-tag">end</span><span class="hljs-selector-class">.time</span>, <span class="hljs-selector-tag">data</span><span class="hljs-selector-class">.consumed</span><span class="hljs-selector-class">.in</span><span class="hljs-selector-class">.MB</span>, <span class="hljs-selector-tag">MB</span><span class="hljs-selector-class">.sec</span>, <span class="hljs-selector-tag">data</span><span class="hljs-selector-class">.consumed</span><span class="hljs-selector-class">.in</span><span class="hljs-selector-class">.nMsg</span>, <span class="hljs-selector-tag">nMsg</span><span class="hljs-selector-class">.sec</span>, <span class="hljs-selector-tag">rebalance</span><span class="hljs-selector-class">.time</span><span class="hljs-selector-class">.ms</span>, <span class="hljs-selector-tag">fetch</span><span class="hljs-selector-class">.time</span><span class="hljs-selector-class">.ms</span>, <span class="hljs-selector-tag">fetch</span><span class="hljs-selector-class">.MB</span><span class="hljs-selector-class">.sec</span>, <span class="hljs-selector-tag">fetch</span><span class="hljs-selector-class">.nMsg</span><span class="hljs-selector-class">.sec</span><br>2021<span class="hljs-selector-tag">-03-09</span> 10<span class="hljs-selector-pseudo">:34</span><span class="hljs-selector-pseudo">:18</span><span class="hljs-selector-pseudo">:447</span>, 2021<span class="hljs-selector-tag">-03-09</span> 10<span class="hljs-selector-pseudo">:34</span><span class="hljs-selector-pseudo">:33</span><span class="hljs-selector-pseudo">:948</span>, 9765<span class="hljs-selector-class">.6250</span>, 629<span class="hljs-selector-class">.9997</span>, 10000000, 645119<span class="hljs-selector-class">.6697</span>, 1615257259068, <span class="hljs-selector-tag">-1615257243567</span>, <span class="hljs-selector-tag">-0</span><span class="hljs-selector-class">.0000</span>, <span class="hljs-selector-tag">-0</span><span class="hljs-selector-class">.0062</span><br></code></pre></div></td></tr></table></figure><p>虽然输出格式有所差别，但该脚本也会打印出消费者的吞吐量数据。比如本例中的 629.9997MB/s。有点令人遗憾的是，它没有计算不同分位数下的分布情况。因此，在实际使用过程中，这个脚本的使用率要比生产者性能测试脚本的使用率低。</p><h3 id="修改动态参数"><a href="#修改动态参数" class="headerlink" title="修改动态参数"></a>修改动态参数</h3><h5 id="修改-Broker-动态参数"><a href="#修改-Broker-动态参数" class="headerlink" title="修改 Broker 动态参数"></a>修改 Broker 动态参数</h5><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">修改动态参数无需重启 <span class="hljs-keyword">Broker，动态 </span><span class="hljs-keyword">Broker </span>参数的使用场景非常广泛，通常包括但不限于以下几种：<br><br>动态调整 <span class="hljs-keyword">Broker </span>端各种线程池大小，实时应对突发流量。<br>动态调整 <span class="hljs-keyword">Broker </span>端连接信息或安全配置信息。<br>动态更新 SSL Keystore 有效期。<br>动态调整 <span class="hljs-keyword">Broker </span>端 Compact 操作性能。<br>实时变更 <span class="hljs-keyword">JMX </span>指标收集器 (<span class="hljs-keyword">JMX </span>Metrics Reporter)。<br>Kafka <span class="hljs-keyword">Broker </span><span class="hljs-built_in">Config</span> 的参数有以下 <span class="hljs-number">3</span> 种类型：<br><br>read-only：被标记为 read-only 的参数和原来的参数行为一样，只有重启 <span class="hljs-keyword">Broker，才能令修改生效。</span><br><span class="hljs-keyword">per-broker：被标记为 </span>per-<span class="hljs-keyword">broker </span>的参数属于动态参数，修改它之后，只会在对应的 <span class="hljs-keyword">Broker </span>上生效。<br>cluster-wide：被标记为 cluster-wide 的参数也属于动态参数，修改它之后，会在整个集群范围内生效，也就是说，对所有 <span class="hljs-keyword">Broker </span>都生效。你也可以为具体的 <span class="hljs-keyword">Broker </span>修改 cluster-wide 参数。<br>在集群层面设置全局值，即设置 cluster-wide 范围值，将 unclean.leader.election.enable 参数在集群层面设置为 true。<br></code></pre></div></td></tr></table></figure><p>释案</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kafka-configs.sh --bootstrap-server  10.37.249.58:9092 \<br>--entity-type brokers --entity-default --alter \<br>--add-config unclean.leader.election.<span class="hljs-attribute">enable</span>=<span class="hljs-literal">true</span><br><br><span class="hljs-comment">#返回结果</span><br>Completed updating<span class="hljs-built_in"> default config </span><span class="hljs-keyword">for</span> brokers <span class="hljs-keyword">in</span> the cluster.<br></code></pre></div></td></tr></table></figure><p>如果要设置 cluster-wide 范围的动态参数，需要显式指定 entity-default。现在，我们使用下面的命令来查看一下刚才的配置是否成功。</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kafka-configs.sh --bootstrap-server 10.37.249.58:9092 \<br>--entity-type brokers --entity-default --describe<br><br><span class="hljs-comment">#返回结果</span><br>Default configs <span class="hljs-keyword">for</span> brokers <span class="hljs-keyword">in</span> the cluster are:<br>  unclean.leader.election.<span class="hljs-attribute">enable</span>=<span class="hljs-literal">true</span> <span class="hljs-attribute">sensitive</span>=<span class="hljs-literal">false</span> synonyms=&#123;DYNAMIC_DEFAULT_BROKER_CONFIG:unclean.leader.election.<span class="hljs-attribute">enable</span>=<span class="hljs-literal">true</span>&#125;<br></code></pre></div></td></tr></table></figure><p>在 Zookeeper 上查看 /config/brokers/ 节点可以查看 cluster-wide 的动态参数设置。</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">[zk: (CONNECTED) ] &gt; get /config/brokers/1</span><br><span class="hljs-section">&#123;"version":1,"config":&#123;"unclean.leader.election.enable":"false"&#125;&#125;</span><br>cZxid = 17179869574<br>ctime = 1631246495120<br>mZxid = 17179869574<br>mtime = 1631246495120<br>pZxid = 17179869574<br>cversion = 0<br>dataVersion = 0<br>aclVersion = 0<br>ephemeralOwner = 0<br>dataLength = 65<br>numChildren = 0[zk: (CONNECTED) ] &gt; get /config/brokers/&lt;default&gt;[zk: (CONNECTED) ] &gt; get /config/brokers/1<br></code></pre></div></td></tr></table></figure><p>删除 cluster-wide 范围动态参数。</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kafka-configs.sh --bootstrap-server 10.37.249.58:9092 \<br>--entity-type brokers --entity-default --alter \<br>--delete-config unclean.leader.election.enable<br><br><span class="hljs-comment">#返回结果</span><br>Completed updating<span class="hljs-built_in"> default config </span><span class="hljs-keyword">for</span> brokers <span class="hljs-keyword">in</span> the cluster.<br></code></pre></div></td></tr></table></figure><p>删除 per-broker 范围参数。</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kafka-configs.sh --bootstrap-server 10.37.249.58:9092 \<br>--entity-type brokers --entity-name 1 --alter \<br>--delete-config unclean.leader.election.enable<br><br><span class="hljs-comment">#返回结果</span><br>Completed updating<span class="hljs-built_in"> config </span><span class="hljs-keyword">for</span> broker 1.<br></code></pre></div></td></tr></table></figure><p>修改 Topic 动态参数<br>设置 Topic test-topic 的 <code>retention.ms</code> 为 10000。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">kafka-configs.sh --bootstrap-server  <span class="hljs-number">10.37</span><span class="hljs-number">.249</span><span class="hljs-number">.58</span>:<span class="hljs-number">9092</span> \<br>--entity-type topics --entity-name test-topic --alter \<br>--add-config retention.ms=<span class="hljs-number">10000</span><br></code></pre></div></td></tr></table></figure><p>查看设置的 Topic 动态参数。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">kafka-configs.sh --bootstrap-server  <span class="hljs-number">10.37</span><span class="hljs-number">.249</span><span class="hljs-number">.58</span>:<span class="hljs-number">9092</span> \<br>--entity-type topics --entity-name test-topic --describe<br><br>#返回结果<br>Dynamic configs <span class="hljs-keyword">for</span> topic test-topic are:<br>  retention.ms=<span class="hljs-number">10000</span> sensitive=<span class="hljs-literal">false</span> synonyms=&#123;DYNAMIC_TOPIC_CONFIG:retention.ms=<span class="hljs-number">10000</span>&#125;<br></code></pre></div></td></tr></table></figure><p>在 Zookeeper 上可以查看 /config/topics/ 来查看 Topic 动态参数。</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">[zk: (CONNECTED) ] &gt; get /config/topics/test-topic</span><br><span class="hljs-section">&#123;"version":1,"config":&#123;"retention.ms":"10000"&#125;&#125;</span><br>cZxid = 17179869460<br>ctime = 1631245744105<br>mZxid = 17179869619<br>mtime = 1631250116481<br>pZxid = 17179869460<br>cversion = 0<br>dataVersion = 10<br>aclVersion = 0<br>ephemeralOwner = 0<br>dataLength = 47<br>numChildren = 0[zk: (CONNECTED) ] &gt; get /config/topics/test-topic<br></code></pre></div></td></tr></table></figure><p>删除 Topic 动态参数。</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">kafka-configs</span><span class="hljs-selector-class">.sh</span> <span class="hljs-selector-tag">--bootstrap-server</span>  10<span class="hljs-selector-class">.37</span><span class="hljs-selector-class">.249</span><span class="hljs-selector-class">.58</span><span class="hljs-selector-pseudo">:9092</span> \<br><span class="hljs-selector-tag">--entity-type</span> <span class="hljs-selector-tag">topics</span> <span class="hljs-selector-tag">--entity-name</span> <span class="hljs-selector-tag">test-topic</span> <span class="hljs-selector-tag">--alter</span> \<br><span class="hljs-selector-tag">--delete-config</span> <span class="hljs-selector-tag">retention</span><span class="hljs-selector-class">.ms</span><br></code></pre></div></td></tr></table></figure><h3 id="Kafka-集群一键启动-停止脚本"><a href="#Kafka-集群一键启动-停止脚本" class="headerlink" title="Kafka 集群一键启动/停止脚本"></a>Kafka 集群一键启动/停止脚本</h3><h4 id="环境变量设置："><a href="#环境变量设置：" class="headerlink" title="环境变量设置："></a>环境变量设置：</h4><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros"><span class="hljs-comment">#/etc/profile 文件</span><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">KAFKA_HOME</span>=/usr/local/kafka<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$PATH</span>:$KAFKA_HOME/bin<br></code></pre></div></td></tr></table></figure><p>一键启动/停止脚本，查看状态需要安装 jps 工具。</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros"><span class="hljs-comment">#! /bin/bash</span><br><span class="hljs-comment"># 填写 Kafka Broker 节点地址</span><br>hosts=(kafka1 kafka2 kafka3)<br><br><span class="hljs-comment"># 打印启动分布式脚本信息</span><br><span class="hljs-attribute">mill</span>=`date <span class="hljs-string">"+%N"</span>`<br><span class="hljs-attribute">tdate</span>=`date <span class="hljs-string">"+%Y-%m-%d %H:%M:%S,<span class="hljs-variable">$&#123;mill:0:3&#125;</span>"</span>`<br><br>echo [<span class="hljs-variable">$tdate</span>] <span class="hljs-builtin-name">INFO</span> [Kafka Cluster] begins <span class="hljs-keyword">to</span> execute the <span class="hljs-variable">$1</span> operation.<br><br><span class="hljs-comment"># 执行分布式开启命令</span><br>function start()<br>&#123;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-variable">$&#123;hosts[@]&#125;</span><br>                <span class="hljs-keyword">do</span><br>                        <span class="hljs-attribute">smill</span>=`date <span class="hljs-string">"+%N"</span>`<br>                        <span class="hljs-attribute">stdate</span>=`date <span class="hljs-string">"+%Y-%m-%d %H:%M:%S,<span class="hljs-variable">$&#123;smill:0:3&#125;</span>"</span>`<br>                        ssh root@<span class="hljs-variable">$i</span> <span class="hljs-string">"source /etc/profile;echo [<span class="hljs-variable">$stdate</span>] INFO [Kafka Broker <span class="hljs-variable">$i</span>] begins to execute the startup operation.;kafka-server-start.sh <span class="hljs-variable">$KAFKA_HOME</span>/config/server.properties&gt;/dev/null"</span> &amp;<br>                        sleep 1<br>                done<br>&#125;<br><br><span class="hljs-comment"># 执行分布式关闭命令</span><br>function stop()<br>&#123;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-variable">$&#123;hosts[@]&#125;</span><br>                <span class="hljs-keyword">do</span><br>                        <span class="hljs-attribute">smill</span>=`date <span class="hljs-string">"+%N"</span>`<br>                        <span class="hljs-attribute">stdate</span>=`date <span class="hljs-string">"+%Y-%m-%d %H:%M:%S,<span class="hljs-variable">$&#123;smill:0:3&#125;</span>"</span>`<br>                        ssh root@<span class="hljs-variable">$i</span> <span class="hljs-string">"source /etc/profile;echo [<span class="hljs-variable">$stdate</span>] INFO [Kafka Broker <span class="hljs-variable">$i</span>] begins to execute the shutdown operation.;kafka-server-stop.sh&gt;/dev/null;"</span> &amp;<br>                        sleep 1<br>                done<br>&#125;<br><br><span class="hljs-comment"># 查看 Kafka Broker 节点状态</span><br>function status()<br>&#123;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-variable">$&#123;hosts[@]&#125;</span><br>                <span class="hljs-keyword">do</span><br>                        <span class="hljs-attribute">smill</span>=`date <span class="hljs-string">"+%N"</span>`<br>                        <span class="hljs-attribute">stdate</span>=`date <span class="hljs-string">"+%Y-%m-%d %H:%M:%S,<span class="hljs-variable">$&#123;smill:0:3&#125;</span>"</span>`<br>                        ssh root@<span class="hljs-variable">$i</span> <span class="hljs-string">"source /etc/profile;echo [<span class="hljs-variable">$stdate</span>] INFO [Kafka Broker <span class="hljs-variable">$i</span>] status message is :;jps | grep Kafka;"</span> &amp;<br>                        sleep 1<br>                done<br>&#125;<br><br><span class="hljs-comment"># 判断输入的 Kafka 命令参数是否有效</span><br>case <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span> <span class="hljs-keyword">in</span><br>    start)<br>        start<br>        ;;<br>    stop)<br>        stop<br>        ;;<br>    status)<br>        status<br>        ;;<br>    *)<br>        echo <span class="hljs-string">"Usage: <span class="hljs-variable">$0</span> &#123;start|stop|status&#125;"</span><br>        <span class="hljs-attribute">RETVAL</span>=1<br>esac<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>冒个泡</title>
    <link href="/2022/11/02/%E5%86%92%E4%B8%AA%E6%B3%A1/"/>
    <url>/2022/11/02/%E5%86%92%E4%B8%AA%E6%B3%A1/</url>
    
    <content type="html"><![CDATA[<p>最近的大事记<br>最近半年最大的事儿是离职。10月的最后一天，我从呆了四年的DaoCloud离职<br>讲真 我内心是非常不舍的。虽然我到现在还是很菜，不管是运维、交付、售前、解决方案 都没有达到资深阶段。<br>但是很感激DaoCloud给我试错的机会。</p><p>我是一个非常喜欢折腾的人，在一个舒适圈待久了我会主动刺破。去寻求新的爽点。<br>在DaoCloud的这四年中我的职能转变还挺有意思。</p><p>在浦发银行的驻场运维<br>项目上的核心运维开发<br>转部门到IOG的海尔项目交付<br>再从IOG内部转岗，新路带我做售前解决方案<br>接下来部门发生大动荡，我没有选择离开，被迫从我喜欢的售前岗位转岗成为交付小组组长<br>一直到离职前的岗位是生态小组。</p><p>哈哈，四年转了这么多岗位。真的不是我在一个岗位待不下去了才转岗的。基本都是主动的操作。<br>其实内心很清楚，我在今年年初就应该离开DaoCloud了。</p><p>第一个是因为个人重心，以后肯定是在武汉了。<br>第二个是我在DaoCloud实在学习不到我感兴趣的东西了。<br>但是一直没走的原因，很直白 就是害怕。害怕失去这一份看起来稳定的工作，害怕因为疫情的阶段，出去生存会更加艰难。</p><p>正常情况下 我在DaoCloud去不去公司基本都没人说我，只要相关时间点交付东西就行。</p><p>这几年的状态下来，导致我个人在DaoCloud的时间非常散漫。(虽然我没有浪费时间，其实在干其他事儿)</p><p>这就是我的舒适圈，我深知，我应该突破舒适圈了。<br>一直苟着，苟到啥时候呢？</p><p>大家都劝我，<br>今年行情不好。<br>快过年啦，拿完年终奖再走。<br>没必要，从新找工作你确定能比现在好的？反而容错率更低。<br>在这里大家都知根知底了，干事儿比较好操作。<br>。。。。</p><p>这些问题其实我都回答不上。<br>但是我知道我要走是肯定了的，迟早的事情。</p><p>那不如就现在吧，趁我在DaoCloud人设还没崩，趁我暂时还无需为自己的经济问题操心的时候。迈出这一步，甚至可以休息一段时间。</p><p>在DaoCloud这段时间我完成了我个人的很多关键节点。<br>工作职能的转型，眼界的开拓，在期间结了婚。工资+自己有一些副业，让自己经济有了很大改观。</p><p>我自我定义在DaoCloud以及前面的工作经历，是我整个人生工作经历的初级阶段，也是第一个阶段。</p><p>我现在需要好好思考一下 我的下一个阶段路怎么走。</p><p>我发现身边很多人其实没有想过未来规划的事情，真的很可怕。</p><p>我希望能做自己人生的棋手，而不是永远是别人的棋子。</p><p>共勉</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>武汉的早点</title>
    <link href="/2022/04/22/%E6%AD%A6%E6%B1%89%E7%9A%84%E6%97%A9%E7%82%B9/"/>
    <url>/2022/04/22/%E6%AD%A6%E6%B1%89%E7%9A%84%E6%97%A9%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="在武汉，起早不为自律，而是为了早餐自由。"><a href="#在武汉，起早不为自律，而是为了早餐自由。" class="headerlink" title="在武汉，起早不为自律，而是为了早餐自由。"></a>在武汉，起早不为自律，而是为了早餐自由。</h2><p>单独出战的重油烧麦、面窝、油饺、欢喜坨已经是强者如林，而面和粉的交锋，更是精彩绝伦。糯米包油条、油饼夹烧麦这种碳水+碳水的组合，更是碳水的N次方，快乐无极限！</p><p><img src="/img/newimg/e6c9d24egy1h1ip3zjbf0j20u016w10f.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/newimg/e6c9d24egy1h1ip04k7bdj20u0179gsc.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/newimg/e6c9d24egy1h1ip0fwfhpj20u0181ajk.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/newimg/e6c9d24egy1h1ip1v71wmj20u017en4b.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/newimg/e6c9d24egy1h1ip261lc2j20u017hjzi.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/newimg/e6c9d24egy1h1ip2hzgf2j20u017kakq.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/newimg/e6c9d24egy1h1ip2qh3f4j20u017rn3a.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/newimg/e6c9d24egy1h1ip2yra21j20u017gq8y.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/newimg/e6c9d24egy1h1ip35mc3mj20u017en4d.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/newimg/e6c9d24egy1h1ip3g0vtoj20u0175dnd.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/newimg/e6c9d24egy1h1ip3q3wn0j20u017l7ay.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/newimg/e6c9d24egy1h1ip479kcej20t816atfj.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/newimg/e6c9d24egy1h1ip4jjmhwj20qm12gtdd.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/newimg/e6c9d24egy1h1ip4xprm5j20u017odnv.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/newimg/e6c9d24egy1h1ip59ggg3j20u017tdmc.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/newimg/e6c9d24egy1h1ip5l3lqqj20u017jguz.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>售前的成长路径</title>
    <link href="/2022/04/18/%E5%94%AE%E5%89%8D%E7%9A%84%E6%88%90%E9%95%BF%E8%B7%AF%E5%BE%84/"/>
    <url>/2022/04/18/%E5%94%AE%E5%89%8D%E7%9A%84%E6%88%90%E9%95%BF%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<p>最近有在想售前这个岗位到底是啥样的，如何认知、定位的，做好售前的全蓝图要求是什么？</p><p>我本身不是做售前出身的。从最开始的客服-&gt;运维-&gt;开发-&gt;架构-&gt;售前 一路走过来有了一些自己的感慨和感悟如下：</p><h3 id="基础素质"><a href="#基础素质" class="headerlink" title="基础素质"></a>基础素质</h3><p>如果要做好一个售前，应该具备一定的学习力，领悟力和抗压力，人的一生应该都在持续学习，抗压能力是要肩担重任必要的基础条件，领悟力一定程度决定了你可以走多远。</p><p>同时售前应该也要具备信心，细心和耐心。有没有信心的售前给人会有不一样的感觉，如果自己对自家的产品或自己的解决方案都不满意，又如何推销给客户。细心是一个好售前应该具备的品质，它不但可以最大量避免犯错，而且还可能从多个方面挖掘出一些隐藏的细节。好多项目前期都是马拉松式的拉锯和博弈，往大了说有些项目需要一年半载才能签单，往小了说我们可能要一遍又一遍地有策略地引导有利于自己的需求，这都需要耐心，有的时候可能还要用上一定的技巧。</p><h3 id="基础能力层"><a href="#基础能力层" class="headerlink" title="基础能力层"></a>基础能力层</h3><p>售前需要在技术、产品和业务中不断精深自己，物联网行业的售前应该具备常见的智能设备，网络，软件，数据库和接口协议的技术储备，不需要你各个方面都很精，但起码要懂得一些基础原理。如果是厂商售前应该要对自己的产品有足够的专注力，说起自己的产品能够如数家珍。客户的需求绝对是基于业务的，抛开业务谈需求和技术指标都是在耍流氓。</p><p>看到一个老售前对售前工作的归类，我觉得挺有道理，这边借鉴一下，他把售前工作分成两大类：</p><h3 id="售前事务能力"><a href="#售前事务能力" class="headerlink" title="售前事务能力"></a>售前事务能力</h3><p>这个包括销售过程支持能力和沟通呈现能力。</p><p>其中沟通呈现能力主要有对话沟通和呈现沟通。销售过程就有很多了，有客户需要获取、需求分析、业务场景分析、痛点分析、方案设计、售前宣讲、标书编制、应标答疑，再厉害点的售前可能还可以做客情分析，应标策略等。当然在定位行业，我们可能还包括现场勘察，演示等。</p><h3 id="售前咨询能力"><a href="#售前咨询能力" class="headerlink" title="售前咨询能力"></a>售前咨询能力</h3><p>这个包括了解决方案重构加工能力和业务、问题解决能力。</p><p>解决方案重构加工能力是一个售前的核心竞争力，具备如何等级的加工能力写出来的方案应该不一样，越资深的，方案的颗粒度应该越小。</p><p>能业务洞察、业务分解、流程梳理、需求分析和痛点诊断是一个售前要进阶到好售前必须要做、能做的。</p><p>那售前应该如何定位呢</p><h3 id="售前自我定位"><a href="#售前自我定位" class="headerlink" title="售前自我定位"></a>售前自我定位</h3><h4 id="技术支持级"><a href="#技术支持级" class="headerlink" title="技术支持级"></a>技术支持级</h4><p>这是最初级的，和销售打打配合，吹吹产品，解决些普遍的技术问题（大部分是口头上的，不涉及具体操作），偶尔写写方案，而且一般是到网上或其他途径摘抄，自己来组织组织，感觉就是个技术销售。</p><h4 id="工程师级"><a href="#工程师级" class="headerlink" title="工程师级"></a>工程师级</h4><p>这类基本上已经具备了一个合格甚至是优秀的售前的雏形。首先，他们的专业知识相当深厚，并且能言善辩，已经步入专业人士之流。其次，已经有了一个广泛的良好的客户网络，和销售的客户网络不同，售前的客户对他们有更多的信赖，而不只是单纯的利益关系，这来源于他们的专业。更好点的还具备一定的管理经验，但还未脱离公司，而且是以公司的业务为主。他们的方案有更多的自己的设计和想法，也更具针对性。</p><h4 id="顾问级"><a href="#顾问级" class="headerlink" title="顾问级"></a>顾问级</h4><p>这就是售前的终极Boss。他们可以是在家办公的自由职业者,也可以自主创业，还可以长期给一家或几家单位当顾问。一般在这之前都是资深的售前，有过多年的丰富行业经验和技术背景，不要求熟悉很多领域，但绝对是某个领域的高级专家，一发话万人敬仰那种。</p>]]></content>
    
    
    
    <tags>
      
      <tag>售前</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>售前是什么</title>
    <link href="/2022/04/18/%E5%94%AE%E5%89%8D%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2022/04/18/%E5%94%AE%E5%89%8D%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<p>怎样做好售前这个问题一直在困扰我，想了一阵感觉还是没有很清晰的思路，总感觉哪里没有弄明白，后来有一天我对自己反问：售前是什么？脑子竟然一时模糊，不能很快的组织语言描述。对啊，是不是自己就没有从根本上搞清楚售前是什么，为什么会有售前这个岗位，没有对售前岗位有很好的理解和认知，所以总感觉念头不通达。在售前的面试中，我也时常问候选人“帮忙说一下你对售前岗位的理解”，确实也得到了很多答案，总的归纳如下：</p><blockquote><p>售前的工作内容，包括：<br> 配合销售，拿下订单、宣讲、演示、方案设计与编写、投标答标、配置报价、竞争性谈判、向交付团队交底项目前期信息、项目后期支持跟进等；</p><p>售前的工作价值，包括：<br> 架设起公司内部与客户应用之间的桥梁、实现技术营销、通过自己的努力实现公司和客户的双赢、提供最佳路径、规避风险、获得客户信任、业务应用专家等；</p><p>售前的分类：<br> 技术支持型售前、解决方案型售前、顾问型售前等；</p></blockquote><p>从不同的维度分析售前应该做什么，实现什么，最终要达成什么，如果平时有一定的观察、思考和归纳能力，这些是水到渠成的。我试着从其他方面去解读售前，有可能会更加提高自己对售前的认知。为什么我要花一定时间去真正深入了解售前呢，我觉得售前之间的能力差异，很大一部分是由于人们对售前认知能力上的差异，因为认知会影响选择，选择改变一个人的命运，所以售前人员成长的高低本质上是被售前认知的深浅导致的。我们可以试着从以下几个方面看看能不能深入的了解售前，了解售前到底是什么？</p><h2 id="你在售前成长模型的哪一层"><a href="#你在售前成长模型的哪一层" class="headerlink" title="你在售前成长模型的哪一层"></a>你在售前成长模型的哪一层</h2><p>罗伯特·迪尔茨和格雷戈里·贝特森创立了NLP（Neuro-Linguistic Programming，中文意思是用神经语言改变行为程序），逻辑层次模型。这个模型把人的思维和觉知分为6个层次，自下而上分别是：环境、行为、能力、信念和价值观、自我意识、使命，如下：</p><p><img src="/img/newimg/e6c9d24egy1h1dplzb497j20u00vyabr.jpg" srcset="/img/loading.gif" alt=""></p><p>这个模型，让我立刻联想到售前的成长等级也非常适用。售前成长过程中，我们必然会遇到很多问题，我们如何对待问题的态度就很关键，因为从中可以看出售前的成长等级，而NLP逻辑层次模型就可以作为衡量售前成长等级的标尺。</p><h3 id="第一层：环境"><a href="#第一层：环境" class="headerlink" title="第一层：环境"></a>第一层：环境</h3><p>在这一层的售前人员遇到问题，往往第一反应或一味地先找外界环境因素的问题，从来不从自己身上找原因。如投标失败后，先一味地反馈是由于商务策略的问题，导致丢单或流标，不能反思自己在投标阶段中哪一点是否可以做的更好，防止今后遇到类似的问题。在这一层的人员，情绪不是很稳定，往往喜欢抱怨。</p><h3 id="第二层：行为"><a href="#第二层：行为" class="headerlink" title="第二层：行为"></a>第二层：行为</h3><p>在这一层的售前人员，不会过多抱怨，会积极地寻找自己是否足够努力。往往看起来是一个行动派，分配任务后，就埋头苦干，一般很少主动去探究任务的产生背景、做成这个事好坏的评判标准、效率是否足够高、是否可以给人带来价值等。努力是一个很重要的成长特质，但如果努力成为了做事的唯一标准后，人们就会忽略其他重要的因素，只用努力来欺骗自己。</p><h3 id="第三层：能力"><a href="#第三层：能力" class="headerlink" title="第三层：能力"></a>第三层：能力</h3><p>在这一层的售前人员开始动脑了，他们的工作会讲究方法、策略，做人做事会有一定的章法、套路，更关注自身的能力是否可以提高。能力往往会成为他们的唯一标准，有的时候会刻意的“挑活”，还会更关注做事的方法论，总觉得远方存在更好的方法来解决当前的问题，反而忽略了曾经陪伴自己走向成长的踏实和努力。</p><h3 id="第四层：信念和价值观"><a href="#第四层：信念和价值观" class="headerlink" title="第四层：信念和价值观"></a>第四层：信念和价值观</h3><p>在这一层的售前人员会主动思考做事的意义，我们为什么要做这个事，做什么事是更重要的，什么事是最重要的。同时来了很多售前项目，哪个售前项目优先做，哪个售前项目后面做，哪些项目我是要大力做，哪些项目我是微微地支持一下。我们总不能按照先来后到，一定是有一个权重来供你做选择。其实我们做某一件事的开始阶段，总是可以专注它，但随着时间的推移，繁杂的琐事总是让你分心，同时由于人的天性，总想急于求成同时做好多事，导致每件事可能都做不好。在这个层次的人员是有智慧克服这个天性，让自己确实在做应该要做的事。</p><h3 id="第五层：自我意识"><a href="#第五层：自我意识" class="headerlink" title="第五层：自我意识"></a>第五层：自我意识</h3><p>在这一层的售前人员已经主动开始对自己进行心理建设，他们会花大量的时间去思考：我想成为一个怎么样的售前人员，什么样的售前风格更符合自己。暗示自己就是会成为受人尊重的顶级售前，具备内在驱动，能从上而下或从里而外地改变自己。其实成长就是将内在身份不断揉碎并重塑的动态过程，在这一层的售前人员是真正的觉醒者。</p><h3 id="第六层：使命"><a href="#第六层：使命" class="headerlink" title="第六层：使命"></a>第六层：使命</h3><p>追求使命的不一定都是伟人，像我们这样的普通人也是可以有使命的，只要在我们的能力范围内对他人产生积极的影响即可。有了使命追求，我们就能催生出真正的人生目标，就能不畏艰难，勇往直前。</p><p>你是否可以停下来，好好思考一下，看看自己在售前成长模型的哪一层？</p><hr><p>一个售前，改变自己的关键就是创造价值，也就是利他性。只有当自身创造的价值足够大时，我们才能被别人强烈需要。售前人应该时常反问自己，我做的事是否给别人带来了价值，是短期价值还是长期价值，可以做为一个审判自己工作是否有效的有力标准之一，经常这样思考，我认为他就会看到新的天地。当然，走价值积累之路是需要保持耐心和远见的，因为价值的产生需要过程，一旦你选定了价值之路，就要消除自我怀疑，保持坚定。</p>]]></content>
    
    
    
    <tags>
      
      <tag>售前</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>售前针对不同级别客户的片子逻辑</title>
    <link href="/2022/04/18/%E5%94%AE%E5%89%8D%E9%92%88%E5%AF%B9%E4%B8%8D%E5%90%8C%E7%BA%A7%E5%88%AB%E5%AE%A2%E6%88%B7%E7%9A%84%E7%89%87%E5%AD%90%E9%80%BB%E8%BE%91/"/>
    <url>/2022/04/18/%E5%94%AE%E5%89%8D%E9%92%88%E5%AF%B9%E4%B8%8D%E5%90%8C%E7%BA%A7%E5%88%AB%E5%AE%A2%E6%88%B7%E7%9A%84%E7%89%87%E5%AD%90%E9%80%BB%E8%BE%91/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一次监控内存的猜想</title>
    <link href="/2022/04/10/%E4%B8%80%E6%AC%A1%E7%9B%91%E6%8E%A7%E5%86%85%E5%AD%98%E7%9A%84%E7%8C%9C%E6%83%B3/"/>
    <url>/2022/04/10/%E4%B8%80%E6%AC%A1%E7%9B%91%E6%8E%A7%E5%86%85%E5%AD%98%E7%9A%84%E7%8C%9C%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<p>一天一个客户问，他们现在用zabbix做的监控平台看到的内存，跟他们自己用算法算出来的看到的相差非常大，想问问我为啥会这样。<br><img src="/img/newimg/e6c9d24egy1h15uly0m95j20m20co3zt.jpg" srcset="/img/loading.gif" alt=""></p><p>看到图以后第一时间找客户要了一下现在zabbix计算内存的公式,以及现阶段用<code>free -m</code>显示情况<br><img src="/img/newimg/e6c9d24egy1h15vk88g7kj20vi0e2jsg.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/newimg/e6c9d24egy1h15uoj5ikkj215e09mq4s.jpg" srcset="/img/loading.gif" alt=""></p><p>第一时间能看出图中监控数据不一致的情况其实结论很清楚，就是zabbix的算法是1- available/total  客户是用1- free/total。替换成之前的就行。<br>但是不理解的点在 为什么 free的值比available大很多，在我印象中available作为程序可看到的内存 一般是<br><code>available ≈ free + cache/buff</code> 所以 free这么大，但是available不大的情况很少见。<br>后来经过猜想 以及跟大佬求证发现 实际free的值除了真实内存还会讲部分swap也计算进去。</p><p>跟大佬激烈讨论<br><img src="/img/newimg/e6c9d24egy1h15v1f34qgj20hq0u4ac3.jpg" srcset="/img/loading.gif" alt=""></p><p>有swap情况，明显free &gt; available<br><img src="/img/newimg/e6c9d24egy1h15uxhsm8cj21ry0ccabm.jpg" srcset="/img/loading.gif" alt=""></p><p>没有swap情况available &gt; free<br><img src="/img/newimg/e6c9d24egy1h15uzeltlzj214s06mgm4.jpg" srcset="/img/loading.gif" alt=""></p><p>`官网下 linux对内存定义的详细描述，free里面是会算部分的swap进去，但是available没算swap。</p><p>Estimation of how much memory is available for starting<br>              new applications, without swapping. Unlike the data<br>              provided by the cache or free fields, this field takes<br>              into account page cache and also that not all reclaimable<br>              memory slabs will be reclaimed due to items being in use<br>              (MemAvailable in /proc/meminfo, available on kernels 3.14,<br>              emulated on kernels 2.6.27+, otherwise the same as free)`</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SOWT模型</title>
    <link href="/2022/02/21/SOWT%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/02/21/SOWT%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>对同行的看法</title>
    <link href="/2021/12/11/%E5%AF%B9%E5%90%8C%E8%A1%8C%E7%9A%84%E7%9C%8B%E6%B3%95/"/>
    <url>/2021/12/11/%E5%AF%B9%E5%90%8C%E8%A1%8C%E7%9A%84%E7%9C%8B%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>贸易在哪儿，炮弹就在哪儿。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>运维培训阶段性成果</title>
    <link href="/2021/11/19/%E8%BF%90%E7%BB%B4%E5%9F%B9%E8%AE%AD%E9%98%B6%E6%AE%B5%E6%80%A7%E6%88%90%E6%9E%9C/"/>
    <url>/2021/11/19/%E8%BF%90%E7%BB%B4%E5%9F%B9%E8%AE%AD%E9%98%B6%E6%AE%B5%E6%80%A7%E6%88%90%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="事情起因"><a href="#事情起因" class="headerlink" title="事情起因"></a>事情起因</h3><p>由于国家双减,导致一高中哥们失业。由于没有太多的技能，一直打零工维持，于心不忍。让他考虑考虑来上海 给他培训一下计算机行业的东西，然后转行做IT。<br>一开始他是拒绝的。因为大学非计算机专业 也没有计算机的底子。出于对我的信任以及可能确实没太好的去处。最后还是被我劝来了</p><p><img src="/img/newimg/008i3skNgy1gwlgx8hy22j30zn0u040c.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/newimg/008i3skNgy1gwlgy81yawj30vs0u0gns.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/newimg/008i3skNgy1gwlgylcoyqj30vq0u0763.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>大概是8月25左右过来上海。</p><p>前面由于确实缺钱。一边半夜打零工兼职一边学习。比较惨<br><img src="/img/newimg/008i3skNgy1gwlh0dm3tnj30w80u0mz1.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/newimg/008i3skNgy1gwlh0j95s0j30ve0u0taf.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="/img/newimg/008i3skNgy1gwlh0qtezuj30u00vkju9.jpg" srcset="/img/loading.gif" alt=""></p><blockquote><p>注意看这个时间</p></blockquote><h3 id="培训"><a href="#培训" class="headerlink" title="培训"></a>培训</h3><p>由于确实经济压力较大，所以建议他一边上班一边学，这样也不用干零工。只培训了大概十天左右<br>然后过了一下面试的流程跟内容就去面试了.<br>找了一个工资5k,但是时间比较多的岗位</p><p><img src="/img/newimg/008i3skNgy1gwlha4d3prj30zy0lwgmp.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/newimg/008i3skNgy1gwlhaalogaj30yw0u0q4m.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="找到10k工作"><a href="#找到10k工作" class="headerlink" title="找到10k工作"></a>找到10k工作</h3><p>大概工作了一个半月,加上前面学习的半个月。最终找到了一个10k的<code>运维开发工程师</code>的岗位<br><img src="/img/newimg/008i3skNgy1gwlhc6dn5tj30u01m4q60.jpg" srcset="/img/loading.gif" alt=""></p><p>全集完。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>对于 不忘初心 这句话的一点看法</title>
    <link href="/2021/11/05/%E5%AF%B9%E4%BA%8E-%E4%B8%8D%E5%BF%98%E5%88%9D%E5%BF%83-%E8%BF%99%E5%8F%A5%E8%AF%9D%E7%9A%84%E4%B8%80%E7%82%B9%E7%9C%8B%E6%B3%95/"/>
    <url>/2021/11/05/%E5%AF%B9%E4%BA%8E-%E4%B8%8D%E5%BF%98%E5%88%9D%E5%BF%83-%E8%BF%99%E5%8F%A5%E8%AF%9D%E7%9A%84%E4%B8%80%E7%82%B9%E7%9C%8B%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>很多人杠说自己不忘初心。这句话的初心我觉得应该指一个大方向，比如。<br>做一个善良的人?或者是做一个对社会有用的人这种比较大,并且比较长远的目标，才有不忘初心的意义。</p><p>但是 实际上，根据现有环境以及自己的情况的变化，不停调整自己的认知，修正自己的观点，调整前进方向，这不是叫与时俱进嘛？有很多人就为了坚持而坚持……为了证明自己正确而坚持………完全不顾事实是如何，最终得到一个稀里哗啦的结果，这才叫打脸…… </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一个学sql的网站</title>
    <link href="/2021/11/01/%E4%B8%80%E4%B8%AA%E5%AD%A6sql%E7%9A%84%E7%BD%91%E7%AB%99/"/>
    <url>/2021/11/01/%E4%B8%80%E4%B8%AA%E5%AD%A6sql%E7%9A%84%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<p>碰到一个学sql还不如错的网站,记录推荐一下。</p><blockquote><p><code>http://xuesql.cn</code></p></blockquote><p><img src="/img/newimg/008i3skNgy1gvzwy50oq4j30u70u0k0n.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>凡事先搞起来,能解决80%问题</title>
    <link href="/2021/11/01/%E5%87%A1%E4%BA%8B%E5%85%88%E6%90%9E%E8%B5%B7%E6%9D%A5-%E8%83%BD%E8%A7%A3%E5%86%B380-%E9%97%AE%E9%A2%98/"/>
    <url>/2021/11/01/%E5%87%A1%E4%BA%8B%E5%85%88%E6%90%9E%E8%B5%B7%E6%9D%A5-%E8%83%BD%E8%A7%A3%E5%86%B380-%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>网上有一个热门话题：“遇事应该做足准备再开始，还是先搞起来？”</p><p>一个高赞回答令我印象颇深：“人生不像做菜，不能等所有材料都准备好才下锅。”</p><p>生活中，我们要做的事情层出不穷。</p><p>倘若总想等到万事俱备才开始行动，事情非但不能解决，反而会越积越多。</p><p>《晏子春秋》中有曰：“为者常成，行者常至。”</p><p>意思是说，努力去拼往往可以做成，不倦前行通常可以抵达目的地。</p><p>有时候，与其一味苦想如何解决，不如让自己先搞起来。</p><p>01<br>先搞起来，能反内耗</p><p>人们常说，犹豫一万次，不如实践一次。一个人越思前想后、犹豫不决，就越容易患得患失。</p><p>看过这样一则故事。</p><p>美国一家报社里，有位小记者琼斯。一天，上司叫他去约访大法官布兰德斯，琼斯大吃一惊，连忙拒绝：“不行不行，他根本就不认识我。”</p><p>接着，他列举出自己不去采访的理由：无名小卒、经验不足。他觉得即便自己很想见这位名人，但人家未必会接见。</p><p>琼斯一脸失落，暗自琢磨：“或许别人去了，会比我表现的更好，我还是别去了。”</p><p>上司瞥了一眼，拿起电话拨通了对方的电话：“你好，我是明星报的记者琼斯，我奉命采访布兰德斯法官，不知道他今天能否接见我几分钟？”</p><p>“他不会答应的！我的能力还不能采访他。”琼斯惶恐地说。</p><p>这时，电话那头传出声音：“一点十五分，请准时。”</p><p>琼斯听后，愣在原地，他怎么也没想到自己反复挣扎、纠结很久的事情，对方竟想也没想就答应了。</p><p>成名以后的琼斯，回忆道：</p><p>“那一刻是我二十几年来学到的最重要的一课。”<br> “我能不能做到？这值不值得去做？我要不要试试，选择还是放弃？”</p><p>很多时候，我们在做一件事情之前，习惯把整个事情都推演一遍，臆断出可能遭遇的问题。</p><p>殊不知，拧巴和纠结会成为行动的最大障碍，不断消耗心神，使自己陷入“我如果做了，会怎么样”的内耗。</p><p>如此循环，最终将是一事无成。</p><p>《反内耗》一书中有这么一段话：“知道……却做不到……的纠结背后，是无止境的自我战斗。”</p><p>内耗本身就是对执行力的阻碍。</p><p>清代彭端淑在《为学》中曾写下这样一段故事：</p><p>一穷一富两位和尚都想去朝圣。</p><p>穷和尚对富和尚说：“吾欲之南海，何如？”</p><p>富和尚问：“子何恃而往？”</p><p>穷和尚回道：“吾一瓶一钵足矣。”</p><p>富和尚听后，说：“吾数年来欲买舟而下，犹未能也。”</p><p>第二年，穷和尚去了南海并顺利返程，而富和尚依旧在筹备自己心之所念的船，仍未动身。</p><p>天下之事，总是困于想，而破于行。</p><p>要知道，降低自我消耗的办法，唯有立刻行动。</p><p>与其陷入“想做但不确定结果如何”的纠结中，不妨让自己先搞起来，前行路上，答案自然会随着时间慢慢呈现。</p><p>就像余世存在《时间之书》中的写的那句话：“年轻人，你的职责是平整土地，而非焦虑时光，你三四月做的事，在八九月自有答案。”</p><p>02<br>先搞起来，自有收获</p><p>生活中，其实多数人都一样，遇到事情、碰到问题都没有绝对的把握完美搞定。</p><p>然而，真正拉开人与人之间差距的，是有人愿意凭借自己模糊的愿景，先搞出来个雏形，一步步慢慢前行；有人则始终忧心忡忡，停滞不前。</p><p>我身边便有这样一个例子。</p><p>朋友的婆婆姓蒋，平日里大家都管她叫蒋婆婆，她75岁，一只眼睛患有严重眼疾，一生务农，没有文化，大字不识几个。</p><p>有趣的是，每次朋友看书时，老太太也跟着拿起儿童画报认字。学了没几天，她扬言要写本书，记录自己一生的故事。</p><p>起初，家里人以为她只是心血来潮，便拿之前的糗事笑话她——</p><p>老太太刚注册微信号时，发现有人第一时间跟她发来消息，就开心地跟这个“好友”聊了许久，甚至晚上钻进被窝，还特别热心地用语音跟人家道晚安。</p><p>出于好奇，朋友便问婆婆和谁聊得这么起劲，结果看了手机差点笑晕，那位所谓的“好友”竟是微信团队。</p><p>或许在我们看来，写书，是一件工程浩大的事情。</p><p>可老太太却从不这样认为，她经常摆弄手机，学拼音、识字，但凡有自己搞不懂的地方，便向旁人问个不停。</p><p>大家都打趣她：“蒋婆婆，你还真要写书啊？”</p><p>老太太也不管别人怎么说，总是埋头忙自己的事。后来，她虽然未能出书，却识了许多字，还搞了一本《蒋奶奶的回忆录》彩印纪念册。</p><p>美国保险业巨子克里蒙斯通曾说：“如果你做了，没有损失，还可能有大收获，那就下手去做！更重要的是，马上就做！”</p><p>先搞起来，通常都是一场稳赚不赔的“生意”。</p><p>我们所有时间和精力都是机会，在岁月里辛苦的付出都会叠加起来。</p><p>把事情做成，固然很好；不成，我们也会在过程中积攒许多令人备受增益的经验。</p><p>03<br>先搞起来，才是捷径</p><p>一位著名公司创始人说过：“做一件事，它到底靠不靠谱，你坐在家里想是没用的。我们的风格就是，不管三七二十一，主意出来大体觉得靠谱，先干起来。”</p><p>在行动中获得信息，不断优化调整，既不耽误事情的进程，更不会阻碍自己成长。</p><p>作家彼得·西姆斯在《小赌注》写了这样一件事。</p><p>有个团队要做一款软件，团队对这个软件的开发起了分歧。一位叫瓦尼尔曾的员工，认为应该把软件做得性能强大再发布。</p><p>另一位叫斯莱默的员工，则认为一次性写出完美的代码这种事几乎不存在，应该尽快把软件发布，接受用户的使用反馈，然后进行改良。</p><p>最后的事实是，公司采纳了斯莱默的想法，在不断研发中改善产品缺陷，边做边更新迭代。因为投入市场及时，随着用户增加，他们的设计思路越来越宽，进而取得了空前的成功。</p><p>职场如此，生活亦是。</p><p>任何事情，我们都要学会先上场，再适应，最后调整。</p><p>这让我想起了网友@许静 分享的一段经历。</p><p>为了塑型健身，她每天都会看一些健身视频，把那些有用的“燃脂”“速减”视频放进收藏夹。</p><p>朋友得知后，就带她去了一家健身会所，哪曾想只围观了30分钟的高强度间歇训练，她就被吓跑了。任凭朋友再怎么喊，她都会以自己体能有限为借口推辞。</p><p>后来，朋友直接给她申请了试学课程，把她拽了过去，迫不得已，她只好跟着上完第一节，当她真正体验的时候，她才知道，单组动作分解完20秒，自己只要支持20秒就算赢了。</p><p>这时候她恍然明白，再大的事情，认准目标、找好方向，立即去做就是解决它的最快路径。</p><p>听过这样一句话：“先做起来，是在你与事情之间建立最短路径。让大脑直接从‘if’的如果，聚焦在‘how’的如何做上。”</p><p>我们遇到的所有事情，从有意向到着手做，确定目标后，减去多余的忧虑，先搞起来，才是抵达目的地的捷径。</p><p>04<br>先搞起来<br>能解决人生80%的问题</p><p>为什么我们听过很多道理，却过不好这一生？</p><p>因为很多人都在被动地生活，平时左晃右摆纠结不定，等事情找到自己头上来才不得不去做。</p><p>逻辑思维CEO李天田曾说：“人生总有很多左右为难的事，如果你在做与不做之间纠结，那么，不要反复推演，立即去做。”</p><p>只要先搞起来，没有什么搞不成的。</p><p>前段时间爆火的李子柒就是最好的诠释。她早期做视频的时候，没人教她，就一点点摸索。</p><p>没人专门跟拍，她就自己用手机一遍遍的调整角度，一个人扛着三脚架，山上山下来来回回的折腾。</p><p>日子从无到有，凭的就是这股“说干就干”的利落，她用一己之力开创了一个崭新的短视频领域——古风美食。</p><p>凡事只有先搞起来，在过程中摸出路子，才能找到自己的最佳状态，逢山开路，遇水搭桥。</p><p>比起空想主义，先搞起来，就会超越很多人。</p><p>想减肥、想写作、想学外语、 想考研……先搞起来，遇见困难逐项解决，我们便会与想要的结果不期而遇。</p><p>聪明的人，永远不会把美好的时光留给焦虑，瞻前顾后、徘徊观望。</p><p>他们知道，所有想要的东西都不会空降。</p><p>唯有让自己先搞起来，步履不停，走在路上，美好才会逐渐靠拢，生活才会慢慢向阳。</p><p>共勉。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>下一代镜像构建工具 Earthly</title>
    <link href="/2021/11/01/%E4%B8%8B%E4%B8%80%E4%BB%A3%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7-Earthly/"/>
    <url>/2021/11/01/%E4%B8%8B%E4%B8%80%E4%BB%A3%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7-Earthly/</url>
    
    <content type="html"><![CDATA[<h3 id="一、Earthly-介绍"><a href="#一、Earthly-介绍" class="headerlink" title="一、Earthly 介绍"></a>一、Earthly 介绍</h3><p><img src="/img/newimg/008i3skNgy1gvzfb9c3jxj30u00fgq48.jpg" srcset="/img/loading.gif" alt=""></p><p>Earthly 是一个更加高级的 Docker 镜像构建工具，Earthly 通过自己定义的 Earthfile 来代替传统的 Dockerfile 完成镜像构建；Earthfile 就如同 Earthly 官方所描述:<br>Makefile + Dockerfile = Earthfile<br>在使用 Earthly 进行构建镜像时目前强依赖于 buildkit，Earthly 通过 buildkit 支持了一些 Dockerfile  的扩展语法，同时将 Dockerfile 与 Makefile 整合，使得多平台构建和代码化 Dockerfile 变得更加简单；使用  Earthly 可以更加方便的完成 Dockerfile 的代码复用以及更加友好的 CI 自动集成。</p><h3 id="二、快速开始"><a href="#二、快速开始" class="headerlink" title="二、快速开始"></a>二、快速开始</h3><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><p>Earthly 目前依赖于 Docker 和 Git，所以安装 Earthly 前请确保机器已经安装了 Docker 和 Git。</p><h4 id="安装-Earthly"><a href="#安装-Earthly" class="headerlink" title="安装 Earthly"></a>安装 Earthly</h4><p>Earthly 采用 Go 编写，所以主要就一个二进制文件，Linux 下安装可以直接参考官方的安装脚本:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">$ sudo <span class="hljs-string">/bin/sh</span> -c 'wget https:<span class="hljs-string">//github.com/earthly/earthly/releases/latest/download/earthly-linux-amd64</span> -O <span class="hljs-string">/usr/local/bin/earthly</span> &amp;&amp; chmod +x <span class="hljs-string">/usr/local/bin/earthly</span> &amp;&amp; <span class="hljs-string">/usr/local/bin/earthly</span> bootstrap <span class="hljs-params">--with-autocomplete</span>'<br></code></pre></div></td></tr></table></figure><p>安装完成后 Earthly 将会启动一个 buildkitd 容器: <code>earthly-buildkitd</code>。</p><h4 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h4><p>目前 Earthly 官方支持 VS Code、VIM 以及 Sublime Text 三种编辑器的语法高亮，具体如何安装请参考 官方文档[1]。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>本示例源于官方 Basic 教程，以下示例以编译 Go 项目为样例:<br>首先创建一个任意名称的目录，目录中存在项目源码文件以及一个 <code>Earthfile</code> 文件；<br><code>main.go</code></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">"hello world"</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>Earthfile</code></p><figure class="highlight maxima"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs maxima">FROM golang:<span class="hljs-number">1.17</span>-alpine<br>WORKDIR /<span class="hljs-built_in">go</span>-<span class="hljs-built_in">example</span><br><br>build:<br>    COPY main.<span class="hljs-built_in">go</span> .<br>    RUN <span class="hljs-built_in">go</span> build -o build/<span class="hljs-built_in">go</span>-<span class="hljs-built_in">example</span> main.<span class="hljs-built_in">go</span><br>    SAVE ARTIFACT build/<span class="hljs-built_in">go</span>-<span class="hljs-built_in">example</span> /<span class="hljs-built_in">go</span>-<span class="hljs-built_in">example</span> AS LOCAL build/<span class="hljs-built_in">go</span>-<span class="hljs-built_in">example</span><br><br>docker:<br>    COPY +build/<span class="hljs-built_in">go</span>-<span class="hljs-built_in">example</span> .<br>    ENTRYPOINT [<span class="hljs-string">"/go-example/go-example"</span>]<br>    SAVE IMAGE <span class="hljs-built_in">go</span>-<span class="hljs-built_in">example</span>:latest<br></code></pre></div></td></tr></table></figure><p>有了 <code>Earthfile</code> 以后我们就可以使用 <code>Earthly</code> 将其打包为镜像；</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-comment"># 目录结构</span><br>~<span class="hljs-regexp">/t/</span>earthlytest ❯❯❯ tree<br>.<br>├── Earthfile<br>└── main.go<br><br><span class="hljs-number">0</span> directories, <span class="hljs-number">2</span> files<br><br><span class="hljs-comment"># 通过 earthly 进行构建</span><br>~<span class="hljs-regexp">/t/</span>earthlytest ❯❯❯ earthly +docker<br></code></pre></div></td></tr></table></figure><p><img src="/img/newimg/008i3skNgy1gvzfdth8m9j30u00j7dj3.jpg" srcset="/img/loading.gif" alt=""></p><p>构建完成后我们就可以直接从 docker 的 images 列表中查看刚刚构建的镜像，并运行:</p><p><img src="/img/newimg/008i3skNgy1gvzfe16dhuj30u00b0wfu.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="三、进阶使用"><a href="#三、进阶使用" class="headerlink" title="三、进阶使用"></a>三、进阶使用</h3><h4 id="多阶段构建"><a href="#多阶段构建" class="headerlink" title="多阶段构建"></a>多阶段构建</h4><p>Earthfile 中包含类似 Makefile 一样的 target，不同的 target 之间还可以通过特定语法进行引用，每个 target 都可以被单独执行，执行过程中 earthly 会自动解析这些依赖关系。<br>这种多阶段构建时语法很弹性，我们可以在每个阶段运行独立的命令以及使用不同的基础镜像；从快速开始中可以看到，我们始终使用了一个基础镜像(golang:1.17-alpine)，对于 Go 这种编译后自带运行时不依赖其语言 SDK 的应用，我们事实上可以将 “发布物” 仅放在简单的运行时系统镜像内，从而减少最终镜像体积:<br><img src="/img/newimg/008i3skNgy1gvzfej5tooj30u00f1q3z.jpg" srcset="/img/loading.gif" alt=""></p><p>由于使用了多个 target，所以我们可以单独的运行 build 这个 target 来验证我们的编译流程，这种多 target 的设计方便我们构建应用时对编译、打包步骤的细化拆分，同时也方便我们进行单独的验证。 例如我们单独执行 build 这个 target 来验证我们的编译流程是否正确:</p><p><img src="/img/newimg/008i3skNgy1gvzfeusb76j30u00jxgo6.jpg" srcset="/img/loading.gif" alt=""><br>在其他阶段验证完成后，我们可以直接运行最终的 target，earthly 会自动识别到这种依赖关系从而自动运行其依赖的 target:</p><p><img src="/img/newimg/008i3skNgy1gvzff0xktxj30u00hkdio.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="扩展指令"><a href="#扩展指令" class="headerlink" title="扩展指令"></a>扩展指令</h4><h5 id="SAVE"><a href="#SAVE" class="headerlink" title="SAVE"></a>SAVE</h5><p>SAVE 指令是 Earthly 自己的一个扩展指令，实际上分为 SAVE ARTIFACT 和 SAVE IMAGE；其中 SAVE ARTIFACT 指令格式如下:</p><figure class="highlight fsharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fsharp">SAVE ARTIFACT [--keep-ts] [--keep-own] [--<span class="hljs-keyword">if</span>-exists] [--force] &lt;src&gt; <span class="hljs-meta">[&lt;artifact-dest-path&gt;]</span> [AS LOCAL &lt;local-path&gt;]<br></code></pre></div></td></tr></table></figure><blockquote><p>SAVE ARTIFACT 指令用于将文件或目录从 build 运行时环境保存到 target 的 artifact 环境；当保存到 artifact 环境后，可以通过 COPY 等命令在其他位置进行引用，类似于 Dockerfile 的 COPY –from… 语法；不同的是 SAVE ARTIFACT 支持 AS LOCAL <local-path> 附加参数，一但指定此参数后，earthly 会同时将文件或目录在宿主机复制一份，一般用于调试等目的。SAVE ARTIFACT 命令在上面的样例中已经展示了，在运行完 earthly +build 命令后实际上会在本地看到被 SAVE 出来的 ARTIFACT:</p></blockquote><p><img src="/img/newimg/008i3skNgy1gvzffup6pmj30u00g9wfr.jpg" srcset="/img/loading.gif" alt=""></p><p>而另一个 SAVE IMAGE 指令则主要用于将当前的 build 环境 SAVE 为一个 IMAGE，如果指定了 –push 选项，同时在执行 earthly +target 命令时也加入 –push 选项，该镜像将会自动被推送到目标 Registry 上。SAVE IMAGE 指令格式如下:</p><figure class="highlight sqf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sqf">SAVE <span class="hljs-built_in">IMAGE</span> [--cache-<span class="hljs-keyword">from</span>=&lt;cache-<span class="hljs-built_in">image</span>&gt;] [--push] &lt;<span class="hljs-built_in">image</span>-<span class="hljs-built_in">name</span>&gt;...<br></code></pre></div></td></tr></table></figure><p><img src="/img/newimg/008i3skNgy1gvzfg4swbxj30u00gr0um.jpg" srcset="/img/loading.gif" alt=""></p><h5 id="GIT-CLONE"><a href="#GIT-CLONE" class="headerlink" title="GIT CLONE"></a>GIT CLONE</h5><p>GIT CLONE 指令用于将指定 git 仓库 clone 到 build 环境中；与 RUN git clone… 命令不同的是，GIT CLONE 通过宿主机的 git 命令运行，它不依赖于容器内的 git 命令，同时还可以直接为 earthly 配置 git 认证，从而避免将这些安全信息泄漏到 build 环境中； 关于如何配置 earthly 的 git 认证请参考 官方文档[2]；下面是 GIT CLONE 指令的样例:</p><p><img src="/img/newimg/008i3skNgy1gvzfh5dcc9j30u00hs419.jpg" srcset="/img/loading.gif" alt=""></p><h5 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h5><p>COPY 指令与标准的 Dockerfile COPY 指令类似，除了支持 Dockerfile 标准的 COPY 功能以外，earthly 中的 COPY 指令可以引用其他 target 环节产生的 artifact，在引用时会自动声明依赖关系；即当在 B target 中存在 COPY +A/xxxxx /path/to/copy 类似的指令时，如果只单纯的执行 earthly +B，那么 earthly 根据依赖分析会得出在 COPY 之前需要执行 target A。COPY 指令的语法格式如下:</p><figure class="highlight dockerfile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 与 Dockerfile 相同的使用方式，从上下文复制</span><br><span class="hljs-keyword">COPY</span><span class="bash"> [options...] &lt;src&gt;... &lt;dest&gt;</span><br><br><span class="hljs-comment"># 扩展支持的从 target 复制方式</span><br><span class="hljs-keyword">COPY</span><span class="bash"> [options...] &lt;src-artifact&gt;... &lt;dest&gt;</span><br></code></pre></div></td></tr></table></figure><h5 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h5><p>RUN 指令在标准使用上与 Dockerfile 里保持一致，除此之外增加了更多的扩展选项，其指令格式如下:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli"><br><span class="hljs-comment"># shell 方式运行(/bin/sh -c)</span><br>RUN [<span class="hljs-params">--push</span>] [<span class="hljs-params">--entrypoint</span>] [<span class="hljs-params">--privileged</span>] [<span class="hljs-params">--secret</span> &lt;env-var&gt;=&lt;secret-ref&gt;] [<span class="hljs-params">--ssh</span>] [<span class="hljs-params">--mount</span> &lt;mount-spec&gt;] [--] &lt;<span class="hljs-keyword">command</span>&gt;<br><br><span class="hljs-comment"># exec 方式运行</span><br>RUN [[&lt;flags&gt;<span class="hljs-string">...</span>], <span class="hljs-string">"&lt;executable&gt;"</span>, <span class="hljs-string">"&lt;arg1&gt;"</span>, <span class="hljs-string">"&lt;arg2&gt;"</span>, <span class="hljs-string">...</span>]<br></code></pre></div></td></tr></table></figure><p>其中 –privileged 选项允许运行的命令使用 privileged capabilities，但是需要 earthly 在运行 target 时增加 –allow-privileged 选项；–interactive / –interactive-keep 选项用于交互式执行一些命令，在完成交互后 build 继续进行，在交互过程中进行的操作都会被持久化到 镜像中:</p><p><img src="/img/newimg/008i3skNgy1gvzfi2c9gnj30u00j2whc.jpg" srcset="/img/loading.gif" alt=""></p><h5 id="UDCS"><a href="#UDCS" class="headerlink" title="UDCS"></a>UDCS</h5><p>UDCs 全称 “User-defined commands”，即用户定义指令；通过 UDCs 我们可以将 Earthfile 中特定的命令剥离出来，从而实现更加通用和统一的代码复用；下面是一个定义 UDCs 指令的样例:</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros"><span class="hljs-comment"># 定义一个 Command</span><br><span class="hljs-comment"># ⚠️ 注意: 语法必须满足以下规则</span><br><span class="hljs-comment"># 1、名称全大写</span><br><span class="hljs-comment"># 2、名称下划线分割</span><br><span class="hljs-comment"># 3、首个命令必须为 COMMAND(后面没有冒号)</span><br>MY_COPY:<br>    COMMAND<br>    ARG src<br>    ARG <span class="hljs-attribute">dest</span>=./<br>    ARG <span class="hljs-attribute">recursive</span>=<span class="hljs-literal">false</span><br>    <span class="hljs-builtin-name">RUN</span> cp $(<span class="hljs-keyword">if</span> <span class="hljs-variable">$recursive</span> =  <span class="hljs-string">"true"</span>; then printf -- -r; fi) <span class="hljs-string">"<span class="hljs-variable">$src</span>"</span> <span class="hljs-string">"<span class="hljs-variable">$dest</span>"</span><br><br><span class="hljs-comment"># target 中引用</span><br>build:<br>    <span class="hljs-keyword">FROM</span> alpine:3.13<br>    WORKDIR /udc-example<br>    <span class="hljs-builtin-name">RUN</span> echo <span class="hljs-string">"hello"</span> &gt;./foo<br>    # 通过 <span class="hljs-keyword">DO</span> 关键字引用 UDCs<br>    <span class="hljs-keyword">DO</span> +MY_COPY <span class="hljs-attribute">--src</span>=./foo <span class="hljs-attribute">--dest</span>=./bar<br>    <span class="hljs-builtin-name">RUN</span> cat ./bar # prints <span class="hljs-string">"hello"</span><br></code></pre></div></td></tr></table></figure><p>UDCs 不光可以定义在一个 Earthfile 中，UDCs 可以跨文件、跨目录引用:</p><p><img src="/img/newimg/008i3skNgy1gvzfigy9x7j30u00ka0v0.jpg" srcset="/img/loading.gif" alt=""><br>有了 UDCs 以后，我们可以通过这种方式将对基础镜像的版本统一控制、对特殊镜像的通用处理等操作全部抽象出来，然后每个 Earthfile 根据需要进行引用；关于 UDCs 的使用样例可以参考我的 autobuild[4] 项目，其中的 udcs[5] 目录定义了大量的通用 UDCs，这些 UDCs 被其他目标镜的 Earthfile 批量引用。</p><h4 id="多平台构建"><a href="#多平台构建" class="headerlink" title="多平台构建"></a>多平台构建</h4><p>在以前使用 Dockerfile 的时候，我们需要自己配置然后开启 buildkit 来实现多平台构建；在配置过程中可能会很繁琐，现在使用 earthly 可以默认帮我们实现多平台的交叉编译，我们需要做的仅仅是在 Earthfile 中声明需要支持哪些平台而已:</p><p><img src="/img/newimg/008i3skNgy1gvzfj3fdekj30u00bnq3m.jpg" srcset="/img/loading.gif" alt=""></p><p>以上 Earthfile 在执行 earthly –push +all 构建时，将会自动构建四个平台的镜像，并保持单个 tag，同时由于使用了 –push 选项还会自动推送到 Docker Hub 上:</p><p><img src="/img/newimg/008i3skNgy1gvzfj8slg2j30u00n80uc.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Earthly 弥补了 Dockerfile 的很多不足，解决了很多痛点问题；但同样可能需要一些学习成本，但是如果已经熟悉了 Dockerfile  其实学习成本不高；所以目前还是比较推荐将 Dockerfile 切换为 Earthfile  进行统一和版本化管理的。本文由于篇幅所限(懒)很多地方没有讲，比如共享缓存等，所以关于 Earthly 更多的详细使用等最好还是仔细阅读一下官方文档[6]。</p><h5 id="引用链接"><a href="#引用链接" class="headerlink" title="引用链接"></a>引用链接</h5><figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy">官方文档: <span class="hljs-string">https:</span><span class="hljs-comment">//earthly.dev/get-earthly</span><br>官方文档: <span class="hljs-string">https:</span><span class="hljs-comment">//docs.earthly.dev/docs/guides/auth</span><br>Earthfile <span class="hljs-string">reference:</span> <span class="hljs-string">https:</span><span class="hljs-comment">//docs.earthly.dev/docs/earthfile</span><br><span class="hljs-string">autobuild:</span> <span class="hljs-string">https:</span><span class="hljs-comment">//github.com/mritd/autobuild</span><br><span class="hljs-string">udcs:</span> <span class="hljs-string">https:</span><span class="hljs-comment">//github.com/mritd/autobuild/tree/main/earthfiles/udcs</span><br>官方文档: <span class="hljs-string">https:</span><span class="hljs-comment">//docs.earthly.dev/docs/guides</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>限制K8S Pod 磁盘容量使用的 3 种方法</title>
    <link href="/2021/10/31/%E9%99%90%E5%88%B6K8S-Pod-%E7%A3%81%E7%9B%98%E5%AE%B9%E9%87%8F%E4%BD%BF%E7%94%A8%E7%9A%84-3-%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <url>/2021/10/31/%E9%99%90%E5%88%B6K8S-Pod-%E7%A3%81%E7%9B%98%E5%AE%B9%E9%87%8F%E4%BD%BF%E7%94%A8%E7%9A%84-3-%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="Pod-如何使用磁盘"><a href="#Pod-如何使用磁盘" class="headerlink" title="Pod 如何使用磁盘"></a>Pod 如何使用磁盘</h3><p>容器在运行期间会产生临时文件、日志。如果没有任何配额机制，则某些容器可能很快将磁盘写满，影响宿主机内核和所有应用。容器的临时存储，例如 emptyDir，位于目录/var/lib/kubelet/pods 下：</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell">/var/lib/kubelet/pods/<br>└── ac0810f5-a1ce<span class="hljs-number">-11</span>ea<span class="hljs-number">-9</span>caf<span class="hljs-number">-00e04</span>c687e45  # <span class="hljs-type">POD_ID</span><br>    ├── containers<br>    │   ├── istio-init<br>    │   │   └── <span class="hljs-number">32390</span>fd7<br>    │   ├── istio-proxy<br>    │   │   └── <span class="hljs-number">70</span>ed81da<br>    │   └── zookeeper<br>    │       └── e9e21e59<br>    ├── etc-hosts          # 命名空间的<span class="hljs-type">Host</span>文件<br>    └── volumes            # <span class="hljs-type">Pod</span>的卷<br>        ├── kubernetes.io~configmap  # <span class="hljs-type">ConfigMap</span>类型的卷<br>        │   └── istiod-ca-cert<br>        │       └── root-cert.pem -&gt; ..<span class="hljs-class"><span class="hljs-keyword">data</span>/root-cert.pem</span><br>        ├── kubernetes.io~downward-api<br>        │   └── istio-podinfo<br>        │       ├── annotations -&gt; ..<span class="hljs-class"><span class="hljs-keyword">data</span>/annotations</span><br>        │       └── labels -&gt; ..<span class="hljs-class"><span class="hljs-keyword">data</span>/labels</span><br>        ├── kubernetes.io~empty-dir # <span class="hljs-type">Empty</span>类型的卷<br>        │   ├── istio-<span class="hljs-class"><span class="hljs-keyword">data</span></span><br>        │   └── istio-envoy<br>        │       ├── envoy-rev0.json<br>        │       └── <span class="hljs-type">SDS</span><br>        ├── kubernetes.io~rbd       # <span class="hljs-type">RBD</span>卷<br>        │   └── pvc<span class="hljs-number">-644</span>a7e30<span class="hljs-number">-845e-11</span>ea-a4e1<span class="hljs-number">-70e24</span>c686d29 # /dev/rbd0挂载到这个挂载点<br>        ├── kubernetes.io~csi       # <span class="hljs-type">CSI</span>卷<br>        └── kubernetes.io~secret    # <span class="hljs-type">Secret</span>类型的卷<br>            └── <span class="hljs-keyword">default</span>-token-jp4n8<br>                ├── ca.crt -&gt; ..<span class="hljs-class"><span class="hljs-keyword">data</span>/ca.crt</span><br>                ├── namespace -&gt; ..<span class="hljs-class"><span class="hljs-keyword">data</span>/namespace</span><br>                └── token -&gt; ..<span class="hljs-class"><span class="hljs-keyword">data</span>/token</span><br></code></pre></div></td></tr></table></figure><p>持久卷的挂载点也位于/var/lib/kubelet/pods 下，但是不会导致存储空间的消耗。容器的日志，存放在/var/log/pods 目录下。使用 Docker 时，容器的 rootfs 位于/var/lib/docker 下，具体位置取决于存储驱动。</p><h3 id="Pod-驱逐机制"><a href="#Pod-驱逐机制" class="headerlink" title="Pod 驱逐机制"></a>Pod 驱逐机制</h3><h4 id="磁盘容量不足触发的驱逐"><a href="#磁盘容量不足触发的驱逐" class="headerlink" title="磁盘容量不足触发的驱逐"></a>磁盘容量不足触发的驱逐</h4><p>具体细节参考：/kubernetes-study-note#out-of-resource[1]。当不可压缩资源（内存、磁盘）不足时，节点上的 Kubelet 会尝试驱逐掉某些 Pod，以释放资源，防止整个系统受到影响。其中，磁盘资源不足的信号来源有两个：imagefs：容器运行时用作存储镜像、可写层的文件系统 nodefs：Kubelet 用作卷、守护进程日志的文件系统 当 imagefs 用量到达驱逐阈值，Kubelet 会删除所有未使用的镜像，释放空间。当 nodefs 用量到达阈值，Kubelet 会选择性的驱逐 Pod（及其容器）来释放空间。</p><h4 id="本地临时存储触发的驱逐"><a href="#本地临时存储触发的驱逐" class="headerlink" title="本地临时存储触发的驱逐"></a>本地临时存储触发的驱逐</h4><p>较新版本的 K8S 支持设置每个 Pod 可以使用的临时存储的 request/limit，驱逐行为可以更具有针对性。如果 Pod 使用了超过限制的本地临时存储，Kubelet 将设置驱逐信号，触发 Pod 驱逐流程：对于容器级别的隔离，如果一个容器的可写层、日志占用磁盘超过限制，则 Kubelet 标记 Pod 为待驱逐 对于 Pod 级别的隔离，Pod 总用量限制，是每个容器限制之和。如果各容器用量之和+Pod 的 emptyDir 卷超过 Pod 总用量限制，标记 Pod 为待驱逐</p><h3 id="从编排层限制"><a href="#从编排层限制" class="headerlink" title="从编排层限制"></a>从编排层限制</h3><p>从 K8S 1.8 开始，支持本地临时存储（local ephemeral storage），ephemeral 的意思是，数据的持久性（durability）不做保证。临时存储可能 Backed by 本地 Attach 的可写设备，或者内存。Pod 可以使用本地临时存储来作为暂存空间，或者存放缓存、日志。Kubelet 可以利用本地临时存储，将 emptyDir 卷挂载给容器。Kubelet 也使用本地临时存储来保存节点级别的容器日志、容器镜像、容器的可写层。Kubelet 会将日志写入到你配置好的日志目录，默认 /var/log。其它文件默认都写入到 /var/lib/kubelet。在典型情况下，这两个目录可能都位于宿主机的 rootfs 之下。Kubernetes 支持跟踪、保留/限制 Pod 能够使用的本地临时存储的总量。</p><h5 id="限制-Pod-用量"><a href="#限制-Pod-用量" class="headerlink" title="限制 Pod 用量"></a>限制 Pod 用量</h5><p>打开特性开关：LocalStorageCapacityIsolation，可以限制每个 Pod 能够使用的临时存储的总量。注意：以内存为媒介（tmpfs）的 emptyDir，其用量计入容器内存消耗，而非本地临时存储消耗。使用类似限制内存、CPU 用量的方式，限制本地临时存储用量：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">spec</span><span class="hljs-selector-class">.containers</span><span class="hljs-selector-attr">[]</span><span class="hljs-selector-class">.resources</span><span class="hljs-selector-class">.limits</span><span class="hljs-selector-class">.ephemeral-storage</span><br><span class="hljs-selector-tag">spec</span><span class="hljs-selector-class">.containers</span><span class="hljs-selector-attr">[]</span><span class="hljs-selector-class">.resources</span><span class="hljs-selector-class">.requests</span><span class="hljs-selector-class">.ephemeral-storage</span><br></code></pre></div></td></tr></table></figure><p>单位可以是 E, P, T, G, M, K，或者 Ei, Pi, Ti, Gi, Mi, Ki（1024）。下面这个例子，Pod 具有两个容器，每个容器最多使用 4GiB 的本地临时存储：</p><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-attribute">apiVersion</span>: v1<br><span class="hljs-attribute">kind</span>: Pod<br><span class="hljs-attribute">metadata</span>:<br>  <span class="hljs-attribute">name</span>: frontend<br><span class="hljs-attribute">spec</span>:<br>  <span class="hljs-attribute">containers</span>:<br>  - <span class="hljs-attribute">name</span>: db<br>    <span class="hljs-attribute">image</span>: mysql<br>    <span class="hljs-attribute">env</span>:<br>    - <span class="hljs-attribute">name</span>: MYSQL_ROOT_PASSWORD<br>      <span class="hljs-attribute">value</span>: <span class="hljs-string">"password"</span><br>    <span class="hljs-attribute">resources</span>:<br>      <span class="hljs-attribute">requests</span>:<br>        <span class="hljs-attribute">ephemeral-storage</span>: <span class="hljs-string">"2Gi"</span><br>      <span class="hljs-attribute">limits</span>:<br>        <span class="hljs-attribute">ephemeral-storage</span>: <span class="hljs-string">"4Gi"</span><br>  - <span class="hljs-attribute">name</span>: wp<br>    <span class="hljs-attribute">image</span>: wordpress<br>    <span class="hljs-attribute">resources</span>:<br>      <span class="hljs-attribute">requests</span>:<br>        <span class="hljs-attribute">ephemeral-storage</span>: <span class="hljs-string">"2Gi"</span><br>      <span class="hljs-attribute">limits</span>:<br>        <span class="hljs-attribute">ephemeral-storage</span>: <span class="hljs-string">"4Gi"</span><br></code></pre></div></td></tr></table></figure><h4 id="对-Pod-用量的监控"><a href="#对-Pod-用量的监控" class="headerlink" title="对 Pod 用量的监控"></a>对 Pod 用量的监控</h4><h5 id="不监控"><a href="#不监控" class="headerlink" title="不监控"></a>不监控</h5><p>如果禁用 Kubelet 对本地临时存储的监控，则 Pod 超过 limit 限制后不会被驱逐。但是，如果磁盘整体上容量太低，节点会被打上污点，所有不能容忍此污点的 Pod 都会被驱逐。</p><h5 id="周期性扫描"><a href="#周期性扫描" class="headerlink" title="周期性扫描"></a>周期性扫描</h5><p>Kubelet 可以执行周期性的扫描，检查 emptyDir 卷、容器日志目录、可写容器层，然后计算 Pod/容器使用了多少磁盘。这个模式下有个问题需要注意，Kubelet 不会跟踪已删除文件的描述符。也就是说，如果你创建一个文件，打开文件，写入 1GB，然后删除文件，这种情况下 inode 仍然存在（直到你关闭文件），空间仍然被占用，但是 Kubelet 却没有算这 1GB.</p><h5 id="Project-Quotas"><a href="#Project-Quotas" class="headerlink" title="Project Quotas"></a>Project Quotas</h5><p>此特性在 1.15+处于 Alpha 状态。Project quotas 是 Linux 操作系统级别的特性，用于在目录级别限制磁盘用量。只有本地临时存储（例如 emptyDir）的后备（Backing）文件系统支持 Project quotas，才可以使用该特性。XFS、ext4 都支持 Project quotas。K8S 将占用从 1048576 开始的 Project ID，占用中的 ID 注册在/etc/projects、/etc/projid 文件中。如果系统中其它进程占用 Project ID，则也必须在这两个文件中注册，这样 K8S 才会改用其它 ID。Quotas 比周期性扫描快，而且更加精准。当一个目录被分配到一个 Project 中后，该目录中创建的任何文件，都是在 Project 中创建的。为了统计用量，内核只需要跟踪 Project 中创建了多少 block 就可以了。如果文件被创建、然后删除，但是它的文件描述符仍然处于打开状态，这种情况下，它仍然消耗空间，不会出现周期性扫描的那种漏统计的问题。要启用 Project Quotas，你需要：<br>开启 Kubelet 特性开关：LocalStorageCapacityIsolationFSQuotaMonitoring<br>确保文件系统支持 Project quotas：<br>XFS 文件系统默认支持，不需要操作<br>ext4 文件系统，你需要在未挂载之前，启用：</p><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle">$ sudo tune2fs -O <span class="hljs-keyword">project</span> -Q prjquota <span class="hljs-regexp">/dev/</span>vda<br></code></pre></div></td></tr></table></figure><p>确保文件系统挂载时，启用了 Project quotas。使用挂载选项 prjquota</p><h4 id="inode-耗尽问题"><a href="#inode-耗尽问题" class="headerlink" title="inode 耗尽问题"></a>inode 耗尽问题</h4><p>有的时候，我们会发现磁盘写入时会报磁盘满，但是 df 查看容量并没有 100%使用，此时可能只是因为 inode 耗尽造成的。当前 k8s 并不支持对 Pod 的临时存储设置 inode 的 limits/requests。但是，如果 node 进入了 inode 紧缺的状态，kubelet 会将 node 设置为 under pressure，不再接收新的 Pod 请求。</p><h3 id="从容器引擎限制"><a href="#从容器引擎限制" class="headerlink" title="从容器引擎限制"></a>从容器引擎限制</h3><p>Docker 提供了配置项 –storage-opt，可以限制容器占用磁盘空间的大小，此大小影响镜像和容器文件系统，默认 10G。你也可以在 /etc/docker/daemon.json 中修改此配置项：</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">"storage-driver"</span>: <span class="hljs-string">"devicemapper"</span>,<br>    <span class="hljs-attr">"storage-opts"</span>: [<br>        <span class="hljs-comment">// devicemapper</span><br>        <span class="hljs-string">"dm.basesize=20G"</span>,<br>        <span class="hljs-comment">// overlay2</span><br>        <span class="hljs-string">"overlay2.size=20G"</span>,<br>    ]<br>&#125;<br></code></pre></div></td></tr></table></figure><p>但是这种配置无法影响那些挂载的卷，例如 emptyDir。</p><h3 id="从系统层限制"><a href="#从系统层限制" class="headerlink" title="从系统层限制"></a>从系统层限制</h3><p>你可以使用 Linux 系统提供的任何能够限制磁盘用量的机制，为了和 K8S 对接，需要开发 Flexvolume 或 CSI 驱动。</p><h4 id="磁盘配额"><a href="#磁盘配额" class="headerlink" title="磁盘配额"></a>磁盘配额</h4><p>前文已经介绍过，K8S 目前支持基于 Project quotas 来统计 Pod 的磁盘用量。这里简单总结一下 Linux 磁盘配额机制。</p><h4 id="配额目标"><a href="#配额目标" class="headerlink" title="配额目标"></a>配额目标</h4><p>Linux 系统支持以下几种角度的配额：<br>在文件系统级别，限制群组能够使用的最大磁盘额度<br>在文件系统级别，限制单个用户能够使用的最大磁盘额度<br>限制某个目录（directory, project）能够占用的最大磁盘额度<br>前面 2 种配额，现代 Linux 都支持，不需要前提条件。你甚至可以在一个虚拟的文件系统上进行配额：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros"><span class="hljs-comment"># 写一个空白文件</span><br>$ dd <span class="hljs-attribute">if</span>=/dev/zero <span class="hljs-attribute">of</span>=/path/to/the/file <span class="hljs-attribute">bs</span>=4096 <span class="hljs-attribute">count</span>=4096<br><span class="hljs-comment"># 格式化</span><br><span class="hljs-built_in">..</span>.<br><span class="hljs-comment"># 挂载为虚拟文件系统</span><br>$ mount -o loop,rw,usrquota,grpquota /path/<span class="hljs-keyword">to</span>/the/file /path/of/mount/point<br><span class="hljs-comment"># 进行配额设置...</span><br></code></pre></div></td></tr></table></figure><p>第 3 种需要较新的文件系统，例如 XFS、ext4fs。</p><h4 id="配额角度"><a href="#配额角度" class="headerlink" title="配额角度"></a>配额角度</h4><p>配额可以针对 Block 用量进行，也可以针对 inode 用量进行。配额可以具有软限制、硬限制。超过软限制后，仍然可以正常使用，但是登陆后会收到警告，在 grace time 倒计时完毕之前，用量低于软限制后，一切恢复正常。如果 grace time 到期仍然没做清理，则无法创建新文件。</p><h4 id="统计用量"><a href="#统计用量" class="headerlink" title="统计用量"></a>统计用量</h4><p>启用配额，内核自然需要统计用量。管理员要查询用量，可以使用 xfs_quota 这样的命令，比 du 这种遍历文件计算的方式要快得多。</p><h4 id="启用配额"><a href="#启用配额" class="headerlink" title="启用配额"></a>启用配额</h4><p>在保证底层文件系统支持之后，你需要修改挂载选项来启用配额：<br>uquota/usrquota/quota：针对用户设置配额<br>gquota/grpquota：针对群组设置配额<br>pquota/prjquota：针对目录设置配额</p><h4 id="LVM"><a href="#LVM" class="headerlink" title="LVM"></a>LVM</h4><p>使用 LVM 你可以任意创建具有尺寸限制的逻辑卷，把这些逻辑卷挂载给 Pod 即可：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><br><span class="hljs-attr">volumes:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">flexVolume:</span><br>    <span class="hljs-comment"># 编写的flexVolume驱动放到</span><br>    <span class="hljs-comment"># /usr/libexec/kubernetes/kubelet-plugins/volume/exec/kubernetes.io~lvm/lvm</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">kubernetes.io/lvm</span><br>    <span class="hljs-attr">fsType:</span> <span class="hljs-string">ext4</span><br>    <span class="hljs-attr">options:</span><br>      <span class="hljs-attr">size:</span> <span class="hljs-string">30Gi</span><br>      <span class="hljs-attr">volumegroup:</span> <span class="hljs-string">docker</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">mnt</span><br><span class="hljs-attr">volumeMounts:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/mnt</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">mnt</span><br></code></pre></div></td></tr></table></figure><p>这需要修改编排方式，不使用 emptyDir 这种本地临时存储，还需要处理好逻辑卷清理工作。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>containerd使用指南</title>
    <link href="/2021/10/31/containerd%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2021/10/31/containerd%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>containerd 是一个高级容器运行时，又名 容器管理器。简单来说，它是一个守护进程，在单个主机上管理完整的容器生命周期：创建、启动、停止容器、拉取和存储镜像、配置挂载、网络等。<br>containerd 旨在轻松嵌入到更大的系统中。Docker 在底层使用 containerd 来运行容器。Kubernetes 可以通过 CRI 使用 containerd 来管理单个节点上的容器。但是较小的项目也可以从与 containerd 的轻松集成中受益——例如，faasd 使用 containerd（我们需要更多的 d！）在独立服务器上启动一个服务。<br><img src="/img/newimg/008i3skNgy1gvyonj2ov3j30u00gl75u.jpg" srcset="/img/loading.gif" alt=""></p><p>但是，以编程方式使用 containerd 并不是唯一的选择。它还可以通过可用客户端之一从命令行使用。由此产生的容器 UX 可能不像 docker 客户端提供的那样全面和用户友好，但它仍然是有用的，例如，用于调试或学习目的。</p><p><img src="/img/newimg/008i3skNgy1gvyonojvlgj30u00gr3zv.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="如何在-ctr-中使用-containerd"><a href="#如何在-ctr-中使用-containerd" class="headerlink" title="如何在 ctr 中使用 containerd"></a>如何在 ctr 中使用 containerd</h3><p>ctr 是作为 containerd 项目的一部分提供的命令行客户端。如果您在机器上运行了 containerd，则 ctr 二进制文件很可能也在那里。<br>该 ctr 界面 与 Docker CLI 不兼容，乍一看，可能看起来不那么用户友好。显然，它的主要受众是测试守护进程的容器开发人员。但是，由于它是最接近实际 containerd API 的东西，因此它可以作为一种很好的探索手段——通过检查可用命令，您可以大致了解 containerd 可以做什么和不能做什么。<br>ctr 也非常适合学习的能力低级别的使用人员，因为 ctr + containerd 是更接近实际的容器比 docker + dockerd。</p><h3 id="使用-ctr-处理容器镜像"><a href="#使用-ctr-处理容器镜像" class="headerlink" title="使用 ctr 处理容器镜像"></a>使用 ctr 处理容器镜像</h3><p>拉取镜像，似乎是必需和完全合规的，但是你不能忽略注册表或标签部分：</p><figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy">$ ctr images pull docker.io<span class="hljs-regexp">/library/</span><span class="hljs-string">nginx:</span><span class="hljs-number">1.21</span><br>$ ctr images pull docker.io<span class="hljs-regexp">/kennethreitz/</span><span class="hljs-string">httpbin:</span>latest<br>$ ctr images pull docker.io<span class="hljs-regexp">/kennethreitz/</span><span class="hljs-string">httpbin:</span>latest<br>$ ctr images pull quay.io<span class="hljs-regexp">/quay/</span><span class="hljs-string">redis:</span>latest<br></code></pre></div></td></tr></table></figure><p>要列出本地镜像，可以使用：</p><figure class="highlight elixir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>ctr images ls<br></code></pre></div></td></tr></table></figure><p>令人惊讶的是，containerd 不提供开箱即用的镜像构建支持。但是 containerd 经常被更高级别的工具用来构建镜像。<br>ctr 您可以导入使用 docker build 或其他 OCI 兼容软件构建的现有镜像，而不是使用构建镜像：</p><figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata"><br>$ docker build -t my-<span class="hljs-keyword">app</span> .<br>$ docker <span class="hljs-keyword">save</span> -o my-<span class="hljs-keyword">app</span>.tar my-<span class="hljs-keyword">app</span><br><br>$ ctr images import my-<span class="hljs-keyword">app</span>.tar<br></code></pre></div></td></tr></table></figure><p>使用 ctr，您还可以学习和探索下挂载镜像：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><br>$ mkdir /tmp/httpbin<br>$ ctr images mount docker.io/kennethreitz/httpbin:latest /tmp/httpbin<br><br>$ ls -l /tmp/httpbin/<br>total <span class="hljs-number">80</span><br>drwxr-xr-x <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> Oct <span class="hljs-number">18</span>  <span class="hljs-number">2018</span> bin<br>drwxr-xr-x <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> Apr <span class="hljs-number">24</span>  <span class="hljs-number">2018</span> boot<br>drwxr-xr-x <span class="hljs-number">4</span> root root <span class="hljs-number">4096</span> Oct <span class="hljs-number">18</span>  <span class="hljs-number">2018</span> dev<br>drwxr-xr-x <span class="hljs-number">1</span> root root <span class="hljs-number">4096</span> Oct <span class="hljs-number">24</span>  <span class="hljs-number">2018</span> etc<br>drwxr-xr-x <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> Apr <span class="hljs-number">24</span>  <span class="hljs-number">2018</span> home<br>drwxr-xr-x <span class="hljs-number">3</span> root root <span class="hljs-number">4096</span> Oct <span class="hljs-number">24</span>  <span class="hljs-number">2018</span> httpbin<br>...<br><br>$ ctr images unmount /tmp/httpbin<br></code></pre></div></td></tr></table></figure><p>要使用删除镜像 ctr，请运行：</p><figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy">$ ctr images remove docker.io<span class="hljs-regexp">/library/</span><span class="hljs-string">nginx:</span><span class="hljs-number">1.21</span><br></code></pre></div></td></tr></table></figure><h3 id="使用-ctr-处理容器"><a href="#使用-ctr-处理容器" class="headerlink" title="使用 ctr 处理容器"></a>使用 ctr 处理容器</h3><p>你可以运行一个容器用ctr run image-ref container-id。例如：<br>$ ctr run –rm -t docker.io/library/debian:latest cont1<br>请注意，ctr 与用户友好地 docker run 为您生成唯一容器 ID 不同，您必须自己提供唯一容器 ID。该 ctr run 命令还只支持一些熟悉的 docker run 标志：–env，-t,–tty，-d,–detach，–rm等，但没有端口指定或自动重启容器–restart=always。<br>与镜像类似，您可以使用以下命令列出现有容器：<br>$ ctr containers ls<br>有趣的是，该 ctr run 命令实际上是快捷方式ctr container create + ctr task start:</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><br>$ ctr container <span class="hljs-keyword">create</span> -t docker.io/<span class="hljs-keyword">library</span>/nginx:latest nginx_1<br>$ ctr <span class="hljs-keyword">container</span> ls<br><span class="hljs-keyword">CONTAINER</span>    IMAGE                              RUNTIME<br>nginx_1      docker.io/<span class="hljs-keyword">library</span>/nginx:latest     io.containerd.runc.v2<br><br>$ ctr task ls<br>TASK    PID    <span class="hljs-keyword">STATUS</span>        <span class="hljs-comment"># Empty!</span><br><br>$ ctr task <span class="hljs-keyword">start</span> -d nginx_1  <span class="hljs-comment"># -d for --detach</span><br>$ ctr task <span class="hljs-keyword">list</span><br>TASK     PID      <span class="hljs-keyword">STATUS</span><br>nginx_1  <span class="hljs-number">10074</span>    RUNNING<br></code></pre></div></td></tr></table></figure><p>我喜欢 container 和 task 子命令的这种分离，因为它反映了 OCI 容器经常被遗忘的性质。尽管普遍认为容器不是进程 -容器是资源被隔离和执行受限制的进程。<br>使用 ctr task attach，您可以重新连接到在容器内运行的现有任务的 stdio 流：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">$ ctr task attach nginx_1<br><span class="hljs-number">2021</span>/<span class="hljs-number">09</span>/<span class="hljs-number">12</span> <span class="hljs-number">15</span>:<span class="hljs-number">42</span>:<span class="hljs-number">20</span> [notice] <span class="hljs-number">1</span>#<span class="hljs-number">1</span>: using the <span class="hljs-string">"epoll"</span> event method<br><span class="hljs-number">2021</span>/<span class="hljs-number">09</span>/<span class="hljs-number">12</span> <span class="hljs-number">15</span>:<span class="hljs-number">42</span>:<span class="hljs-number">20</span> [notice] <span class="hljs-number">1</span>#<span class="hljs-number">1</span>: nginx/<span class="hljs-number">1.21</span><span class="hljs-number">.3</span><br><span class="hljs-number">2021</span>/<span class="hljs-number">09</span>/<span class="hljs-number">12</span> <span class="hljs-number">15</span>:<span class="hljs-number">42</span>:<span class="hljs-number">20</span> [notice] <span class="hljs-number">1</span>#<span class="hljs-number">1</span>: built by gcc <span class="hljs-number">8.3</span><span class="hljs-number">.0</span> (Debian <span class="hljs-number">8.3</span><span class="hljs-number">.0</span><span class="hljs-number">-6</span>)<br><span class="hljs-number">2021</span>/<span class="hljs-number">09</span>/<span class="hljs-number">12</span> <span class="hljs-number">15</span>:<span class="hljs-number">42</span>:<span class="hljs-number">20</span> [notice] <span class="hljs-number">1</span>#<span class="hljs-number">1</span>: OS: Linux <span class="hljs-number">4.19</span><span class="hljs-number">.0</span><span class="hljs-number">-17</span>-amd64<br><span class="hljs-number">2021</span>/<span class="hljs-number">09</span>/<span class="hljs-number">12</span> <span class="hljs-number">15</span>:<span class="hljs-number">42</span>:<span class="hljs-number">20</span> [notice] <span class="hljs-number">1</span>#<span class="hljs-number">1</span>: getrlimit(RLIMIT_NOFILE): <span class="hljs-number">1024</span>:<span class="hljs-number">1024</span><br><span class="hljs-number">2021</span>/<span class="hljs-number">09</span>/<span class="hljs-number">12</span> <span class="hljs-number">15</span>:<span class="hljs-number">42</span>:<span class="hljs-number">20</span> [notice] <span class="hljs-number">1</span>#<span class="hljs-number">1</span>: start worker processes<br><span class="hljs-number">2021</span>/<span class="hljs-number">09</span>/<span class="hljs-number">12</span> <span class="hljs-number">15</span>:<span class="hljs-number">42</span>:<span class="hljs-number">20</span> [notice] <span class="hljs-number">1</span>#<span class="hljs-number">1</span>: start worker process <span class="hljs-number">31</span><br>...<br></code></pre></div></td></tr></table></figure><p>与 docker 非常相似，您可以在现有容器中执行命令：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><br>$ ctr task exec -t --exec-id bash_1 nginx_1 bash<br><br># From inside the container:<br>$ root@host:/# curl 127.0.0.1:80<br><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Welcome to nginx!<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>...<br></code></pre></div></td></tr></table></figure><p>在删除容器之前，必须停止其所有任务：<code>$ ctr task kill -9 nginx_1</code><br>或者，您可以使用以下标志–force 删除正在运行的任务：<br><code>$ ctr task rm -f nginx_1</code><br>最后，要删除容器，请运行：<br><code>$ ctr container rm nginx_1</code></p><h3 id="如何在-nerdctl-中使用-containerd"><a href="#如何在-nerdctl-中使用-containerd" class="headerlink" title="如何在 nerdctl 中使用 containerd"></a>如何在 nerdctl 中使用 containerd</h3><p>nerdctl 是一个相对较新的 containerd 命令行客户端。与 ctr,nerdctl 旨在用户友好且与 Docker 兼容。在某种程度上，nerdctl + containerd可以无缝替换docker + dockerd. 但是，这似乎不是该项目的目标：</p><blockquote><p>nerdctl 其目标是促进试验 Docker 中不存在的 containerd 的尖端功能。此类功能包括但不限于延迟拉取 (stargz) 和图像加密 (ocicrypt)。预计这些功能最终也将在 Docker 中可用，但是，这可能需要几个月甚至几年的时间，因为 Docker 目前被设计为仅使用容器子系统的一小部分。重构 Docker 以使用整个 containerd 是可能的，但并不简单。所以我们决定创建一个完全使用 containerd 的新 CLI，但我们不打算用 Docker 来完成。我们一直在为 Docker/Moby 以及 containerd 做出贡献，并将继续这样做。</p></blockquote><p>从基本使用的角度来看，与 相比 ctr，nerdctl 支持：</p><figure class="highlight armasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs armasm">镜像管理 nerdctl <span class="hljs-keyword">build</span><br><span class="hljs-keyword">容器网络管理</span><br><span class="hljs-keyword">Docker </span>与 nerdctl compose up<br></code></pre></div></td></tr></table></figure><p>最酷的部分是 nerdctl 尝试提供与 docker（和 podman）相同的命令行用户体验。因此，如果您熟悉 docker（或 podman）CLI，那么您已经熟悉 nerdctl.</p><h3 id="如何在-crictl-中使用-containerd"><a href="#如何在-crictl-中使用-containerd" class="headerlink" title="如何在 crictl 中使用 containerd"></a>如何在 crictl 中使用 containerd</h3><p>crictl 是 Kubernetes CRI 兼容容器运行时的命令行客户端。</p><blockquote><p>引入了 Kubernetes 容器运行时接口 (CRI)以使 Kubernetes 容器运行时充满魔法。Kubernetes 节点代理 kubelet 实现了 CRI 客户端 API，可以使用任何实现 CRI 服务器 API 的容器运行时来管理其节点上的容器和 pod。</p></blockquote><p><img src="/img/newimg/008i3skNgy1gvyoqpzndwj30u00op42q.jpg" srcset="/img/loading.gif" alt=""></p><p>从 1.1 版开始，containerd 带有一个内置的 CRI 插件。因此，containerd 是一个兼容 CRI 的容器运行时。因此，它可以与 crictl 共存.<br>crictl 创建用于检查和调试 Kubernetes 节点上的容器运行时和应用程序。它支持以下操作：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">attach: Attach <span class="hljs-keyword">to</span> a running container<br>create: Create a new container<br>exec: <span class="hljs-builtin-name">Run</span> a command <span class="hljs-keyword">in</span> a running container<br>version: Display runtime version information<br>images, image, img: List images<br>inspect: Display the status of one <span class="hljs-keyword">or</span> more containers<br>inspecti: Return the status of one <span class="hljs-keyword">or</span> more images<br>imagefsinfo: Return image filesystem info<br>inspectp: Display the status of one <span class="hljs-keyword">or</span> more pods<br>logs: Fetch the logs of a container<br>port-forward: Forward local<span class="hljs-built_in"> port </span><span class="hljs-keyword">to</span> a pod<br>ps: List containers<br>pull: Pull an image <span class="hljs-keyword">from</span> a registry<br>run: <span class="hljs-builtin-name">Run</span> a new container inside a sandbox<br>runp: <span class="hljs-builtin-name">Run</span> a new pod<br>rm: <span class="hljs-builtin-name">Remove</span> one <span class="hljs-keyword">or</span> more containers<br>rmi: <span class="hljs-builtin-name">Remove</span> one <span class="hljs-keyword">or</span> more images<br>rmp: <span class="hljs-builtin-name">Remove</span> one <span class="hljs-keyword">or</span> more pods<br>pods: List pods<br>start: Start one <span class="hljs-keyword">or</span> more created containers<br>info: Display information of the container runtime<br>stop: Stop one <span class="hljs-keyword">or</span> more running containers<br>stopp: Stop one <span class="hljs-keyword">or</span> more running pods<br>update: Update one <span class="hljs-keyword">or</span> more running containers<br>config: <span class="hljs-builtin-name">Get</span> <span class="hljs-keyword">and</span> <span class="hljs-builtin-name">set</span> crictl<span class="hljs-built_in"> client </span>configuration options<br>stats: List container(s)<span class="hljs-built_in"> resource </span>usage statistics<br></code></pre></div></td></tr></table></figure><p>这里有趣的部分是，通过 crictl + containerdbundle 可以了解 pod 是如何实现的，但是这个话题值得自己去探索。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DNS 故障诊断及问题分析示例</title>
    <link href="/2021/10/31/DNS-%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E5%8F%8A%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E7%A4%BA%E4%BE%8B/"/>
    <url>/2021/10/31/DNS-%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E5%8F%8A%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E7%A4%BA%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="DNS-基础知识"><a href="#DNS-基础知识" class="headerlink" title="DNS 基础知识"></a>DNS 基础知识</h3><p>互联网基于 TCP/IP 协议。为了方便管理网络内的主机，整个互联网分为若干个域 （domain），每 个域又可以再分为若干个子域，例如，.com，.org，.edu 都是顶级域，而 google.com 是.com 下面的子域。</p><p>网络中的任意一台主机（host）都会属于某个域，并且有自己的名字，称为主机名（ hostname）。例如 example.com 就是.com 域中一台主机名为 example.com（或 example，hostname 和 domain name 的区别，见这里 ）的主机。</p><p>域名/主机名是为了方便人记忆，而机器之间通信最终用的还是 IP 地址，因此需要一个将主 机名（域名）转换成 IP 地址的服务。域名服务系统（DNS, domain name system）做的就是 这个事情，对应的服务器称为域名服务器（Domain Name Server）。</p><p>例如，当通过浏览器访问 example.com，浏览器会首先访问 DNS 服务器，查找 example.com 对应的 IP 地址，然后和这个 IP 建立 TCP 连接，接下来才发起 HTTP 请求。</p><p>一个域名可以对应一个 IP 地址，也可以对应多个。对于后者，DNS 服务算法会从中选择一个 地址返回。大部分网络服务为了实现高可用，都是对应多个地址，我们后面会看到， baidu.com 就对应多个 IP。</p><p>有一些场景会导致访问 DNS 服务不稳定，例如 DNS 服务器的设置有问题、网络有丢包、主机 DNS 配置错误等等。我们接下来查看几种 case。</p><h3 id="准备测试环境"><a href="#准备测试环境" class="headerlink" title="准备测试环境"></a>准备测试环境</h3><p>为方便大家跟着上手练习，本文将搭建一个容器环境。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">$ sudo docker pull alpine:<span class="hljs-number">3.8</span><br></code></pre></div></td></tr></table></figure><p>运行容器，注意这里一定要带–privileged 参数 [2]，否则后面的部分 tc 命令无法执行:</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">$ sudo docker run -d --privileged --name ctn<span class="hljs-number">-1</span> alpine:<span class="hljs-number">3.8</span> sleep <span class="hljs-number">3600</span>d<br>$ sudo docker ps<br>CONTAINER ID    IMAGE        COMMAND         CREATED        STATUS          PORTS  NAMES<br><span class="hljs-number">233</span>bc36bde4b    alpine:<span class="hljs-number">3.8</span>   <span class="hljs-string">"sleep 3600d"</span>   <span class="hljs-number">1</span> minutes ago  Up <span class="hljs-number">14</span> minutes           ctn<span class="hljs-number">-1</span><br></code></pre></div></td></tr></table></figure><p>进入容器：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo docker <span class="hljs-built_in">exec</span> -it ctn-1 sh</span><br></code></pre></div></td></tr></table></figure><p>查看容器网络信息：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">/ # ifconfig<br>eth0      Link encap:Ethernet  HWaddr <span class="hljs-number">02</span>:<span class="hljs-number">42</span>:AC:<span class="hljs-number">11</span>:<span class="hljs-number">00</span>:<span class="hljs-number">09</span><br>          inet addr:<span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.9</span>  Bcast:<span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>  Mask:<span class="hljs-number">255.255</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br></code></pre></div></td></tr></table></figure><h3 id="DNS-配置"><a href="#DNS-配置" class="headerlink" title="DNS 配置"></a>DNS 配置</h3><h4 id="查看-DNS-配置"><a href="#查看-DNS-配置" class="headerlink" title="查看 DNS 配置"></a>查看 DNS 配置</h4><p>Linux 上的 DNS 配置在/etc/resolv.conf 里面。我们先来查看容器的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">/</span> <span class="hljs-comment"># cat /etc/resolv.conf</span><br><span class="hljs-comment"># Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)</span><br><span class="hljs-comment">#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN</span><br><span class="hljs-string">nameserver</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.11</span><br><span class="hljs-string">nameserver</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.12</span><br></code></pre></div></td></tr></table></figure><p>这其实是继承了宿主机的 DNS 配置，在宿主机上执行 cat /etc/resolv.conf 会看到一样的 结果。</p><h4 id="修改-DNS-配置"><a href="#修改-DNS-配置" class="headerlink" title="修改 DNS 配置"></a>修改 DNS 配置</h4><p>可以通过修改/etc/resolv.conf 里面的 nameserver 来配置自己想用的 DNS 服务器。例如内网环境可能都会使用自己的 DNS 服务器，因为它除了 提供内网域名解析之外，公网域名解析也会比较快（相比于网络供应商的公网 DNS 服务器） 。</p><h4 id="DNS-问题排查"><a href="#DNS-问题排查" class="headerlink" title="DNS 问题排查"></a>DNS 问题排查</h4><p>本节模拟几种导致 DNS 查询变慢的场景，如果在实际环境中遇到类似现象，可以考虑往这些 方向排查。</p><h4 id="机器未配置-DNS-导致域名查找失败"><a href="#机器未配置-DNS-导致域名查找失败" class="headerlink" title="机器未配置 DNS 导致域名查找失败"></a>机器未配置 DNS 导致域名查找失败</h4><p>现象：网络是通的（例如 ping IP 通），但是 DNS 查询总是失败<br>可能的原因：机器没有配置 DNS 服务器<br>解决办法：修改/etc/resolv.conf，给机器配置合适的 DNS 服务器 有时新启动的机器（不管是物理机、虚拟机还是容器）没有设置 DNS，导致访问域名不通。我们来复现一下。<br>在正常的容器里用 nslookup 工具查看域名对应的 IP 地址：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">/ # nslookup example.com<br><br>Name:      example.com<br>Address 1: 93.184.216.34<br>Address 2: 2606:2800:220:1:248:1893:25c8:1946<br></code></pre></div></td></tr></table></figure><p>可以看到，我们获取到了该域名一个 IPv4 地址和一个 IPv6 地址。</p><p>将/etc/resolv.conf 里的 DNS 服务器列表用#注释掉，模拟没有配置 DNS 服务器的场景。</p><p>再次测试：</p><figure class="highlight profile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs profile">/ # nslookup example.com<br><br>nslookup: can<span class="hljs-string">'t resolve '</span>example.com': Try again<br></code></pre></div></td></tr></table></figure><p>所以遇到这种问题，可以先去排查/etc/resolv.conf 里面是否配置了 DNS 服务器。</p><h3 id="DNS-服务太慢"><a href="#DNS-服务太慢" class="headerlink" title="DNS 服务太慢"></a>DNS 服务太慢</h3><p>现象：DNS 查询太慢<br>可能的原因：配置的 DNS 服务器不合理<br>解决办法：修改/etc/resolv.conf，配置合适的 DNS 服务器<br>每个公司一般都有自维护的 DNS 服务器，不仅用来解析内网 DNS，而且可以加速解析公网域名 。</p><p>dig 是另外一个功能更强大的 DNS 查询工具，安装：</p><figure class="highlight sas"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sas">/ # apk <span class="hljs-meta">update</span> <span class="hljs-variable">&amp;&amp;</span> apk <span class="hljs-meta">add</span> bind-tools<br></code></pre></div></td></tr></table></figure><p>首先查看使用内网 DNS，查询域名的延迟：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">/ # dig example.com<br>...<br>example.com.            <span class="hljs-number">15814</span>   IN      A       <span class="hljs-number">93.184</span><span class="hljs-number">.216</span><span class="hljs-number">.34</span><br><br>;; Query time: <span class="hljs-number">0</span> msec<br>;; SERVER: <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.11</span>#<span class="hljs-number">53</span>(<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.11</span>)<br></code></pre></div></td></tr></table></figure><p>可以看到非常快，在 1ms 以内。</p><p>然后我们测试如果使用 Google 的公网 DNS 服务器 8.8.8.8，延迟会是多少。</p><p>修改/etc/resolv.conf，将其他 nameserver 注释掉，添加一行 nameserver 8.8.8.8。</p><p>再次测试：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><br>/ # dig example.com<br>...<br>example.com.            <span class="hljs-number">15814</span>   IN      A       <span class="hljs-number">93.184</span><span class="hljs-number">.216</span><span class="hljs-number">.34</span><br><br>;; Query time: <span class="hljs-number">150</span> msec<br>;; SERVER: <span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span>#<span class="hljs-number">53</span>(<span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span>)<br></code></pre></div></td></tr></table></figure><p>延迟变成了 150ms，比原来大了 150 多倍。</p><p>因此，对于 DNS 查询特别慢的场景，首先要查看配置的 DNS 服务器是否合理。</p><h4 id="hardcode-etc-hosts-导致跳过-DNS-查询"><a href="#hardcode-etc-hosts-导致跳过-DNS-查询" class="headerlink" title="hardcode /etc/hosts 导致跳过 DNS 查询"></a>hardcode /etc/hosts 导致跳过 DNS 查询</h4><p>现象：某域名访问太慢、某域名总是指向相同 IP（多 IP 情况下）、特定机器不可访问 某域名等等<br>可能的原因：/etc/hosts 有 hardcode 域名及 IP<br>解决办法：修改/etc/hosts<br>前面提到，大部分公网域名都对应多个 IP 地址，因此每次 DNS 查询拿到的 IP 地址都可能不一 样，我们用 ping 来测试一下：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">/ #<span class="hljs-built_in"> ping </span>baidu.com<br>PING baidu.com (220.181.57.216): 56 data bytes<br>64 bytes <span class="hljs-keyword">from</span> 220.181.57.216: <span class="hljs-attribute">seq</span>=0 <span class="hljs-attribute">ttl</span>=45 <span class="hljs-attribute">time</span>=26.895 ms<br>64 bytes <span class="hljs-keyword">from</span> 220.181.57.216: <span class="hljs-attribute">seq</span>=1 <span class="hljs-attribute">ttl</span>=45 <span class="hljs-attribute">time</span>=26.701 ms<br>^C<br>/ #<span class="hljs-built_in"> ping </span>baidu.com<br>PING baidu.com (123.125.115.110): 56 data bytes<br>64 bytes <span class="hljs-keyword">from</span> 123.125.115.110: <span class="hljs-attribute">seq</span>=0 <span class="hljs-attribute">ttl</span>=43 <span class="hljs-attribute">time</span>=27.587 ms<br>64 bytes <span class="hljs-keyword">from</span> 123.125.115.110: <span class="hljs-attribute">seq</span>=1 <span class="hljs-attribute">ttl</span>=43 <span class="hljs-attribute">time</span>=27.757 ms<br>^C<br></code></pre></div></td></tr></table></figure><p>可以看到，两次 ping 测试（内部首先查询 baidu.com 对应的 IP 地址）拿到的 IP 地址是不一样 的。用 nslookup 可以看到它们都是 baidu.com 对应的 IP 地址：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">/</span> <span class="hljs-comment"># nslookup baidu.com</span><br><span class="hljs-attr">Name:</span> <span class="hljs-string">baidu.com</span><br><span class="hljs-attr">Address:</span> <span class="hljs-number">220.181</span><span class="hljs-number">.57</span><span class="hljs-number">.216</span><br><span class="hljs-attr">Name:</span> <span class="hljs-string">baidu.com</span><br><span class="hljs-attr">Address:</span> <span class="hljs-number">123.125</span><span class="hljs-number">.115</span><span class="hljs-number">.110</span><br></code></pre></div></td></tr></table></figure><p>/etc/hosts 里面可以直接 harcode 一个域名对应的 IP 地址，这会导致机器跳过 DNS 查询，直接拿这个 IP 作 为该域名的 IP。我们来验证一下。</p><p>修改/etc/hosts，添加一行 123.125.115.110 baidu.com，再次 ping 测试</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">/ #<span class="hljs-built_in"> ping </span>baidu.com<br>PING baidu.com (123.125.115.110): 56 data bytes<br>64 bytes <span class="hljs-keyword">from</span> 123.125.115.110: <span class="hljs-attribute">seq</span>=0 <span class="hljs-attribute">ttl</span>=43 <span class="hljs-attribute">time</span>=27.861 ms<br>^C<br>--- baidu.com<span class="hljs-built_in"> ping </span>statistics ---<br>1 packets transmitted, 1 packets received, 0% packet loss<br>round-trip min/avg/max = 27.861/27.861/27.861 ms<br>/ #<span class="hljs-built_in"> ping </span>baidu.com<br>PING baidu.com (123.125.115.110): 56 data bytes<br>64 bytes <span class="hljs-keyword">from</span> 123.125.115.110: <span class="hljs-attribute">seq</span>=0 <span class="hljs-attribute">ttl</span>=43 <span class="hljs-attribute">time</span>=27.614 ms<br>^C<br></code></pre></div></td></tr></table></figure><p>这是不管执行多少次，baidu.com 对应的 IP 地址都不会变了。而实际上，这个 IP 地址并不一定是最优的 IP 地址，甚至有可能这 个 IP 不可用，导致访问 baidu.com 失败。因此，实际中要极力避免在/etc/hosts 中 hardcode。</p><h4 id="DNS-查询不稳定"><a href="#DNS-查询不稳定" class="headerlink" title="DNS 查询不稳定"></a>DNS 查询不稳定</h4><p>现象：DNS 查询不稳定，时快时慢<br>可能的原因：机器上有 tc 或 iptables 规则，导致到 DNS 服务器的 packet 变慢或丢失<br>解决办法：修改或删除 tc/iptables 规则<br>我们用 tc 来模拟网络延迟：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">/ # apk <span class="hljs-builtin-name">add</span> iproute2<br></code></pre></div></td></tr></table></figure><p>首先查看有没有 tc 规则：</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">/ # <span class="hljs-keyword">tc</span> -<span class="hljs-keyword">p</span> qdisc <span class="hljs-keyword">ls</span> dev eth0<br></code></pre></div></td></tr></table></figure><p>默认没有任何规则。</p><p>然后我们加一条：每个 packet 延迟 600ms：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">/ # tc qdisc add dev eth0 root netem delay <span class="hljs-number">600</span>ms<br><br>/ # tc -p qdisc ls dev eth0<br>/ # qdisc netem <span class="hljs-number">8001</span>: root <span class="hljs-built_in">ref</span>cnt <span class="hljs-number">2</span> limit <span class="hljs-number">1000</span> delay <span class="hljs-number">600.0</span>ms<br></code></pre></div></td></tr></table></figure><p>测试：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">/ # dig example.com<br>...<br>example.com.            <span class="hljs-number">15814</span>   IN      A       <span class="hljs-number">93.184</span><span class="hljs-number">.216</span><span class="hljs-number">.34</span><br><br>;; Query time: <span class="hljs-number">600</span> msec<br>;; SERVER: <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.11</span>#<span class="hljs-number">53</span>(<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.11</span>)<br></code></pre></div></td></tr></table></figure><p>可以看到，DNS 查询变成了 600ms。</p><p>这里我们测试的是固定延迟，这种问题很容易发现。我们还可以测试随机延迟，或者按 比例延迟等：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">/ # tc qdisc change dev eth0 root netem delay <span class="hljs-number">600</span>ms <span class="hljs-number">10</span>ms <span class="hljs-number">25</span>%<br>/ # tc qdisc change dev eth0 root netem delay <span class="hljs-number">600</span>ms <span class="hljs-number">20</span>ms distribution normal<br></code></pre></div></td></tr></table></figure><p>此类规则会导致 DNS 查询速度更有随机性。</p><p>最后删除 tc 规则：</p><figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c">/ <span class="hljs-meta"># tc qdisc del dev eth0 root</span><br></code></pre></div></td></tr></table></figure><p>iptables 规则也会导致类似的问题。</p><p>很多软件在运行之后，会在宿主机上添加 tc 或 iptables 规则，例如 OpenStack，K8S 等等 。因此遇到这种随机延迟问题，首先可以查看机器上是否有 tc 或 iptables 规则。</p><h4 id="DNS-反向查询不稳定"><a href="#DNS-反向查询不稳定" class="headerlink" title="DNS 反向查询不稳定"></a>DNS 反向查询不稳定</h4><p>线上遇到过这样一个问题：从一台机器 ping 一个内网域名，每个 ping 包看起来都会卡 5 ～ 30s 不等，但是 CTL-C 关闭 ping 之后，打印出来的统计信息里，既没有丢包，ping 的延迟也很低 （毫秒级），这就很奇怪。接下来：</p><p>dig，很快，毫秒级，说明 DNS 查询没有问题<br>dig 能看到域名对应的 IP，直接 ping 这个 IP，发现是没有卡顿的<br>仍然 ping 域名，用 tcpdump 抓包，tcpdump -i eth0 hostand icmp，发现 ping 包都是立即响应的，印证了统计信息里，ping 延迟很低的事实<br>根据以上信息，说明 ping 卡顿的问题出在这台机器，而且应该就是 ping 程序本身在做什么耗 时的操作。继续：</p><p>仍然 ping 域名，同时，用 ltrace -p跟踪 ping 进程，发现卡在一个叫 gethostbyaddr()的函数<br>查阅文档，发现这个函数是根据 IP 反向查询 hostname，需要和 DNS 交互<br>到这里，基本确定了是 DNS 服务器反向查询的问题，我们用另外几个命令行工具验证一下， 以下三个命令都是根据 IP 反查 hostname：</p><p>nslookup<br>host<br>dig -x<br>果然，以上三个命令都会卡住。修改/etc/resolv.conf，换一个 DNS 服务器之后，问题 消失了。接下来，就去查 DNS 服务器的问题吧。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes上生产环境后的常见问题以及解决方法</title>
    <link href="/2021/10/31/Kubernetes%E4%B8%8A%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%90%8E%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2021/10/31/Kubernetes%E4%B8%8A%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%90%8E%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>随着微服务的不断推进，使用 k8s 集群越来越多，越来越深入，随之而来会遇到一系列的问题，本文向大家介绍实际使用 k8s 遇到的一些问题以及解决方法。</p><h3 id="问题一-修复-K8S-内存泄露问题"><a href="#问题一-修复-K8S-内存泄露问题" class="headerlink" title="问题一:  修复 K8S 内存泄露问题"></a>问题一:  修复 K8S 内存泄露问题</h3><blockquote><p>问题描述<br>A现象-&gt;  当 k8s 集群运行日久以后，有的 node 无法再新建 pod，并且出现如下错误，当重启服务器之后，才可以恢复正常使用。查看 pod 状态的时候会出现以下报错。</p></blockquote><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">applying cgroup … caused: <span class="hljs-built_in">mkdir</span> …<span class="hljs-keyword">no</span> space <span class="hljs-keyword">left</span> <span class="hljs-keyword">on</span> device<br></code></pre></div></td></tr></table></figure><p>或者在 describe pod 的时候出现 cannot allocate memory。</p><p>这时候你的 k8s 集群可能就存在内存泄露的问题了，当创建的 pod 越多的时候内存会泄露的越多，越快。</p><p>B现象-&gt; 具体查看是否存在内存泄露</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">$ cat <span class="hljs-regexp">/sys/</span>fs<span class="hljs-regexp">/cgroup/m</span>emory<span class="hljs-regexp">/kubepods/m</span>emory.kmem.slabinfo<br></code></pre></div></td></tr></table></figure><p>当出现 cat: /sys/fs/cgroup/memory/kubepods/memory.kmem.slabinfo: Input/output error 则说明不存在内存泄露的情况 如果存在内存泄露会出现</p><figure class="highlight objectivec"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs objectivec">slabinfo - version: <span class="hljs-number">2.1</span><br><span class="hljs-meta"># name            <span class="hljs-meta-string">&lt;active_objs&gt;</span> <span class="hljs-meta-string">&lt;num_objs&gt;</span> <span class="hljs-meta-string">&lt;objsize&gt;</span> <span class="hljs-meta-string">&lt;objperslab&gt;</span> <span class="hljs-meta-string">&lt;pagesperslab&gt;</span> : tunables <span class="hljs-meta-string">&lt;limit&gt;</span> <span class="hljs-meta-string">&lt;batchcount&gt;</span> <span class="hljs-meta-string">&lt;sharedfactor&gt;</span> : slabdata <span class="hljs-meta-string">&lt;active_slabs&gt;</span> <span class="hljs-meta-string">&lt;num_slabs&gt;</span> <span class="hljs-meta-string">&lt;sharedavail&gt;</span></span><br></code></pre></div></td></tr></table></figure><blockquote><p>解决方案</p></blockquote><ol><li><p>解决方法思路：关闭 runc 和 kubelet 的 kmem，因为升级内核的方案改动较大，此处不采用。</p></li><li><p>kmem 导致内存泄露的原因：</p></li></ol><p>内核对于每个 cgroup 子系统的的条目数是有限制的，限制的大小定义在 kernel/cgroup.c #L139，当正常在 cgroup 创建一个 group 的目录时，条目数就加 1。我们遇到的情况就是因为开启了 kmem accounting 功能，虽然 cgroup 的目录删除了，但是条目没有回收。这样后面就无法创建 65535 个 cgroup 了。也就是说，在当前内核版本下，开启了 kmem accounting 功能，会导致 memory cgroup 的条目泄漏无法回收。</p><h3 id="问题二：k8s-证书过期问题的两种处理方法"><a href="#问题二：k8s-证书过期问题的两种处理方法" class="headerlink" title="问题二：k8s 证书过期问题的两种处理方法"></a>问题二：k8s 证书过期问题的两种处理方法</h3><blockquote><p>前情提要<br>公司测试环境的 k8s 集群使用已经很长时间了,突然有一天开发联系我说 k8s 集群无法访问，开始以为是测试环境的机器磁盘空间不够了，导致组件异常或者把开发使用的镜像自动清理掉了，但是当登上机器去查验的时候发现不是这个原因。当时觉得也很疑惑。因为开发环境使用人数较少，不应该会出问题，所以就去查验 log 的相关报错信息。</p></blockquote><blockquote><p>问题现象<br>出现 k8s api 无法调取的现象，使用 kubectl 命令获取资源均返回如下报错:</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">$ Unable <span class="hljs-keyword">to</span> <span class="hljs-keyword">connect</span> <span class="hljs-keyword">to</span> the <span class="hljs-keyword">server</span>: x509: certificate has expired <span class="hljs-keyword">or</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> yet <span class="hljs-keyword">valid</span><br></code></pre></div></td></tr></table></figure><p>经网上搜索之后发现应该是 k8s 集群的证书过期了，使用命令排查证书的过期时间</p><figure class="highlight elixir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>kubeadm alpha certs check-expiration<br></code></pre></div></td></tr></table></figure><p>发现确实是证书过期了</p><p>相关介绍以及问题解决<br>因为我们是使用 kubeadm 部署的 k8s 集群，所以更新起证书也是比较方便的，默认的证书时间有效期是一年，我们集群的 k8s 版本是 1.15.3 版本是可以使用以下命令来更新证书的，但是一年之后还是会到期，这样就很麻烦，所以我们需要了解一下 k8s 的证书，然后我们来生成一个时间很长的证书，这样我们就可以不用去总更新证书了。</p><figure class="highlight gams"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> kubeadm alpha certs renew <span class="hljs-keyword">all</span> --config=kubeadm.yaml<br><span class="hljs-symbol">$</span> systemctl restart kubelet<br><span class="hljs-symbol">$</span> kubeadm init phase kubeconfig <span class="hljs-keyword">all</span> --config kubeadm.yaml<br># 然后将生成的配置文件替换,重启 kube-apiserver、kube-controller、kube-scheduler、etcd 这<span class="hljs-number">4</span>个容器即可<br>另外 kubeadm 会在控制面板升级的时候自动更新所有证书，所以使用 kubeadm 搭建的集群最佳的做法是经常升级集群，这样可以确保你的集群保持最新状态并保持合理的安全性。但是对于实际的生产环境我们可能并不会去频繁的升级集群，所以这个时候我们就需要去手动更新证书。<br></code></pre></div></td></tr></table></figure><p>下面我们通过调用 k8s 的 api 来实现更新一个 10 年的证书</p><p>首先在 /etc/kubernetes/manifests/kube-controller-manager.yaml 文件加入配置</p><figure class="highlight haml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haml">spec:<br>  containers:<br>  -<span class="ruby"> <span class="hljs-symbol">command:</span></span><br><span class="ruby">    - kube-controller-manager</span><br><span class="ruby">    <span class="hljs-comment"># 设置证书有效期为 10年</span></span><br><span class="ruby">    - --experimental-cluster-signing-duration=<span class="hljs-number">87600</span>h</span><br><span class="ruby">    - --client-ca-file=<span class="hljs-regexp">/etc/kubernetes</span><span class="hljs-regexp">/pki/ca</span>.crt</span><br></code></pre></div></td></tr></table></figure><p>修改完成后 kube-controller-manager 会自动重启生效。然后我们需要使用下面的命令为 Kubernetes 证书 API 创建一个证书签名请求。如果您设置例如 cert-manager 等外部签名者，则会自动批准证书签名请求（CSRs）。否者，您必须使用 kubectl certificate 命令手动批准证书。以下 kubeadm 命令输出要批准的证书名称，然后等待批准发生：</p><figure class="highlight dsconfig"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dsconfig"><span class="hljs-comment"># 需要将全部 pending 的证书全部批准</span><br>$ <span class="hljs-string">kubeadm </span><span class="hljs-string">alpha </span><span class="hljs-string">certs </span><span class="hljs-string">renew </span><span class="hljs-string">all </span><span class="hljs-built_in">--use-api</span> <span class="hljs-built_in">--config</span> <span class="hljs-string">kubeadm.</span><span class="hljs-string">yaml </span>&amp;<br></code></pre></div></td></tr></table></figure><p>我们还不能直接重启控制面板的几个组件，这是因为使用 kubeadm 安装的集群对应的 etcd 默认是使用的 /etc/kubernetes/pki/etcd/ca.crt 这个证书进行前面的，而上面我们用命令 kubectl certificate approve 批准过后的证书是使用的默认的 /etc/kubernetes/pki/ca.crt 证书进行签发的，所以我们需要替换 etcd 中的 ca 机构证书:</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-meta"># 先拷贝静态 Pod 资源清单</span><br>$ cp -r <span class="hljs-meta-keyword">/etc/</span>kubernetes<span class="hljs-meta-keyword">/manifests/</span> <span class="hljs-meta-keyword">/etc/</span>kubernetes/manifests.bak<br>$ vi <span class="hljs-meta-keyword">/etc/</span>kubernetes<span class="hljs-meta-keyword">/manifests/</span>etcd.yaml<br>......<br><span class="hljs-symbol">spec:</span><br><span class="hljs-symbol">  containers:</span><br>  - command:<br>    - etcd<br>    <span class="hljs-meta"># 修改为 CA 文件</span><br>    - --peer-trusted-ca-file=<span class="hljs-meta-keyword">/etc/</span>kubernetes<span class="hljs-meta-keyword">/pki/</span>ca.crt<br>    - --trusted-ca-file=<span class="hljs-meta-keyword">/etc/</span>kubernetes<span class="hljs-meta-keyword">/pki/</span>ca.crt<br>......<br><span class="hljs-symbol">    volumeMounts:</span><br>    - mountPath: <span class="hljs-meta-keyword">/var/</span>lib/etcd<br><span class="hljs-symbol">      name:</span> etcd-data<br>    - mountPath: <span class="hljs-meta-keyword">/etc/</span>kubernetes/pki  <span class="hljs-meta"># 更改证书目录</span><br><span class="hljs-symbol">      name:</span> etcd-certs<br><span class="hljs-symbol">  volumes:</span><br>  - hostPath:<br><span class="hljs-symbol">      path:</span> <span class="hljs-meta-keyword">/etc/</span>kubernetes/pki  <span class="hljs-meta"># 将 pki 目录挂载到 etcd 中去</span><br><span class="hljs-symbol">      type:</span> DirectoryOrCreate<br><span class="hljs-symbol">    name:</span> etcd-certs<br>  - hostPath:<br><span class="hljs-symbol">      path:</span> <span class="hljs-meta-keyword">/var/</span>lib/etcd<br><span class="hljs-symbol">      type:</span> DirectoryOrCreate<br><span class="hljs-symbol">    name:</span> etcd-data<br>......<br></code></pre></div></td></tr></table></figure><p>由于 kube-apiserver 要连接 etcd 集群，所以也需要重新修改对应的 etcd ca 文件：</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">$ vi /etc/kubernetes/manifests/kube-apiserver.yaml<br>......<br>spec:<br><span class="hljs-code">  containers:</span><br><span class="hljs-code">  - command:</span><br><span class="hljs-code">    - kube-apiserver</span><br><span class="hljs-code">    # 将etcd ca文件修改为默认的ca.crt文件</span><br><span class="hljs-code">    - --etcd-cafile=/etc/kubernetes/pki/ca.crt</span><br>......<br></code></pre></div></td></tr></table></figure><p>除此之外还需要替换 requestheader-client-ca-file 文件，默认是 /etc/kubernetes/pki/front-proxy-ca.crt 文件，现在也需要替换成默认的 CA 文件，否则使用聚合 API，比如安装了 metrics-server 后执行 kubectl top 命令就会报错：</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">$ cp <span class="hljs-regexp">/etc/</span>kubernetes<span class="hljs-regexp">/pki/</span>ca.crt <span class="hljs-regexp">/etc/</span>kubernetes<span class="hljs-regexp">/pki/</span>front-proxy-ca.crt<br>$ cp <span class="hljs-regexp">/etc/</span>kubernetes<span class="hljs-regexp">/pki/</span>ca.key <span class="hljs-regexp">/etc/</span>kubernetes<span class="hljs-regexp">/pki/</span>front-proxy-ca.key<br></code></pre></div></td></tr></table></figure><p>这样我们就得到了一个 10 年证书的 k8s 集群，还可以通过重新编译 kubeadm 来实现一个 10 年证书的，这个我没有尝试，不过在初始化集群的时候也是一个方法。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>openresty之ngx-lua指令详解</title>
    <link href="/2021/10/29/openresty%E4%B9%8Bngx-lua%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/10/29/openresty%E4%B9%8Bngx-lua%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>最近写openresty 记录一下，经常忘。</p><h3 id="指令顺序"><a href="#指令顺序" class="headerlink" title="指令顺序"></a>指令顺序</h3><p>nginx配置文件中执行lua语句是通过指令来识别的，lua指令执行顺序如下：<br><img src="/img/newimg/008i3skNgy1gvwmi5fg8nj30rx0pawfv.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="INIT-BY-LUA代码诠释"><a href="#INIT-BY-LUA代码诠释" class="headerlink" title="INIT_BY_LUA代码诠释"></a>INIT_BY_LUA代码诠释</h3><p>init_by_lua主要用来执行加载比较耗时的操作。这里通过一个例子来说明：我们在ngx中开辟一个全局变量，并在lua中执行自增操作。</p><h4 id="NGINX-CONF-的HTTP中写入："><a href="#NGINX-CONF-的HTTP中写入：" class="headerlink" title="NGINX.CONF 的HTTP中写入："></a>NGINX.CONF 的HTTP中写入：</h4><p>在最后两行，主要意思：</p><p>1）、定一个共享内存，内存大小为1m。</p><p>2）、init_by_lua_file 指定lua的文件位置，这里一般用来执行一些加载比较耗时的操作，比如连接数据库等。</p><figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-comment">#include       mime.types;</span><br>    <span class="hljs-attribute">default_type</span>  application/octet-stream;<br> <br>    <span class="hljs-attribute">log_format</span>  main  <span class="hljs-string">'<span class="hljs-variable">$remote_addr</span> - <span class="hljs-variable">$remote_user</span> [<span class="hljs-variable">$time_local</span>] "<span class="hljs-variable">$request</span>" '</span><br>                      <span class="hljs-string">'<span class="hljs-variable">$status</span> <span class="hljs-variable">$body_bytes_sent</span> "<span class="hljs-variable">$http_referer</span>" '</span><br>                      <span class="hljs-string">'"<span class="hljs-variable">$http_user_agent</span>" "<span class="hljs-variable">$http_x_forwarded_for</span>"'</span>;<br> <br>    <span class="hljs-attribute">access_log</span>  logs/access.log  main;<br> <br>    <span class="hljs-attribute">sendfile</span>        <span class="hljs-literal">off</span>;<br>    <span class="hljs-comment">#tcp_nopush     on;</span><br> <br>    <span class="hljs-comment">#keepalive_timeout  0;</span><br>    <span class="hljs-attribute">keepalive_timeout</span>  <span class="hljs-number">65</span>;<br>    <span class="hljs-attribute">lua_shared_dict</span> shared_data <span class="hljs-number">1m</span>;<br>    <span class="hljs-attribute">init_by_lua_file</span> <span class="hljs-string">"/Users/stefan/mac_develep/nginx/lua/init.lua"</span>;<br></code></pre></div></td></tr></table></figure><h4 id="INIT-LUA的内容："><a href="#INIT-LUA的内容：" class="headerlink" title="INIT.LUA的内容："></a>INIT.LUA的内容：</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver"><span class="hljs-comment">--load module that spend time</span><br><span class="hljs-built_in">local</span> redis = <span class="hljs-built_in">require</span> <span class="hljs-string">"resty.redis"</span><br> <br><span class="hljs-built_in">local</span> cjson = <span class="hljs-built_in">require</span> <span class="hljs-string">"cjson"</span><br> <br><span class="hljs-comment">--global var</span><br>count = <span class="hljs-number">1</span><br><span class="hljs-comment">--</span><br> <br><span class="hljs-comment">--get share data from ngx</span><br><span class="hljs-built_in">local</span> share_data = ngx.shared.shared_data<br> <br>share_data:<span class="hljs-built_in">set</span>(<span class="hljs-string">"count"</span>, <span class="hljs-number">1</span>)<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CDN技术之--流媒体CDN系统的组成</title>
    <link href="/2021/10/29/CDN%E6%8A%80%E6%9C%AF%E4%B9%8B-%E6%B5%81%E5%AA%92%E4%BD%93CDN%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90/"/>
    <url>/2021/10/29/CDN%E6%8A%80%E6%9C%AF%E4%B9%8B-%E6%B5%81%E5%AA%92%E4%BD%93CDN%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h3 id="流媒体业务"><a href="#流媒体业务" class="headerlink" title="流媒体业务"></a>流媒体业务</h3><p>流媒体业务是一种对实时性、连续性、时序性要求非常高的业务，无论从带宽消耗上还是质量保障上来说，<br>对best-effort的IP网络都是一个不小的冲击</p><blockquote><p>高带宽要求<br>高QoS要求<br>组播、广播要求（目前IP网络无法实现端到端的组播业务）</p></blockquote><h4 id="播放一个视频分为以下四个步骤"><a href="#播放一个视频分为以下四个步骤" class="headerlink" title="播放一个视频分为以下四个步骤"></a>播放一个视频分为以下四个步骤</h4><p>–Access<br>–Demux（音视频分离）<br>–Decode(解码解压缩)<br>–Output</p><h4 id="RTP、RTCP、RTSP、RTMP的关系："><a href="#RTP、RTCP、RTSP、RTMP的关系：" class="headerlink" title="RTP、RTCP、RTSP、RTMP的关系："></a>RTP、RTCP、RTSP、RTMP的关系：</h4><p>RTSP协议用来实现远程播放控制，RTP用来提供时间信息和实现流同步，<br>RTCP协助RTP完成传输质量控制&lt;=（播放控制），<br>=&gt;（传输控制）RTMP和HTTP streaming则是将流同步、播放控制、质量控制集成起来的企业自有流媒体传送协议<br>RTMP是adobe的传输协议。<br>RTMP的基本通信单元：消息块（chunk）和消息（message）<br>RTMP协议架构在TCP层之上，但RTMP消息并不是直接封装在TCP中，而是通过一个被称为消息块的封装单元进行传输。<br>消息在网络上发送之前往往需要分割成多个较小的部分，这样较小的部分就是消息块，属于不同消息流的消息块可以在网络上交叉发送。<br>RTSP/RTP和HTTP streaming是目前应用最广泛的流化协议，<br>目前电信运营商在IPTV（特殊通道的基于IP的流媒体播放）的流化上主要以RTSP/RTP技术为主，<br>而互联网视频网站（点播/直播）则多倾向于使用HTTP streaming的流化技术。<br>HTTP streaming前身是progressive download（渐进式下载：边下载边播放，直到下载完）。<br>HTTP streaming首先会将视频数据（包括直播的视频流和点播的视频文件）在服务器上进行编码，<br>然后将编码后的数据进行更细粒度的分片，再把每个分片通过 HTTP协议传输到客户端。<br>HTTP streaming的客户端需要对视频文件的每个分片都发出一个HTTP请求，<br>这样，在视频播放速度低于下载速度的情况下，<br>客户端可以灵活控制HTTP请求的发出速度，从而保证用户在中途退出时不会出现下载浪费。<br>另外，因为采用分片的特点，HTTP streaming还可以实现媒体播放过程中的码率切换（码率自适应），<br>结合网络带宽资源，为用户提供更好的体验。</p><h4 id="HTTP-streaming"><a href="#HTTP-streaming" class="headerlink" title="HTTP streaming"></a>HTTP streaming</h4><p>支持点播、直播<br>可对分片文件加密，保证数字版权<br>因为分片传输，故支持码率自适应    </p><h4 id="Progressive-download"><a href="#Progressive-download" class="headerlink" title="Progressive download"></a>Progressive download</h4><p>仅支持点播<br>直接把媒体文件分割成多个小文件分片，无法保障版权所有<br>只支持固定码率</p><h4 id="HTTP-streaming-1"><a href="#HTTP-streaming-1" class="headerlink" title="HTTP streaming"></a>HTTP streaming</h4><p>基于TCP，更高可靠性，也可以直接利用TCP的流控机制来适应带宽的变化<br>可将播放过的内容保存在客户端<br>使用80端口，能穿越防火墙<br>采用标准的HTTP协议来传输，只需要标准的HTTP服务器支撑    </p><h4 id="RTSP-RTP"><a href="#RTSP-RTP" class="headerlink" title="RTSP/RTP"></a>RTSP/RTP</h4><p>基于UDP<br>不能保存在客户端<br>使用特殊端口<br>需要特殊的流媒体服务器</p><h4 id="HTTP-streaming的几个主流阵营："><a href="#HTTP-streaming的几个主流阵营：" class="headerlink" title="HTTP streaming的几个主流阵营："></a>HTTP streaming的几个主流阵营：</h4><blockquote><p>3GPP adaptive HTTP Streaming<br>Microsoft IIS Smooth Streaming<br>Adobe HTTP Dynamic Streaming (HDS)<br>Apple HTTP Live Streaming (HLS)</p></blockquote><h4 id="HLS流化技术主要分三个部分："><a href="#HLS流化技术主要分三个部分：" class="headerlink" title="HLS流化技术主要分三个部分："></a>HLS流化技术主要分三个部分：</h4><p>服务器组件、分发组件和客户端软件</p><blockquote><p> 服务器组件主要负责从原始的音视频设备捕捉相应的音视频流，并对这些输入的媒体流进行编码，<br>然后进行封装和分片，最后交付给分发组件来进行传送；</p></blockquote><blockquote><p>分发组件主要负责接收客户端发送的请求，然后将封装的流媒体分片文件连同相关的索引文件一起发送给客户端。<br>对于没有采用CDN服务的源服务器，标准的 Web服务器就是一个分发组件，<br>而对于大型的视频网站或者类似的大规模应用平台，分发组件还应包括支持RTMP协议的CDN；</p></blockquote><blockquote><p>客户端软件负责确定应该请求的具体媒体流，下载相关资源，并在下载后通过拼接分片将流媒体重新展现给用户<br>HLS音视频流或流媒体文件在经过编码、封装和分片后，变成多个以.ts结尾的分片文件。<br>流分割器产生的索引文件是以.M3U8为后缀的，用户可以直接通过Web访问来获取<br>分发组件负责将分片文件和索引文件通过HTTP的方式发送给客户端，<br>无须对现有的Web服务器和Cache设备进行额外的扩展、配置和升级<br>客户端组件根据URL来获取这个视频的索引文件。</p></blockquote><p>索引文件包含了可提供分片文件的具体位置、解密密钥以及可用的替换流。<br>HDS，点播内容是通过一个简单的预编码生成MP4片段以及Manifest清单文件；<br>直播的内容准备工作流程相对复杂一点，<br>在播放的过程中生成MP4.（直播推荐用RTMP，使用FMS推流器）<br>MPEG-2 TS是指TS格式封装的、MPEG-2编码格式的媒体流。大多数IPTV系统使用这种内容源。<br>H.264这一层完成原始文件的压缩编码，TS这一层负责音 视频的复用以及同步，<br>RTP这一层负责流的顺序传输，UDP这一层负责数据包的交付，IP层负责传输路由选择</p><p>流媒体加速的回源要求：因为流媒体文件传送带宽需求高，而且往往需要维持TCP长连接，<br>所以一旦CDN回源比例过高，源 站服务器I/O将不堪负荷。</p><p>CDN对内容采取分发方式分为pull和push两种。Pull是被动下拉的方式，push是主动推送的方式。<br>对于流媒体内容，系统一般会选择对热点内容采取push方式的预分发，而普通的网页内容几乎100%是pull方式的。<br>在流媒体CDN系统中，用户访问的调度会更多考虑内容命中，主要是因为流媒体内容文件体积大，业务质量要求高，<br>如果从其他节点拉内容再向用户提供服务会带来额外的延迟，影响用户体验。<br>为进一步提高命中率，流媒体CDN系统普遍采用了对热点内容实施预先push的内容分发策略<br>在流媒体服务系统中，主要关注的技术是对不同流媒体协议、不同编码格式、不同播放器、不同业务质量要求等的适应。</p><p>流媒体CDN与Web CDN的对比（业务差异）<br>主要差异点</p><p>内容类型<br>流媒体CDN:大文件、实时流、QoS要求高<br>Web CDN:小文件、固定大小、QoS要求低</p><p>用户行为<br>流媒体CDN:拖曳、暂停等播放控制<br>Web CDN:下载后浏览</p><p>内容管理<br>流媒体CDN:内容冷热度差异明显（对命中率要求高），内容生命周期长<br>Web CDN:内容冷热度差异不明显，内容生命周期短</p><p>回源要求<br>流媒体CDN:回源比例小<br>Web CDN:回源比例大</p><p>现在已经投入商用的CDN系统，基本都是同时提供Web CDN能力和流媒体CDN能力的，<br>而且这两种能力的实现在系统内部几乎都是互相隔离的，从调度系统到节点设备都没有交叉互用</p><p>流媒体CDN与Web CDN的设计差异（设计差异）<br>主要差异点<br>Cache<br>流媒体CDN:支持多种流化协议，硬件配置大存储、高I/O<br>Web CDN：支持多协议（HTTP、FTP等）硬件配置小存储、高性能CPU</p><p>负载均衡<br>流媒体CDN:DNS+HTTP重定向方式<br>Web CDN:DNS方式</p><p>内容分发方式<br>流媒体CDN：热片PUSH，冷片PULL<br>Web CDN：全PULL方式</p><p>组网<br>流媒体CDN：多级组网，可能要求组播、单播混合组网<br>Web CDN:两级组网</p><p>流媒体CDN的Cache设备与Web Cache无论在软件实现还是硬件要求上差异都很大，我们很少看到这两种业务共用同一台设备<br>当用户请求的内容在Cache上命中时，Cache直接向用户提供流服务，此时Cache设备充当流媒体服务器的角色； 当用户请求内容未能在Cache上命中时，Cache会从上一级Cache（二级缓存设备或中间缓存设备）或者源站服务器获取内容，再提供给用户。</p><p>Cache在用户与另一个流媒体服务器之间扮演代理的角色<br>分布式存储技术因其大容量、低成本的特点，目前也被业界关注和研究作为流媒体CDN系统的存储解决方案之一。<br>常用的分布式存储技术包括分布式文件系统和分布式数据库，<br>由于采用了数据副本冗余（每份数据复制2~3份）、磁盘冗余（Raid1、Raid10、Raid5）等技术，<br>通常可以提供良好的数据容错机制，当单台存储设备断电或者单个存储磁盘失效时，整个存储系统仍能正常工作<br>负载均衡设备在进行用户访问调度时，会综合考虑很多静态的、动态的参数，包括IP就近性、连接保持、内容命中、响应速 度、连接数等。<br>但没有哪个CDN会考虑所有参数，而是会根据业务特点进行一些取舍，否则均衡系统就太复杂了。<br>而流媒体CDN在进行用户访问调度时，会更多考虑内容命中这一参数</p><p>有两种GSLB实现方式，一种是基于DNS的，一种是基于应用层重定向的<br>PUSH方式适合内容访问比较集中的情况，如热点的影视流媒体内容，PULL方式比较适合内容访问分散的情况<br>对使用CDN服务的SP来说，CDN的作用在于尽量就近为用户提供服务，<br>帮助SP解决长距离IP传输和跨域传输带来的种 种业务质量问题（通过空间换取时间）。<br>因此，为用户提供服务的Cache设备一定部署在离用户比较近的地方。另一方面，CDN的建设者从成本角度考虑，又 不能把所有内容都存放在这些离用户最近的节点中，这会消耗大量存储成本，所以这些提供服务的Cache设备会根据需要从源站服务器或者其他Cache获取 内容。</p><p>这样就形成了CDN网络分层部署的概念。<br>从网络分层上看，Web CDN通常是两级架构（也有三级架构以减少回源），即中心-边缘。而流媒体CDN通常有三级以上架构，即中心-区域-边缘。<br>产生这种区别的原因在于流媒体 回源成本比较高，源站服务器响应一次流媒体内容回源请求，要比Web内容回源消耗更多资源。<br>尤其对于流媒体直播业务来说，只要直播节目没结束，服务器就需 要长时间持续吐流，如果没有第二层节点作为中继，那么中心节点的压力将是不可想象的。</p><p>分层部署的方式，对点播业务而言的主要意义是节省存储成本，对直播业务而言在于减少带宽成本。<br>在点播业务中，边缘Cache只需存储用户访问量大的内容或者内容片断，其余内容存储在区域Cache中。<br>在直播业务中，边缘Cache从区域中心获取直播流，而不需要直接向中心节点（源站）获取，<br>从而节省了区域中心到中心节点这一段的大部分带宽。<br>因为直播流在各个Cache中都不需要占用很大的存储空间，只需少量缓存空间即可，<br>所以直播业务方面并不用注重考虑存储成本<br>考虑到电信运营商的IP拓扑和流量模型，区域中心Cache通常部署在重点城市的城域网出口的位置，<br>以保障向各个边缘 Cache的链路通畅。<br>边缘Cache的位置选择则以整个节点能够提供的并发能力为主要依据，依据业务并发数收敛比，<br>计算出单个Cache需要覆盖的用户 规模，从而选择一个合适的部署位置。<br>当然，边缘Cache离用户越近，服务质量越好，但覆盖的用户数越少，部署成本越高。</p><p>内容文件预处理<br>是指视频内容进入CDN以后，进入内容分发流程之前，CDN系统对内容进行的一系列处理过程。这个预处理过程的目的有几个：<br>–为全网内容管理提供依据，比如对内容进行全网唯一标识，对内容基础信息进行记录等<br>–为提高CDN服务效率或降低系统成本提供手段，比如内容切片<br>–为满足业务要求提供能力，比如对同一内容进行多种码率的转换以满足动态带宽自适应或三屏互动业务要求<br>视频转码(video transcoding)<br>– 码率转换<br>–空间分辨率转换<br>–时间分辨率转换<br>– 编码格式转换。编码格式主要包括H.264、MPEG-4、MPEG-2、VC-1、REAL、H.263、WMV。通常是把其他编码格式转换成H.264</p><p>文件切片<br>是指按照一定的规则把一个完整的文件切成大小一致的若干个小文件；<br>由于流媒体CDN需要提供的内容体积越来越大，传统整片存储带来的成本消耗超出了CDN服务商的承受范围；<br>切片的另一个目的是，使边缘Cache能够支持自适应码率业务<br>防盗链机制和实现<br>–基于IP的黑白名单<br>–利用HTTP header的referer字段<br>–使用动态密钥（随机生成的key通过算法生成新的url）<br>–在内容中插入数据（对有版权内容进行加密（DRM），如Microsoft的playready，Google的Widevine）<br>–打包下载：在原文件的基础上进一步封装，使得资源的hash值改变</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>从零到一开发 Operator</title>
    <link href="/2021/10/05/%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80%E5%BC%80%E5%8F%91-Operator/"/>
    <url>/2021/10/05/%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80%E5%BC%80%E5%8F%91-Operator/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转自DaoCloud</p></blockquote><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>在 Kubernetes 已经成为容器调度平台的事实标准之后，对于整个云原生围绕 Kubernetes 来构建自己的业务来说，社区的统一的方案就是通过实现 CRD+Controller 的方式来实现自己的 Kubernetes 的业务能力。此类业务已经覆盖了软件的很多领域，如微服务，DevOps, AI, 安全，网络，存储，大数据，数据库，中间件等等。那接下来，我们就来介绍一下 Operator 是什么，有哪些作用和能力。</p><p>Kubernetes 是一个管理容器化应用程序的平台，它会 Watch ETCD 中存储的信息来比较并在必要时协调所表达的期望状态和对象的当前状态，它的这种工作方式我们称为 Reconciliation Loop（协调循环），而协调循环与状态恢复的大部分工作是通过 Controller 实现的。</p><h3 id="2-什么是-Operator"><a href="#2-什么是-Operator" class="headerlink" title="2. 什么是 Operator"></a>2. 什么是 Operator</h3><p>随着 Kubernetes 生态的不断发展，开箱即用的相对底层，通用的 Kubernetes 基础模型元素已经无法支撑不同业务领域下复杂的自动化场景，更高层次对象的出现，带来的是业务运行时繁琐的运维操作以及复杂的部署场景，因此，Kubernetes 社区在 1.7 版本中提出了 Custom Resources And Controllers 的概念，通过自定义资源以及自定义控制器达到对 Kubernetes API 进行拓展的目的，而 Operator 正是这个模型的实现。</p><p>CoreOS 在 2016 年底提出了 Operator 的概念，官方定义如下：</p><blockquote><p>An Operator represents human operational knowledge in software, to reliably manage an application. They are methods of packaging, deploying, and managing a Kubernetes application.    </p></blockquote><p>简单来说，Operators 就是一组自定义控制器的集合以及由这些控制器管理着的一系列自定义资源，我们将不在关注于 pod，configmap 等基本模型元素，而是将他们聚合为一个应用或服务，Operator 通过控制器的协调循环来使自定义应用达到我们期望的状态，我们只需要关注该应用的期望状态，通过自定义控制器协调循环逻辑，来达到安装，更新，扩展，备份，恢复 7*24 小时不间断的应用或服务的生命周期管理。</p><h3 id="3-Operator-的工作原理"><a href="#3-Operator-的工作原理" class="headerlink" title="3. Operator 的工作原理"></a>3. Operator 的工作原理</h3><p>Operator 使用自定义资源(CR)管理应用以及其组件的自定义 kubernetes 控制器，自定义资源是 kubernetes 中的 API 扩展，自定义资源配置(CRD)会明确 CR 并列出 Operator 用户可用的所有配置，Operator 监视 CR 类型并且采取特定于应用的操作，确保当前状态与该资源的理想状态相符。</p><p>Operator 工作流程：<br><img src="/img/newimg/008i3skNly1gvc901ct2lj60u01aswg902.jpg" srcset="/img/loading.gif" alt=""></p><p>一个 Operator 中主要有以下几种对象：</p><p>CRD:自定义资源的定义，Kubernetes API 服务器会为你所指定的每一个 CRD 版本生成 RESTful 的资源路径。一个 CRD 其实就是定义自己应用业务模型的地方，可以根据业务的需求，完全定制自己所需要的资源对象，如 RedisCluster, PrometheusServer 等这些都是可以被 Kubernetes 直接操作和管理的自定义的资源对象。</p><p>CR：自定义资源，即 CRD 的一个具体实例，是具体的可管理的 Kubernetes 资源对象，可以对其进行正常的生命周期管理，如创建，删除，修改，查询等，同时 CR 对象一般还会包含运行时的状态，如当前的 CR 的真实的状态是什么，用于观察和判断，CR 对象的真正所处于的状态。</p><p>Controller：其实就是控制器真正的用武之地了，它会循环处理工作队列中的动作，按照逻辑协调应用当前状态至期望状态。如观察一个 CR 对象被创建了之后，会根据实现的逻辑来处理 CR，让 CR 对象的状态以及CR对象所负责的业务逻辑慢慢的往最终期望的状态上靠近，最终达到期望的效果，举例来说如果定义了一个 RocketMQ 的 Operator，那在创建 RocketMQCluster 的时候，就会一直协调和观察 RocketMQ 真正的集群是不是创建好了，以及每个节点的状态和可用性是不是健康的，一旦发现不符合期望的状态就会继续协调，就一直保持基于事件的机制，不断检查和协调，去保证期望的状态。</p><h3 id="4-开发一个-Operator"><a href="#4-开发一个-Operator" class="headerlink" title="4. 开发一个 Operator"></a>4. 开发一个 Operator</h3><p>从 0 开始开发一个 Operator 是非常困难的，因此 Operator Framework 为我们提供了 webhook 以及 controller 的框架，使开发者可以忽略一些 Kubernetes 底层细节，只需要关注于被管理应用的运维逻辑实现。</p><p>目前主流的 Operator Framework 主要有两个：Kubebuilder 以及 Operator SDK。以下将以 DaoCloud 自研的 RocketMQ Operator 为例，介绍使用 Operator SDK 开发一个 Operator 的过程。</p><blockquote><p>4.1. 创建 rocketmq operator 项目,并生成样板文件</p></blockquote><p>mkdir rocketmq-operator</p><p>operator-sdk init  –domain daocloud.io</p><p>生成以下文件以及目录：<br><img src="/img/newimg/008i3skNly1gvc90n9ansj60jg07gdgs02.jpg" srcset="/img/loading.gif" alt=""></p><p>go.mod：与我们的项目匹配的新 Go 模块，具有基本依赖项。</p><p>PROJECT：我们应用的一些元数据元数据</p><p><img src="/img/newimg/008i3skNly1gvc90xstguj60n408mjs602.jpg" srcset="/img/loading.gif" alt=""></p><p>如上，定义了项目名称，版本以及 repo 等</p><p>Makefile：构建与部署控制器的工程文件</p><p>Config: 部署控制器的一些编排文件，包括控制器，RBAC 等</p><blockquote><p>4.2. 创建组为 rocketmq 版本为 v1 类型为 Broker 的新的自定义资源定义(CRD)，并设置控制器</p></blockquote><p>operator-sdk create api –group rocketmq  –version v1 –kind Broker –resource –controller</p><p>生成文件目录结构如下：</p><p><img src="/img/newimg/008i3skNly1gvc91cyt96j60n40a4jt202.jpg" srcset="/img/loading.gif" alt=""><br>再次查看 PROJECT 文件：<br><img src="/img/newimg/008i3skNly1gvc91iiua7j60n40j640302.jpg" srcset="/img/loading.gif" alt=""><br>PROJECT 文件中新增了 Resources 字段，描述了我们添加的 Broker CRD 以及它的版本。</p><p>Api：自定义类型元数据存放位置，每次创建新类型都会在此处生成新文件。</p><p>Controller：自定义资源的控制器协调循环逻辑</p><blockquote><p>4.3. 关注于自定义类型与控制循环            </p></blockquote><p>查看 api/v1/ broker_types.go 文件，我们对 BrokerSpec 以及 BrokerStatus 做一些定义，以使 Kubernetes 通过 Controller 协调 Broker</p><p><img src="/img/newimg/008i3skNly1gvc91u0kc0j60iy0bowf902.jpg" srcset="/img/loading.gif" alt=""></p><p>如下所示，我们定义了一系列字段来设置对 Broker 的期望状态，同时也定义了一系列字段来描述 Broker 的当前状态，以供我们很方便的监控 Broker 的生命周期</p><p><img src="/img/newimg/008i3skNly1gvc925r7tlj60iy0aat9n02.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="/img/newimg/008i3skNly1gvc929vdhij60jc076mxv02.jpg" srcset="/img/loading.gif" alt=""></p><p>由上述介绍我们已经知道控制器主要完成协调循环逻辑， 将自定义资源不断推向期望状态，需要注意的是控制器运行在集群上并对集群资源进行增删改查，所以需要 RBAC 权限。</p><p><img src="/img/newimg/008i3skNly1gvc92fv29zj60n40dqmyb02.jpg" srcset="/img/loading.gif" alt=""></p><p>控制器会监视资源的增删改事件，并触发 reconcile 函数作为响应，每个控制器都有两个核心组件：Informer 以及 Workqueue，Informer 负责 Watch 指定资源的变化，将增删改时间发送到 Workqueue 中，然后控制器的 Worker 从Workqueue 中取出事件交由控制器程序处理，这些机制 controller-runtime 包已经帮我们实现，当我们需要设置对指定的资源进行 Watch 时，只需更改 broker_controller.go 中 SetupWithManager 方法即可。 </p><p><img src="/img/newimg/008i3skNly1gvc92lt4sjj60n405wjrt02.jpg" srcset="/img/loading.gif" alt=""></p><p>如上，当前控制器会监听 Broker 资源，如果我们希望它同时监听 Deploymeng/Pod 等资源可以用 For 进一步指定，如果我们希望监听由 Broker 类型创建的 Deploymeng，可以使用 Owns 进行指定，当然这要求 Broker 与由他创建的 Deployment 具有从属关系。</p><p>RocketMQ Operator Broker 使用 DLedger 模式部署，实现了按组扩缩容，配置文件热更新，动态获取 Nameserver 地址等功能，简单的协调逻辑如图：</p><p><img src="/img/newimg/008i3skNly1gvc92rj1e2j60qa0igjsd02.jpg" srcset="/img/loading.gif" alt=""></p><p>在开始一次协调循环之前，我们先看看 Operator SDK 帮助我们做了什么事：</p><p>首先它会将自定义资源的 Group 和 Version 以及 Kind（GVK）注册进 Scheme中，维持 GVK 与我们编写的自定义资源结构体的映射关系.</p><p><img src="/img/newimg/008i3skNly1gvc942t620j60u007v3z602.jpg" srcset="/img/loading.gif" alt=""></p><p>而每一个控制器中都需要 Scheme，以通过 GVK 来找到我们所要 Watch 的 Kind，也就是我们编写的自定义资源 Struct,而实例化以后便是 GVR，因此 GVK 与 GVR 便是 Reconcile 的关键，控制器又通过 Informer Watch 到自定义资源的增删改查事件，来触发 Reconcile，一次协调循环就此开始：</p><p>对比 RocketMQ 协调逻辑图，主要发生了以下几步： </p><p>Reconcile 是所有 Operator 的程序协调整个过程的入口，一般处理的逻辑是判断CR对象是新建的，修改的，还是删除的，进行一些常规处理，然后就会进入真正的协调的完整过程。<br>Finalize 阶段，检查实例是否需要被删除，使用 Finalize 异步删除实例所关联的外部资源例如存储等。<br>PreConfig 阶段，预创建实例所需要的 ConfigMap/Secret 等对象。<br>Sync 阶段，根据定义的 CR 编排文件，对实例进行部署以及更新操作，监控配置，存储挂载，扩容，缩容，并检查实例状态，根据实例的状态进行进一步的协调的过程，最终保障实例的状态是达到了期望的状态了。</p><p>为了保证应用完整的运维性，监控当然必不可少：</p><p><img src="/img/newimg/008i3skNly1gvc94dmhn5j60u00bimy802.jpg" srcset="/img/loading.gif" alt=""></p><p>如上，通过在控制器中添加 Metrics 地址来暴露出我们的监控指标，使用 RocketMQ Exporter 提供监控指标给 Prometheus 使用</p><p><img src="/img/newimg/008i3skNly1gvc94kpjjej60u00gimzg02.jpg" srcset="/img/loading.gif" alt=""><br>这样，一个具备自动化运维及监控，扩缩容能力的 Operator 就开发完成了，以下是它的一个基本架构：</p><p><img src="/img/newimg/008i3skNly1gvc953xyl4j60qg0lr75e02.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="5-Operator-社区"><a href="#5-Operator-社区" class="headerlink" title="5. Operator 社区"></a>5. Operator 社区</h3><p>随着 Operator 的种类的增多和秉持着开源共享的精神，社区也相继推出了开放和共享 Operator 的机制，如 operatorhub.io, artifacthub.io。</p><p><img src="/img/newimg/008i3skNly1gvc95f4po2j60u00ew40302.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="/img/newimg/008i3skNly1gvc95lwlu1j60u00evq4102.jpg" srcset="/img/loading.gif" alt=""></p><p>如果大家对 Operator 实现细节感兴趣，可以参考社区中几个不错的 Operator 实现：</p><p>Kafka：CNCF 的项目，<a href="https://github.com/strimzi/strimzi-kafka-operator" target="_blank" rel="noopener">https://github.com/strimzi/strimzi-kafka-operator</a></p><p>ElasticSearch: ES 官方的项目，<a href="https://github.com/elastic/cloud-on-k8s" target="_blank" rel="noopener">https://github.com/elastic/cloud-on-k8s</a></p><p>RabbitMQ: RabbitMQ 官方的项目，<a href="https://github.com/rabbitmq/cluster-operator" target="_blank" rel="noopener">https://github.com/rabbitmq/cluster-operator</a></p><h3 id="6-挑战"><a href="#6-挑战" class="headerlink" title="6. 挑战"></a>6. 挑战</h3><p>开发一个优秀的 Operator，首先的要求是对封装组件本身需要比较熟悉。以中间件为例，来分析一下面临的挑战：</p><p>首先，对于架构师而言，应该是具备中间件架构设计能力，以及需要有中间件丰富运维经验；</p><p>其次，对于研发而言，就是有 Operator 的研发能力，以及能结合周边的监控，告警，日志，容器存储，容器网络等系统，打造完善的中间件的 Opetator 能力；</p><p>最后，对于交付而言，需要有丰富的运维经验，能理解 Operator 本身的能力，以及利用好 Operator 能力，结合客户周边的监控，告警，日志，容器存储，容器网络等系统，去完整的交付和运维 Operator，以及 Operator 负责的中间件。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CDN技术详解之系统架构</title>
    <link href="/2021/09/30/CDN%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3%E4%B9%8B%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    <url>/2021/09/30/CDN%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3%E4%B9%8B%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h3 id="功能架构"><a href="#功能架构" class="headerlink" title="功能架构"></a>功能架构</h3><p><img src="/img/newimg/008i3skNgy1guyndogyrvj60en06474v02.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="分发系统"><a href="#分发系统" class="headerlink" title="分发系统"></a>分发系统</h4><p><img src="/img/newimg/008i3skNgy1guynea2m45j60q30gujt902.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="负载均衡系统"><a href="#负载均衡系统" class="headerlink" title="负载均衡系统"></a>负载均衡系统</h4><p><img src="/img/newimg/008i3skNgy1guynfgup8rj60zw0aptbp02.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="运营管理系统"><a href="#运营管理系统" class="headerlink" title="运营管理系统"></a>运营管理系统</h4><p><img src="/img/newimg/008i3skNgy1guynfsyxyzj610x0980uq02.jpg" srcset="/img/loading.gif" alt=""></p><hr><h3 id="部署账号"><a href="#部署账号" class="headerlink" title="部署账号"></a>部署账号</h3><p><img src="/img/newimg/008i3skNgy1guyng2xcq0j616009jtb702.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="CDN系统分类"><a href="#CDN系统分类" class="headerlink" title="CDN系统分类"></a>CDN系统分类</h3><p><img src="/img/newimg/008i3skNgy1guyngirlg2j60y50gz77c02.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我心目中的武汉</title>
    <link href="/2021/06/12/%E6%88%91%E5%BF%83%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%AD%A6%E6%B1%89/"/>
    <url>/2021/06/12/%E6%88%91%E5%BF%83%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%AD%A6%E6%B1%89/</url>
    
    <content type="html"><![CDATA[<p>武汉，是全国市区面积最大的城市之一。然而，两江分隔，三镇分立，不仅从地理上,也从思想与精神上，把武汉分成了无数个区域版块。对于一个没有“城市中心”的城市而言，思想、精神、地理、文化层面，也至今没有建构起任何中心化的高度认同;</p><p>这就导致，武汉名义上是一座城市，实际上是无数个分散的“城镇集合体”。它们各自分立，各自为营，利益割据，资源分散，相互竞争，也彼此内耗;兄弟阋墙，就没有办法形成一个真正意义上，有共同价值观与价值追求的城市共同体。</p><p>而一座城市没有统一的思想文化与价值追求的结果，就导致利益的纷争与分化，演化成城市群体内部的撕裂与封闭;相互竞争，内耗，撕扯，鄙视，牵制，形成各种封闭的利益壁垒与利益小团体，各自为营，各自为政，反而成为了这座城市的某种主旋律与文化基调。</p><p>在现代的高铁时代武汉已然不是古代传言的九省通衢。而近代历史对武汉来说也是一个没落历程,当年为了改革开放的大三线建设 把武汉的轻工业以及军工业都转到重庆等西北西南地区，一直到最近两年,武汉光谷高科产业才有一些气色，但是汉阳以及汉口等真正老武汉依旧是死气沉沉。</p><p>希望未来的武汉长江新区能获批，天河机场等区域能产业规模化。那或许是新武汉的出路。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>怎么写好ppt</title>
    <link href="/2021/05/24/%E6%80%8E%E4%B9%88%E5%86%99%E5%A5%BDppt/"/>
    <url>/2021/05/24/%E6%80%8E%E4%B9%88%E5%86%99%E5%A5%BDppt/</url>
    
    <content type="html"><![CDATA[<p>先留个坑</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>减肥成果</title>
    <link href="/2021/05/18/%E5%87%8F%E8%82%A5%E6%88%90%E6%9E%9C/"/>
    <url>/2021/05/18/%E5%87%8F%E8%82%A5%E6%88%90%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/newimg/008i3skNgy1gqmlxe53h6j30ig0e975d.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>微服务之BFF架构设计</title>
    <link href="/2021/04/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BBFF%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <url>/2021/04/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8BBFF%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是BFF"><a href="#什么是BFF" class="headerlink" title="什么是BFF"></a>什么是BFF</h2><p>BFF是（Backends For Frontends）单词的缩写，主要是用于服务前端的后台应用程序，来解决多访问终端业务耦合问题。</p><p>在业务突增以,不同的终端拥有不同的接口服务，有不同的操作数据的能力，针对这种业务场景做出了调研，我们是否可以在不同的访问层进行业务逻辑处理，获取不同的数据内容呢？</p><p>早在微服务出现的初期就已经存在类似的业务需求出现，而且衍生出了一套成熟的解决方案，那就是BFF，可以针对不用业务场景来提供对应的服务接口，每一种业务场景之间完全独立。</p><h2 id="演进过程"><a href="#演进过程" class="headerlink" title="演进过程"></a>演进过程</h2><blockquote><p>在传统的应用程序中，我们一般只将接口提供给一种类型的终端使用。</p></blockquote><h2 id="单端调用基础服务"><a href="#单端调用基础服务" class="headerlink" title="单端调用基础服务"></a>单端调用基础服务</h2><p><img src="/img/newimg/008eGmZEgy1gpgr5zoorpj30k707x74l.jpg" srcset="/img/loading.gif" alt=""></p><p>传统的应用程序内提供的接口是有业务针对性的，这种类型的接口如果独立出来再提供给别的系统再次使用是一件比较麻烦的事情，设计初期的高耦合就决定了这一点。</p><h2 id="多端直接调用基础服务"><a href="#多端直接调用基础服务" class="headerlink" title="多端直接调用基础服务"></a>多端直接调用基础服务</h2><p><img src="/img/newimg/008eGmZEgy1gpgr6hjfx6j30ko087q3u.jpg" srcset="/img/loading.gif" alt=""></p><p>如果我们的接口同时提供给web、移动端使用，移动端仅用来采集数据以及数据的展示，而web端大多数场景是用来管理数据，因为不同端点的业务有所不同每一个端的接口复用度不会太高。</p><h2 id="多端共用一个BFF"><a href="#多端共用一个BFF" class="headerlink" title="多端共用一个BFF"></a>多端共用一个BFF</h2><p><img src="/img/newimg/008eGmZEgy1gpgr7559nij30m508uq3y.jpg" srcset="/img/loading.gif" alt=""></p><p>针对多端共用服务接口的场景，我们将基础的数据服务与BFF进行了分离，数据服务仅提供数据的增删改查，并不过多涉及业务的判断处理，所有业务判断处理都交给BFF来把控，遇到的一些业务逻辑异常也同样由BFF格式化处理后展示给访问端点。</p><p>这种设计方式同样存在一定的问题，虽然基础服务与BFF进行了分离，我们只需要在BFF层面进行业务判断处理，但是多个端共用一个BFF，也会导致代码编写复杂度增高、代码可阅读性降低、多端业务耦合。</p><h2 id="每个端提供一个BFF"><a href="#每个端提供一个BFF" class="headerlink" title="每个端提供一个BFF"></a>每个端提供一个BFF</h2><p><img src="/img/newimg/008eGmZEgy1gpgr97oe0fj30m6095abb.jpg" srcset="/img/loading.gif" alt=""><br>如果我们为每一个端点都提供一个BFF，每个端点的BFF处理自身的业务逻辑，需要数据时从基础服务内获取，然后在接口返回之前进行组装数据用于实例化返回对象。</p><p>这样基础服务如果有新功能添加，BFF几乎不会受到影响，而我们如果后期把App端点进行拆分成Android、IOS时我们只需要将app-bff进行拆分为android-bff、ios-bff，基础服务同样也不会受到影响</p><p><img src="/img/newimg/008eGmZEgy1gpgr9lu1htj30m308jq4u.jpg" srcset="/img/loading.gif" alt=""><br>这样每当新增一个访问端点时，我们需要修改的地方也只有网关的转发以及添加一个BFF即可，基础服务内提供的服务接口我们完全可以复用，因为基础服务提供的接口都是没有业务针对性的！！！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在微服务架构设计中，BFF起到了一个业务聚合的关键作用，可以 通过openfeign、restTemplate调用基础服务来获取数据，将获取到的数据进行组装返回结果对象，BFF解决了业务场景问题，也同样带来了一些问题，如下所示：</p><ul><li>响应时间延迟（服务如果是内网之间访问，延迟时间较低）</li><li>编写起来较为浪费时间（因为在基础服务上添加的一层转发，所以会多写一部分代码）</li><li>业务异常处理（统一格式化业务异常的返回内容）</li><li>分布式事务（微服务的通病）</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>linux内核Epoll 实现原理</title>
    <link href="/2021/04/08/linux%E5%86%85%E6%A0%B8Epoll-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <url>/2021/04/08/linux%E5%86%85%E6%A0%B8Epoll-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="Epoll-实现原理"><a href="#Epoll-实现原理" class="headerlink" title="Epoll 实现原理"></a>Epoll 实现原理</h2><p><code>epoll</code> 是Linux平台下的一种特有的多路复用IO实现方式，与传统的 <code>select</code> 相比，<code>epoll</code> 在性能上有很大的提升。本文主要讲解 <code>epoll</code> 的实现原理，而对于 <code>epoll</code> 的使用可以参考相关的书籍或文章。</p><h3 id="epoll-的创建"><a href="#epoll-的创建" class="headerlink" title="epoll 的创建"></a>epoll 的创建</h3><p>要使用 <code>epoll</code> 首先需要调用 <code>epoll_create()</code> 函数创建一个 <code>epoll</code> 的句柄，<code>epoll_create()</code> 函数定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">epoll_create</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span></span>;<br></code></pre></div></td></tr></table></figure><p>参数 <code>size</code> 是由于历史原因遗留下来的，现在不起作用。当用户调用 <code>epoll_create()</code> 函数时，会进入到内核空间，并且调用 <code>sys_epoll_create()</code> 内核函数来创建 <code>epoll</code> 句柄，<code>sys_epoll_create()</code> 函数代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">asmlinkage <span class="hljs-keyword">long</span> <span class="hljs-title">sys_epoll_create</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> error, fd = <span class="hljs-number">-1</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> *<span class="hljs-title">ep</span>;</span><br><br>    error = -EINVAL;<br>    <span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">0</span> || (error = ep_alloc(&amp;ep)) &lt; <span class="hljs-number">0</span>) &#123;<br>        fd = error;<br>        <span class="hljs-keyword">goto</span> error_return;<br>    &#125;<br><br>    fd = anon_inode_getfd(<span class="hljs-string">"[eventpoll]"</span>, &amp;eventpoll_fops, ep);<br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>)<br>        ep_free(ep);<br><br>error_return:<br>    <span class="hljs-keyword">return</span> fd;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>sys_epoll_create()</code> 主要做两件事情：</p><ol><li>调用 <code>ep_alloc()</code> 函数创建并初始化一个 <code>eventpoll</code> 对象。</li><li>调用 <code>anon_inode_getfd()</code> 函数把 <code>eventpoll</code> 对象映射到一个文件句柄，并返回这个文件句柄。</li></ol><p>我们先来看看 <code>eventpoll</code> 这个对象，<code>eventpoll</code> 对象用于管理 <code>epoll</code> 监听的文件列表，其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> &#123;</span><br>    ...<br>    <span class="hljs-keyword">wait_queue_head_t</span> wq;<br>    ...<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">rdllist</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_root</span> <span class="hljs-title">rbr</span>;</span><br>    ...<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>先来说明一下 <code>eventpoll</code> 对象各个成员的作用：</p><ol><li><code>wq</code>: 等待队列，当调用 <code>epoll_wait(fd)</code> 时会把进程添加到 <code>eventpoll</code> 对象的 <code>wq</code> 等待队列中。</li><li><code>rdllist</code>: 保存已经就绪的文件列表。</li><li><code>rbr</code>: 使用红黑树来管理所有被监听的文件。</li></ol><p>下图展示了 <code>eventpoll</code> 对象与被监听的文件关系：</p><p><img src="/img/newimg/008eGmZEly1gpc5c1gib3j30j30k5q4a.jpg" srcset="/img/loading.gif" alt=""></p><p>由于被监听的文件是通过 <code>epitem</code> 对象来管理的，所以上图中的节点都是以 <code>epitem</code> 对象的形式存在的。为什么要使用红黑树来管理被监听的文件呢？这是为了能够通过文件句柄快速查找到其对应的 <code>epitem</code> 对象。红黑树是一种平衡二叉树，如果对其不了解可以查阅相关的文档。</p><h3 id="向-epoll-添加文件句柄"><a href="#向-epoll-添加文件句柄" class="headerlink" title="向 epoll 添加文件句柄"></a>向 epoll 添加文件句柄</h3><p>前面介绍了怎么创建 <code>epoll</code>，接下来介绍一下怎么向 <code>epoll</code> 添加要监听的文件。</p><p>通过调用 <code>epoll_ctl()</code> 函数可以向 <code>epoll</code> 添加要监听的文件，其原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">epoll_ctl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epfd, <span class="hljs-keyword">int</span> op, <span class="hljs-keyword">int</span> fd,struct epoll_event *event)</span></span>;<br></code></pre></div></td></tr></table></figure><p>下面说明一下各个参数的作用：</p><ol><li><code>epfd</code>: 通过调用 <code>epoll_create()</code> 函数返回的文件句柄。</li><li><code>op</code>: 要进行的操作，有3个选项：<ul><li><code>EPOLL_CTL_ADD</code>：表示要进行添加操作。</li><li><code>EPOLL_CTL_DEL</code>：表示要进行删除操作。</li><li><code>EPOLL_CTL_MOD</code>：表示要进行修改操作。</li></ul></li><li><code>fd</code>: 要监听的文件句柄。</li><li><code>event</code>: 告诉内核需要监听什么事。其定义如下：<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> &#123;</span><br>    <span class="hljs-keyword">__uint32_t</span> events;  <span class="hljs-comment">/* Epoll events */</span><br>    <span class="hljs-keyword">epoll_data_t</span> data;  <span class="hljs-comment">/* User data variable */</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><code>events</code> 可以是以下几个宏的集合：</li></ol><ul><li><code>EPOLLIN</code> ：表示对应的文件句柄可以读（包括对端SOCKET正常关闭）；</li><li><code>EPOLLOUT</code>：表示对应的文件句柄可以写；</li><li><code>EPOLLPRI</code>：表示对应的文件句柄有紧急的数据可读（这里应该表示有带外数据到来）；</li><li><code>EPOLLERR</code>：表示对应的文件句柄发生错误；</li><li><code>EPOLLHUP</code>：表示对应的文件句柄被挂断；</li><li><code>EPOLLET</code>：将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</li><li><code>EPOLLONESHOT</code>：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里。</li></ul><p><code>data</code> 用来保存用户自定义数据。</p><p><code>epoll_ctl()</code> 函数会调用 <code>sys_epoll_ctl()</code> 内核函数，<code>sys_epoll_ctl()</code> 内核函数的实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">asmlinkage <span class="hljs-keyword">long</span> <span class="hljs-title">sys_epoll_ctl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epfd, <span class="hljs-keyword">int</span> op, </span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span> fd, struct epoll_event __user *event)</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br>    file = fget(epfd);<br>    tfile = fget(fd);<br>    ...<br>    ep = file-&gt;private_data;<br><br>    mutex_lock(&amp;ep-&gt;mtx);<br><br>    epi = ep_find(ep, tfile, fd);<br><br>    error = -EINVAL;<br>    <span class="hljs-keyword">switch</span> (op) &#123;<br>    <span class="hljs-keyword">case</span> EPOLL_CTL_ADD:<br>        <span class="hljs-keyword">if</span> (!epi) &#123;<br>            epds.events |= POLLERR | POLLHUP;<br><br>            error = ep_insert(ep, &amp;epds, tfile, fd);<br>        &#125; <span class="hljs-keyword">else</span><br>            error = -EEXIST;<br>        <span class="hljs-keyword">break</span>;<br>    ...<br>    &#125;<br>    mutex_unlock(&amp;ep-&gt;mtx);<br><br>    ...<br>    <span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>sys_epoll_ctl()</code> 函数会根据传入不同 <code>op</code> 的值来进行不同操作，比如传入 <code>EPOLL_CTL_ADD</code> 表示要进行添加操作，那么就调用 <code>ep_insert()</code> 函数来进行添加操作。</p><p>我们继续来分析添加操作 <code>ep_insert()</code> 函数的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ep_insert</span><span class="hljs-params">(struct eventpoll *ep, struct epoll_event *event,</span></span><br><span class="hljs-function"><span class="hljs-params">             struct file *tfile, <span class="hljs-keyword">int</span> fd)</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br>    error = -ENOMEM;<br>    <span class="hljs-comment">// 申请一个 epitem 对象</span><br>    <span class="hljs-keyword">if</span> (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))<br>        <span class="hljs-keyword">goto</span> error_return;<br><br>    <span class="hljs-comment">// 初始化 epitem 对象</span><br>    INIT_LIST_HEAD(&amp;epi-&gt;rdllink);<br>    INIT_LIST_HEAD(&amp;epi-&gt;fllink);<br>    INIT_LIST_HEAD(&amp;epi-&gt;pwqlist);<br>    epi-&gt;ep = ep;<br>    ep_set_ffd(&amp;epi-&gt;ffd, tfile, fd);<br>    epi-&gt;event = *event;<br>    epi-&gt;nwait = <span class="hljs-number">0</span>;<br>    epi-&gt;next = EP_UNACTIVE_PTR;<br><br>    epq.epi = epi;<br>    <span class="hljs-comment">// 等价于: epq.pt-&gt;qproc = ep_ptable_queue_proc</span><br>    init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);<br><br>    <span class="hljs-comment">// 调用被监听文件的 poll 接口. </span><br>    <span class="hljs-comment">// 这个接口又各自文件系统实现, 如socket的话, 那么这个接口就是 tcp_poll().</span><br>    revents = tfile-&gt;f_op-&gt;poll(tfile, &amp;epq.pt);<br>    ...<br>    ep_rbtree_insert(ep, epi); <span class="hljs-comment">// 把 epitem 对象添加到epoll的红黑树中进行管理</span><br><br>    spin_lock_irqsave(&amp;ep-&gt;lock, flags);<br><br>    <span class="hljs-comment">// 如果被监听的文件已经可以进行对应的读写操作</span><br>    <span class="hljs-comment">// 那么就把文件添加到epoll的就绪队列 rdllink 中, 并且唤醒调用 epoll_wait() 的进程.</span><br>    <span class="hljs-keyword">if</span> ((revents &amp; event-&gt;events) &amp;&amp; !ep_is_linked(&amp;epi-&gt;rdllink)) &#123;<br>        list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);<br><br>        <span class="hljs-keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))<br>            wake_up_locked(&amp;ep-&gt;wq);<br>        <span class="hljs-keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))<br>            pwake++;<br>    &#125;<br><br>    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);<br>    ...<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>被监听的文件是通过 <code>epitem</code> 对象进行管理的，也就是说被监听的文件会被封装成 <code>epitem</code> 对象，然后会被添加到 <code>eventpoll</code> 对象的红黑树中进行管理（如上述代码中的 <code>ep_rbtree_insert(ep, epi)</code>）。</p><p><code>tfile-&gt;f_op-&gt;poll(tfile, &amp;epq.pt)</code> 这行代码的作用是调用被监听文件的 <code>poll()</code> 接口，如果被监听的文件是一个socket句柄，那么就会调用 <code>tcp_poll()</code>，我们来看看 <code>tcp_poll()</code> 做了什么操作：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tcp_poll</span><span class="hljs-params">(struct file *file, struct socket *sock, poll_table *wait)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span> *<span class="hljs-title">sk</span> = <span class="hljs-title">sock</span>-&gt;<span class="hljs-title">sk</span>;</span><br>    ...<br>    poll_wait(file, sk-&gt;sk_sleep, wait);<br>    ...<br>    <span class="hljs-keyword">return</span> mask;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>每个 <code>socket</code> 对象都有个等待队列（<code>waitqueue</code>, ）,用于存放等待 socket 状态更改的进程。</p><p>从上述代码可以知道，<code>tcp_poll()</code> 调用了 <code>poll_wait()</code> 函数，而 <code>poll_wait()</code> 最终会调用 <code>ep_ptable_queue_proc()</code> 函数，<code>ep_ptable_queue_proc()</code> 函数实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ep_ptable_queue_proc</span><span class="hljs-params">(struct file *file, </span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">wait_queue_head_t</span> *whead, poll_table *pt)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">epi</span> = <span class="hljs-title">ep_item_from_epqueue</span>(<span class="hljs-title">pt</span>);</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eppoll_entry</span> *<span class="hljs-title">pwq</span>;</span><br><br>    <span class="hljs-keyword">if</span> (epi-&gt;nwait &gt;= <span class="hljs-number">0</span> &amp;&amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) &#123;<br>        init_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback);<br>        pwq-&gt;whead = whead;<br>        pwq-&gt;base = epi;<br>        add_wait_queue(whead, &amp;pwq-&gt;wait);<br>        list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);<br>        epi-&gt;nwait++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        epi-&gt;nwait = <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>ep_ptable_queue_proc()</code> 函数主要工作是把当前 <code>epitem</code> 对象添加到 socket 对象的等待队列中，并且设置唤醒函数为 <code>ep_poll_callback()</code>，也就是说，当socket状态发生变化时，会触发调用 <code>ep_poll_callback()</code> 函数。<code>ep_poll_callback()</code> 函数实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ep_poll_callback</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *wait, <span class="hljs-keyword">unsigned</span> mode, <span class="hljs-keyword">int</span> sync, <span class="hljs-keyword">void</span> *key)</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br>    <span class="hljs-comment">// 把就绪的文件添加到就绪队列中</span><br>    list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);<br><br>is_linked:<br>    <span class="hljs-comment">// 唤醒调用 epoll_wait() 而被阻塞的进程</span><br>    <span class="hljs-keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))<br>        wake_up_locked(&amp;ep-&gt;wq);<br>    ...<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>ep_poll_callback()</code> 函数的主要工作是把就绪的文件添加到 <code>eventepoll</code> 对象的就绪队列中，然后唤醒调用 <code>epoll_wait()</code> 被阻塞的进程。</p><h3 id="等待被监听的文件状态发生改变"><a href="#等待被监听的文件状态发生改变" class="headerlink" title="等待被监听的文件状态发生改变"></a>等待被监听的文件状态发生改变</h3><p>把被监听的文件句柄添加到epoll后，就可以通过调用 <code>epoll_wait()</code> 等待被监听的文件状态发生改变。<code>epoll_wait()</code> 调用会阻塞当前进程，当被监听的文件状态发生改变时，<code>epoll_wait()</code> 调用便会返回。</p><p><code>epoll_wait()</code> 系统调用的原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">epoll_wait</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epfd, struct epoll_event *events, <span class="hljs-keyword">int</span> maxevents, <span class="hljs-keyword">int</span> timeout)</span></span>;<br></code></pre></div></td></tr></table></figure><p>各个参数的意义：</p><ol><li><code>epfd</code>: 调用 <code>epoll_create()</code> 函数创建的epoll句柄。</li><li><code>events</code>: 用来存放就绪文件列表。</li><li><code>maxevents</code>: <code>events</code> 数组的大小。</li><li><code>timeout</code>: 设置等待的超时时间。</li></ol><p><code>epoll_wait()</code> 函数会调用 <code>sys_epoll_wait()</code> 内核函数，而 <code>sys_epoll_wait()</code> 函数最终会调用 <code>ep_poll()</code> 函数，我们来看看 <code>ep_poll()</code> 函数的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ep_poll</span><span class="hljs-params">(struct eventpoll *ep, </span></span><br><span class="hljs-function"><span class="hljs-params">    struct epoll_event __user *events, <span class="hljs-keyword">int</span> maxevents, <span class="hljs-keyword">long</span> timeout)</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br>    <span class="hljs-comment">// 如果就绪文件列表为空</span><br>    <span class="hljs-keyword">if</span> (list_empty(&amp;ep-&gt;rdllist)) &#123;<br>        <span class="hljs-comment">// 把当前进程添加到epoll的等待队列中</span><br>        init_waitqueue_entry(&amp;wait, current);<br>        wait.flags |= WQ_FLAG_EXCLUSIVE;<br>        __add_wait_queue(&amp;ep-&gt;wq, &amp;wait);<br><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            set_current_state(TASK_INTERRUPTIBLE); <span class="hljs-comment">// 把当前进程设置为睡眠状态</span><br>            <span class="hljs-keyword">if</span> (!list_empty(&amp;ep-&gt;rdllist) || !jtimeout) <span class="hljs-comment">// 如果有就绪文件或者超时, 退出循环</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (signal_pending(current)) &#123; <span class="hljs-comment">// 接收到信号也要退出</span><br>                res = -EINTR;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);<br>            jtimeout = schedule_timeout(jtimeout); <span class="hljs-comment">// 让出CPU, 切换到其他进程进行执行</span><br>            spin_lock_irqsave(&amp;ep-&gt;lock, flags);<br>        &#125;<br>        <span class="hljs-comment">// 有3种情况会执行到这里:</span><br>        <span class="hljs-comment">// 1. 被监听的文件集合中有就绪的文件</span><br>        <span class="hljs-comment">// 2. 设置了超时时间并且超时了</span><br>        <span class="hljs-comment">// 3. 接收到信号</span><br>        __remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);<br><br>        set_current_state(TASK_RUNNING);<br>    &#125;<br>    <span class="hljs-comment">/* 是否有就绪的文件? */</span><br>    eavail = !list_empty(&amp;ep-&gt;rdllist);<br><br>    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);<br><br>    <span class="hljs-keyword">if</span> (!res &amp;&amp; eavail <br>        &amp;&amp; !(res = ep_send_events(ep, events, maxevents)) &amp;&amp; jtimeout)<br>        <span class="hljs-keyword">goto</span> retry;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>ep_poll()</code> 函数主要做以下几件事：</p><ol><li>判断被监听的文件集合中是否有就绪的文件，如果有就返回。</li><li>如果没有就把当前进程添加到epoll的等待队列中，并且进入睡眠。</li><li>进程会一直睡眠直到有以下几种情况发生：<ol><li>被监听的文件集合中有就绪的文件</li><li>设置了超时时间并且超时了</li><li>接收到信号</li></ol></li><li>如果有就绪的文件，那么就调用 <code>ep_send_events()</code> 函数把就绪文件复制到 <code>events</code> 参数中。</li><li>返回就绪文件的个数。</li></ol><p>最后，我们通过一张图来总结epoll的原理：</p><p><img src="/img/newimg/008eGmZEly1gpc5cdhrr0j310f0u0djf.jpg" srcset="/img/loading.gif" alt=""></p><p>下面通过文字来描述一下这个过程：</p><ol><li>通过调用 <code>epoll_create()</code> 函数创建并初始化一个 <code>eventpoll</code> 对象。</li><li>通过调用 <code>epoll_ctl()</code> 函数把被监听的文件句柄 (如socket句柄) 封装成 <code>epitem</code> 对象并且添加到 <code>eventpoll</code> 对象的红黑树中进行管理。</li><li>通过调用 <code>epoll_wait()</code> 函数等待被监听的文件状态发生改变。</li><li>当被监听的文件状态发生改变时（如socket接收到数据），会把文件句柄对应 <code>epitem</code> 对象添加到 <code>eventpoll</code> 对象的就绪队列 <code>rdllist</code> 中。并且把就绪队列的文件列表复制到 <code>epoll_wait()</code> 函数的 <code>events</code> 参数中。</li><li>唤醒调用 <code>epoll_wait()</code> 函数被阻塞（睡眠）的进程。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux进程详解</title>
    <link href="/2021/04/08/Linux%E8%BF%9B%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/04/08/Linux%E8%BF%9B%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>程序是指储存在外部存储(如硬盘)的一个可执行文件, 而进程是指处于执行期间的程序, 进程包括 <code>代码段(text section)</code> 和 <code>数据段(data section)</code>, 除了代码段和数据段外, 进程一般还包含打开的文件, 要处理的信号和CPU上下文等等. </p><h3 id="进程描述符"><a href="#进程描述符" class="headerlink" title="进程描述符"></a>进程描述符</h3><p>Linux进程使用 <code>struct task_struct</code> 来描述(include/linux/sched.h), 如下:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * offsets of these are hardcoded elsewhere - touch with care</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> state;<span class="hljs-comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> flags;<span class="hljs-comment">/* per process flags, defined below */</span><br><span class="hljs-keyword">int</span> sigpending;<br><span class="hljs-keyword">mm_segment_t</span> addr_limit;<span class="hljs-comment">/* thread address space:</span><br><span class="hljs-comment"> 0-0xBFFFFFFF for user-thead</span><br><span class="hljs-comment">0-0xFFFFFFFF for kernel-thread</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">exec_domain</span> *<span class="hljs-title">exec_domain</span>;</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> need_resched;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> ptrace;<br><br><span class="hljs-keyword">int</span> lock_depth;<span class="hljs-comment">/* Lock depth */</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * offset 32 begins here on 32-bit platforms. We keep</span><br><span class="hljs-comment"> * all fields in a single cacheline that are needed for</span><br><span class="hljs-comment"> * the goodness() loop in schedule().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">long</span> counter;<br><span class="hljs-keyword">long</span> nice;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> policy;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span>;</span><br><span class="hljs-keyword">int</span> processor;<br>...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Linux把所有的进程使用双向链表连接起来, 如下图(来源&lt;Linux设计与实现&gt;):<br><img src="/img/newimg/008eGmZEgy1gpc4ubn2ttj30co08yq3t.jpg" srcset="/img/loading.gif" alt=""></p><p>Linux内核为了加快获取当前进程的的task_struct结构, 使用了一个技巧, 就是把task_struct放置在内核栈的栈底, 这样就可以通过 <code>esp寄存器</code> 快速获取到当前运行进程的task_struct结构. 如下图:<br><img src="/img/newimg/008eGmZEgy1gpc4ugzldpj30hj0b3mx8.jpg" srcset="/img/loading.gif" alt=""></p><p>获取当前运行进程的task_struct代码如下:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> struct task_struct * <span class="hljs-title">get_current</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">current</span>;</span><br>__asm__(<span class="hljs-string">"andl %%esp,%0; "</span>:<span class="hljs-string">"=r"</span> (current) : <span class="hljs-string">"0"</span> (~<span class="hljs-number">8191U</span>L));<br><span class="hljs-keyword">return</span> current;<br> &#125;<br></code></pre></div></td></tr></table></figure><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>进程描述符的state字段用于保存进程的当前状态, 进程的状态有以下几种:</p><ul><li><code>TASK_RUNNING (运行)</code> – 进程处于可执行状态, 在这个状态下的进程要么正在被CPU执行, 要么在等待执行(CPU被其他进程占用的情况下).</li><li><code>TASK_INTERRUPTIBLE (可中断等待)</code> – 进程处于等待状态, 其在等待某些条件成立或者接收到某些信号, 进程会被唤醒变为运行状态.</li><li><code>TASK_UNINTERRUPTIBLE (不可中断等待)</code> – 进程处于等待状态, 其在等待某些条件成立, 进程会被唤醒变为运行状态, 但不能被信号唤醒.</li><li><code>TASK_TRACED (被追踪)</code> – 进程处于被追踪状态, 例如通过ptrace命令对进程进行调试.</li><li><code>TASK_STOPPED (停止)</code> – 进程处于停止状态, 进程不能被执行. 一般接收到SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU信号进程会变成TASK_STOPPED状态.</li></ul><p>各种状态间的转换如下图:</p><p><img src="/img/newimg/008eGmZEgy1gpc4umsilej30i60d3t9s.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>在Linux系统中，进程的创建使用fork()系统调用，fork()调用会创建一个与父进程一样的子进程，唯一不同就是fork()的返回值，父进程返回的是子进程的进程ID，而子进程返回的是0。</p><p>Linux创建子进程时使用了<code>写时复制（Copy On Write）</code>，也就是创建子进程时使用的是父进程的内存空间，当子进程或者父进程修改数据时才会复制相应的内存页。</p><p>当调用fork()系统调用时会陷入内核空间并且调用sys_fork()函数，sys_fork()函数会调用do_fork()函数，代码如下(arch/i386/kernel/process.c)：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function">asmlinkage <span class="hljs-keyword">int</span> <span class="hljs-title">sys_fork</span><span class="hljs-params">(struct pt_regs regs)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> do_fork(SIGCHLD, regs.esp, &amp;regs, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>do_fork()主要的工作是申请一个进程描述符, 然后初始化进程描述符的各个字段,  包括调用 copy_files() 函数复制打开的文件,  调用 copy_sighand() 函数复制信号处理函数, 调用 copy_mm() 函数复制进程虚拟内存空间, 调用 copy_namespace() 函数复制命名空间. 代码如下:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">do_fork</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> clone_flags, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> stack_start,</span></span><br><span class="hljs-function"><span class="hljs-params">    struct pt_regs *regs, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> stack_size)</span></span><br><span class="hljs-function"></span>&#123;<br>...<br>p = alloc_task_struct(); <span class="hljs-comment">// 申请进程描述符</span><br>...<br><span class="hljs-keyword">if</span> (copy_files(clone_flags, p))<br><span class="hljs-keyword">goto</span> bad_fork_cleanup;<br><span class="hljs-keyword">if</span> (copy_fs(clone_flags, p))<br><span class="hljs-keyword">goto</span> bad_fork_cleanup_files;<br><span class="hljs-keyword">if</span> (copy_sighand(clone_flags, p))<br><span class="hljs-keyword">goto</span> bad_fork_cleanup_fs;<br><span class="hljs-keyword">if</span> (copy_mm(clone_flags, p))<br><span class="hljs-keyword">goto</span> bad_fork_cleanup_sighand;<br><span class="hljs-keyword">if</span> (copy_namespace(clone_flags, p))<br><span class="hljs-keyword">goto</span> bad_fork_cleanup_mm;<br>retval = copy_thread(<span class="hljs-number">0</span>, clone_flags, stack_start, stack_size, p, regs);<br>...<br>wake_up_process(p);<br>...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>值得注意的是do_fork() 还调用了 copy_thread() 这个函数, copy_thread()这个函数主要用于设置进程的CPU执行上下文 <code>struct thread_struct</code> 结构.  代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">copy_thread</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nr, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> clone_flags, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> esp,</span></span><br><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> unused,</span></span><br><span class="hljs-function"><span class="hljs-params">struct task_struct * p, struct pt_regs * regs)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pt_regs</span> * <span class="hljs-title">childregs</span>;</span><br><br><span class="hljs-comment">// 指向栈顶(见图2)</span><br>childregs = ((struct pt_regs *) (THREAD_SIZE + (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) p)) - <span class="hljs-number">1</span>;<br>struct_cpy(childregs, regs);  <span class="hljs-comment">// 复制父进程的栈信息</span><br>childregs-&gt;eax = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 这个是子进程调用fork()之后的返回值, 也就是0</span><br>childregs-&gt;esp = esp; <span class="hljs-comment">// 设置新的栈空间</span><br><br>p-&gt;thread.esp = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) childregs;      <span class="hljs-comment">// 子进程当前的栈地址, 调用switch_to()的时候esp设置为这个地址</span><br>p-&gt;thread.esp0 = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (childregs+<span class="hljs-number">1</span>); <span class="hljs-comment">// 子进程内核空间栈地址</span><br><br>p-&gt;thread.eip = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) ret_from_fork;  <span class="hljs-comment">// 子进程将要执行的代码地址</span><br><br>savesegment(fs,p-&gt;thread.fs);<br>savesegment(gs,p-&gt;thread.gs);<br><br>unlazy_fpu(current);<br>struct_cpy(&amp;p-&gt;thread.i387, &amp;current-&gt;thread.i387);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>do_fork() 函数最后调用 wake_up_process() 函数唤醒子进程, 让子进程进入运行状态.</p><h3 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h3><p>Linux内核有很多任务需要去做, 例如定时把缓冲中的数据刷到硬盘, 当内存不足的时候进行内存的回收等, 这些工作都需要通过内核线程来完成. 内核线程与普通进程的主要区别就是: 内核线程没有自己的 <code>虚拟空间结构(struct mm)</code>, 每次内核线程执行的时候都是借助当前运行进程的虚拟内存空间结构来运行, 因为内核线程只会运行在内核态, 而每个进程的内核态空间都是一样的, 所以借助其他进程的虚拟内存空间结构来运行是完成可行的.</p><p>内核线程使用 <code>kernel_thread()</code> 函数来创建, 代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kernel_thread</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*fn)(<span class="hljs-keyword">void</span> *), <span class="hljs-keyword">void</span> * arg, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> flags)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">long</span> retval, d0;<br><br>__asm__ __volatile__(<br><span class="hljs-string">"movl %%esp,%%esi\n\t"</span><br><span class="hljs-string">"int $0x80\n\t"</span><span class="hljs-comment">/* Linux/i386 system call */</span><br><span class="hljs-string">"cmpl %%esp,%%esi\n\t"</span><span class="hljs-comment">/* child or parent? */</span><br><span class="hljs-string">"je 1f\n\t"</span><span class="hljs-comment">/* parent - jump */</span><br><span class="hljs-comment">/* Load the argument into eax, and push it.  That way, it does</span><br><span class="hljs-comment"> * not matter whether the called function is compiled with</span><br><span class="hljs-comment"> * -mregparm or not.  */</span><br><span class="hljs-string">"movl %4,%%eax\n\t"</span><br><span class="hljs-string">"pushl %%eax\n\t"</span><br><span class="hljs-string">"call *%5\n\t"</span><span class="hljs-comment">/* call fn */</span><br><span class="hljs-string">"movl %3,%0\n\t"</span><span class="hljs-comment">/* exit */</span><br><span class="hljs-string">"int $0x80\n"</span><br><span class="hljs-string">"1:\t"</span><br>:<span class="hljs-string">"=&amp;a"</span> (retval), <span class="hljs-string">"=&amp;S"</span> (d0)<br>:<span class="hljs-string">"0"</span> (__NR_clone), <span class="hljs-string">"i"</span> (__NR_exit),<br> <span class="hljs-string">"r"</span> (arg), <span class="hljs-string">"r"</span> (fn),<br> <span class="hljs-string">"b"</span> (flags | CLONE_VM)<br>: <span class="hljs-string">"memory"</span>);<br><span class="hljs-keyword">return</span> retval;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>因为这个函数式使用嵌入汇编来实现的, 所以有点难懂, 不过主要过程就是通过调用 <code>_clone()</code>函数来创建一个新的进程, 而创建进程是通过传入 <code>CLONE_VM</code> 标志来指定进程借用其他进程的虚拟内存空间结构.</p><div class="hljs code-wrapper"><pre><code>特别说明一下：`d0` 局部变量的作用是为了在创建内核线程时保证 `struct pt_regs` 结构的完整，这是因为创建内核线程是在内核态进行的，所以在内核态调用系统调用是不会压入 `ss` 和 `esp` 寄存器的，这样就会导致系统调用的 `struct pt_regs` 参数信息不完整，所以 `kernel_thread()` 函数定义了一个 `d0` 局部变量是为了补充没压栈的 `ss` 和 `esp` 的。</code></pre></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux等待队列原理与实现</title>
    <link href="/2021/04/07/Linux%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/04/07/Linux%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="等待队列原理与实现"><a href="#等待队列原理与实现" class="headerlink" title="等待队列原理与实现"></a>等待队列原理与实现</h2><p>当进程要获取某些资源（例如从网卡读取数据）的时候，但资源并没有准备好（例如网卡还没接收到数据），这时候内核必须切换到其他进程运行，直到资源准备好再唤醒进程。</p><p><code>waitqueue (等待队列)</code> 就是内核用于管理等待资源的进程，当某个进程获取的资源没有准备好的时候，可以通过调用 <code>add_wait_queue()</code> 函数把进程添加到 <code>waitqueue</code> 中，然后切换到其他进程继续执行。当资源准备好，由资源提供方通过调用 <code>wake_up()</code> 函数来唤醒等待的进程。</p><h3 id="等待队列初始化"><a href="#等待队列初始化" class="headerlink" title="等待队列初始化"></a>等待队列初始化</h3><p>要使用 <code>waitqueue</code> 首先需要声明一个 <code>wait_queue_head_t</code> 结构的变量，<code>wait_queue_head_t</code> 结构定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">wait_queue_head</span> &#123;</span><br>    <span class="hljs-keyword">spinlock_t</span> lock;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">task_list</span>;</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p><code>waitqueue</code> 本质上是一个链表，而 <code>wait_queue_head_t</code> 结构是 <code>waitqueue</code> 的头部，<code>lock</code> 字段用于保护等待队列在多核环境下数据被破坏，而 <code>task_list</code> 字段用于保存等待资源的进程列表。</p><p>可以通过调用 <code>init_waitqueue_head()</code> 函数来初始化 <code>wait_queue_head_t</code> 结构，其实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init_waitqueue_head</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_head_t</span> *q)</span></span><br><span class="hljs-function"></span>&#123;<br>    spin_lock_init(&amp;q-&gt;lock);<br>    INIT_LIST_HEAD(&amp;q-&gt;task_list);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>初始化过程很简单，首先调用 <code>spin_lock_init()</code> 来初始化自旋锁 <code>lock</code>，然后调用 <code>INIT_LIST_HEAD()</code> 来初始化进程链表。</p><h3 id="向等待队列添加等待进程"><a href="#向等待队列添加等待进程" class="headerlink" title="向等待队列添加等待进程"></a>向等待队列添加等待进程</h3><p>要向 <code>waitqueue</code> 添加等待进程，首先要声明一个 <code>wait_queue_t</code> 结构的变量，<code>wait_queue_t</code> 结构定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*<span class="hljs-keyword">wait_queue_func_t</span>)</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *wait, <span class="hljs-keyword">unsigned</span> mode, <span class="hljs-keyword">int</span> sync, <span class="hljs-keyword">void</span> *key)</span></span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">wait_queue</span> &#123;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags;<br>    <span class="hljs-keyword">void</span> *<span class="hljs-keyword">private</span>;<br>    <span class="hljs-keyword">wait_queue_func_t</span> func;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">task_list</span>;</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>下面说明一下各个成员的作用：</p><ol><li><code>flags</code>: 可以设置为 <code>WQ_FLAG_EXCLUSIVE</code>，表示等待的进程应该独占资源（解决惊群现象）。</li><li><code>private</code>: 一般用于保存等待进程的进程描述符 <code>task_struct</code>。</li><li><code>func</code>: 唤醒函数，一般设置为 <code>default_wake_function()</code> 函数，当然也可以设置为自定义的唤醒函数。</li><li><code>task_list</code>: 用于连接其他等待资源的进程。</li></ol><p>可以通过调用 <code>init_waitqueue_entry()</code> 函数来初始化 <code>wait_queue_t</code> 结构变量，其实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init_waitqueue_entry</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *q, struct task_struct *p)</span></span><br><span class="hljs-function"></span>&#123;<br>    q-&gt;flags = <span class="hljs-number">0</span>;<br>    q-&gt;<span class="hljs-keyword">private</span> = p;<br>    q-&gt;func = default_wake_function;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>也可以通过调用 <code>init_waitqueue_func_entry()</code> 函数来初始化为自定义的唤醒函数：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init_waitqueue_func_entry</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *q, <span class="hljs-keyword">wait_queue_func_t</span> func)</span></span><br><span class="hljs-function"></span>&#123;<br>    q-&gt;flags = <span class="hljs-number">0</span>;<br>    q-&gt;<span class="hljs-keyword">private</span> = <span class="hljs-literal">NULL</span>;<br>    q-&gt;func = func;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>初始化完 <code>wait_queue_t</code> 结构变量后，可以通过调用 <code>add_wait_queue()</code> 函数把等待进程添加到等待队列，其实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_wait_queue</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_head_t</span> *q, <span class="hljs-keyword">wait_queue_t</span> *wait)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> flags;<br><br>    wait-&gt;flags &amp;= ~WQ_FLAG_EXCLUSIVE;<br>    spin_lock_irqsave(&amp;q-&gt;lock, flags);<br>    __add_wait_queue(q, wait);<br>    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> __add_wait_queue(<span class="hljs-keyword">wait_queue_head_t</span> *head, <span class="hljs-keyword">wait_queue_t</span> *<span class="hljs-keyword">new</span>)<br>&#123;<br>    list_add(&amp;<span class="hljs-keyword">new</span>-&gt;task_list, &amp;head-&gt;task_list);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>add_wait_queue()</code> 函数的实现很简单，首先通过调用 <code>spin_lock_irqsave()</code> 上锁，然后调用 <code>list_add()</code> 函数把节点添加到等待队列即可。</p><p><code>wait_queue_head_t</code> 结构与 <code>wait_queue_t</code> 结构之间的关系如下图：</p><p><img src="/img/newimg/008eGmZEgy1gpb9smr9n3j30x60hgta5.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="休眠等待进程"><a href="#休眠等待进程" class="headerlink" title="休眠等待进程"></a>休眠等待进程</h3><p>当把进程添加到等待队列后，就可以休眠当前进程，让出CPU给其他进程运行，要休眠进程可以通过一下方式：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">set_current_state(TASK_INTERRUPTIBLE);<br>schedule();<br></code></pre></div></td></tr></table></figure><p>代码 <code>set_current_state(TASK_INTERRUPTIBLE)</code> 可以把当前进程运行状态设置为 <code>可中断休眠</code> 状态，调用 <code>schedule()</code> 函数可以使当前进程让出CPU，切换到其他进程执行。</p><h3 id="唤醒等待队列"><a href="#唤醒等待队列" class="headerlink" title="唤醒等待队列"></a>唤醒等待队列</h3><p>当资源准备好后，就可以唤醒等待队列中的进程，可以通过 <code>wake_up()</code> 函数来唤醒等待队列中的进程。<code>wake_up()</code> 最终会调用 <code>__wake_up_common()</code>，其实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __wake_up_common(<span class="hljs-keyword">wait_queue_head_t</span> *q, <br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mode, <span class="hljs-keyword">int</span> nr_exclusive, <span class="hljs-keyword">int</span> sync, <span class="hljs-keyword">void</span> *key)<br>&#123;<br>    <span class="hljs-keyword">wait_queue_t</span> *curr, *next;<br><br>    list_for_each_entry_safe(curr, next, &amp;q-&gt;task_list, task_list) &#123;<br>        <span class="hljs-keyword">unsigned</span> flags = curr-&gt;flags;<br><br>        <span class="hljs-keyword">if</span> (curr-&gt;func(curr, mode, sync, key) &amp;&amp;<br>                (flags &amp; WQ_FLAG_EXCLUSIVE) &amp;&amp; !--nr_exclusive)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看出，唤醒等待队列就是变量等待队列的等待进程，然后调用唤醒函数来唤醒它们。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux中断处理</title>
    <link href="/2021/04/07/Linux%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/"/>
    <url>/2021/04/07/Linux%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="中断处理-上半部（硬中断）"><a href="#中断处理-上半部（硬中断）" class="headerlink" title="中断处理 - 上半部（硬中断）"></a>中断处理 - 上半部（硬中断）</h2><p>由于 <code>APIC中断控制器</code> 有点小复杂，所以本文主要通过 <code>8259A中断控制器</code> 来介绍Linux对中断的处理过程。</p><h3 id="中断处理相关结构"><a href="#中断处理相关结构" class="headerlink" title="中断处理相关结构"></a>中断处理相关结构</h3><p>前面说过，<code>8259A中断控制器</code> 由两片 8259A 风格的外部芯片以 <code>级联</code> 的方式连接在一起，每个芯片可处理多达 8 个不同的 IRQ（中断请求），所以可用 IRQ 线的个数达到 15 个。如下图：</p><p><img src="/img/newimg/008eGmZEgy1gpb9pea1n8j30hj0emdix.jpg" srcset="/img/loading.gif" alt=""></p><p>在内核中每条IRQ线由结构体 <code>irq_desc_t</code> 来描述，<code>irq_desc_t</code> 定义如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> status;        <span class="hljs-comment">/* IRQ status */</span><br>    hw_irq_controller *handler;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irqaction</span> *<span class="hljs-title">action</span>;</span>   <span class="hljs-comment">/* IRQ action list */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> depth;         <span class="hljs-comment">/* nested irq disables */</span><br>    <span class="hljs-keyword">spinlock_t</span> lock;<br>&#125; <span class="hljs-keyword">irq_desc_t</span>;<br></code></pre></div></td></tr></table></figure><p>下面介绍一下 <code>irq_desc_t</code> 结构各个字段的作用：</p><ul><li><code>status</code>: IRQ线的状态。</li><li><code>handler</code>: 类型为 <code>hw_interrupt_type</code> 结构，表示IRQ线对应的硬件相关处理函数，比如 <code>8259A中断控制器</code> 接收到一个中断信号时，需要发送一个确认信号才会继续接收中断信号的，发送确认信号的函数就是 <code>hw_interrupt_type</code> 中的 <code>ack</code> 函数。</li><li><code>action</code>: 类型为 <code>irqaction</code> 结构，中断信号的处理入口。由于一条IRQ线可以被多个硬件共享，所以 <code>action</code> 是一个链表，每个 <code>action</code> 代表一个硬件的中断处理入口。</li><li><code>depth</code>: 防止多次开启和关闭IRQ线。</li><li><code>lock</code>: 防止多核CPU同时对IRQ进行操作的自旋锁。</li></ul><p><code>hw_interrupt_type</code> 这个结构与硬件相关，这里就不作介绍了，我们来看看 <code>irqaction</code> 这个结构：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irqaction</span> &#123;</span><br>    <span class="hljs-keyword">void</span> (*handler)(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">void</span> *, struct pt_regs *);<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> flags;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> mask;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;<br>    <span class="hljs-keyword">void</span> *dev_id;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irqaction</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>下面说说 <code>irqaction</code> 结构各个字段的作用：</p><ul><li><code>handler</code>: 中断处理的入口函数，<code>handler</code> 的第一个参数是中断号，第二个参数是设备对应的ID，第三个参数是中断发生时由内核保存的各个寄存器的值。</li><li><code>flags</code>: 标志位，用于表示 <code>irqaction</code> 的一些行为，例如是否能够与其他硬件共享IRQ线。</li><li><code>name</code>: 用于保存中断处理的名字。</li><li><code>dev_id</code>: 设备ID。</li><li><code>next</code>: 每个硬件的中断处理入口对应一个 <code>irqaction</code> 结构，由于多个硬件可以共享同一条IRQ线，所以这里通过 <code>next</code> 字段来连接不同的硬件中断处理入口。</li></ul><p><code>irq_desc_t</code> 结构关系如下图：</p><p><img src="/img/newimg/008eGmZEgy1gpb9pnnj3uj30zo0ebgm5.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="注册中断处理入口"><a href="#注册中断处理入口" class="headerlink" title="注册中断处理入口"></a>注册中断处理入口</h3><p>在内核中，可以通过 <code>setup_irq()</code> 函数来注册一个中断处理入口。<code>setup_irq()</code> 函数代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setup_irq</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> irq, struct irqaction * <span class="hljs-keyword">new</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> shared = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> flags;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irqaction</span> *<span class="hljs-title">old</span>, **<span class="hljs-title">p</span>;</span><br>    <span class="hljs-keyword">irq_desc_t</span> *desc = irq_desc + irq;<br>    ...<br>    spin_lock_irqsave(&amp;desc-&gt;lock,flags);<br>    p = &amp;desc-&gt;action;<br>    <span class="hljs-keyword">if</span> ((old = *p) != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!(old-&gt;flags &amp; <span class="hljs-keyword">new</span>-&gt;flags &amp; SA_SHIRQ)) &#123;<br>            spin_unlock_irqrestore(&amp;desc-&gt;lock,flags);<br>            <span class="hljs-keyword">return</span> -EBUSY;<br>        &#125;<br><br>        <span class="hljs-keyword">do</span> &#123;<br>            p = &amp;old-&gt;next;<br>            old = *p;<br>        &#125; <span class="hljs-keyword">while</span> (old);<br>        shared = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    *p = <span class="hljs-keyword">new</span>;<br><br>    <span class="hljs-keyword">if</span> (!shared) &#123;<br>        desc-&gt;depth = <span class="hljs-number">0</span>;<br>        desc-&gt;status &amp;= ~(IRQ_DISABLED | IRQ_AUTODETECT | IRQ_WAITING);<br>        desc-&gt;handler-&gt;startup(irq);<br>    &#125;<br>    spin_unlock_irqrestore(&amp;desc-&gt;lock,flags);<br><br>    register_irq_proc(irq); <span class="hljs-comment">// 注册proc文件系统</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>setup_irq()</code> 函数比较简单，就是通过 <code>irq</code> 号来查找对应的 <code>irq_desc_t</code> 结构，并把新的 <code>irqaction</code> 连接到 <code>irq_desc_t</code> 结构的 <code>action</code> 链表中。要注意的是，如果设备不支持共享IRQ线（也即是 <code>flags</code> 字段没有设置 <code>SA_SHIRQ</code> 标志），那么就返回 <code>EBUSY</code> 错误。</p><p>我们看看 <code>时钟中断处理入口</code> 的注册实例：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irqaction</span> <span class="hljs-title">irq0</span>  = &#123;</span> timer_interrupt, SA_INTERRUPT, <span class="hljs-number">0</span>, <span class="hljs-string">"timer"</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>&#125;;<br><br><span class="hljs-keyword">void</span> __<span class="hljs-function">init <span class="hljs-title">time_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br>    setup_irq(<span class="hljs-number">0</span>, &amp;irq0);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，时钟中断处理入口的IRQ号为0，处理函数为 <code>timer_interrupt()</code>，并且不支持共享IRQ线（<code>flags</code> 字段没有设置 <code>SA_SHIRQ</code> 标志）。</p><h3 id="处理中断请求"><a href="#处理中断请求" class="headerlink" title="处理中断请求"></a>处理中断请求</h3><p>当一个中断发生时，中断控制层会发送信号给CPU，CPU收到信号会中断当前的执行，转而执行中断处理过程。中断处理过程首先会保存寄存器的值到栈中，然后调用 <code>do_IRQ()</code> 函数进行进一步的处理，<code>do_IRQ()</code> 函数代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function">asmlinkage <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">do_IRQ</span><span class="hljs-params">(struct pt_regs regs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> irq = regs.orig_eax &amp; <span class="hljs-number">0xff</span>; <span class="hljs-comment">/* 获取IRQ号  */</span><br>    <span class="hljs-keyword">int</span> cpu = smp_processor_id();<br>    <span class="hljs-keyword">irq_desc_t</span> *desc = irq_desc + irq;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irqaction</span> * <span class="hljs-title">action</span>;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> status;<br><br>    kstat.irqs[cpu][irq]++;<br>    spin_lock(&amp;desc-&gt;lock);<br>    desc-&gt;handler-&gt;ack(irq);<br><br>    status = desc-&gt;status &amp; ~(IRQ_REPLAY | IRQ_WAITING);<br>    status |= IRQ_PENDING; <span class="hljs-comment">/* we _want_ to handle it */</span><br><br>    action = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (!(status &amp; (IRQ_DISABLED | IRQ_INPROGRESS))) &#123; <span class="hljs-comment">// 当前IRQ不在处理中</span><br>        action = desc-&gt;action;    <span class="hljs-comment">// 获取 action 链表</span><br>        status &amp;= ~IRQ_PENDING;   <span class="hljs-comment">// 去除IRQ_PENDING标志, 这个标志用于记录是否在处理IRQ请求的时候又发生了中断</span><br>        status |= IRQ_INPROGRESS; <span class="hljs-comment">// 设置IRQ_INPROGRESS标志, 表示正在处理IRQ</span><br>    &#125;<br>    desc-&gt;status = status;<br><br>    <span class="hljs-keyword">if</span> (!action)  <span class="hljs-comment">// 如果上一次IRQ还没完成, 直接退出</span><br>        <span class="hljs-keyword">goto</span> out;<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        spin_unlock(&amp;desc-&gt;lock);<br>        handle_IRQ_event(irq, &amp;regs, action); <span class="hljs-comment">// 处理IRQ请求</span><br>        spin_lock(&amp;desc-&gt;lock);<br>        <br>        <span class="hljs-keyword">if</span> (!(desc-&gt;status &amp; IRQ_PENDING)) <span class="hljs-comment">// 如果在处理IRQ请求的时候又发生了中断, 继续处理IRQ请求</span><br>            <span class="hljs-keyword">break</span>;<br>        desc-&gt;status &amp;= ~IRQ_PENDING;<br>    &#125;<br>    desc-&gt;status &amp;= ~IRQ_INPROGRESS;<br>out:<br><br>    desc-&gt;handler-&gt;<span class="hljs-built_in">end</span>(irq);<br>    spin_unlock(&amp;desc-&gt;lock);<br><br>    <span class="hljs-keyword">if</span> (softirq_active(cpu) &amp; softirq_mask(cpu))<br>        do_softirq(); <span class="hljs-comment">// 中断下半部处理</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>do_IRQ()</code> 函数首先通过IRQ号获取到其对应的 <code>irq_desc_t</code> 结构，注意的是同一个中断有可能发生多次，所以要判断当前IRQ是否正在被处理当中（判断 <code>irq_desc_t</code> 结构的 <code>status</code> 字段是否设置了 <code>IRQ_INPROGRESS</code> 标志），如果不是处理当前，那么就获取到 <code>action</code> 链表，然后通过调用 <code>handle_IRQ_event()</code> 函数来执行 action 链表中的中断处理函数。</p><p>如果在处理中断的过程中又发生了相同的中断（<code>irq_desc_t</code> 结构的 <code>status</code> 字段被设置了 <code>IRQ_INPROGRESS</code> 标志），那么就继续对中断进行处理。处理完中断后，调用 <code>do_softirq()</code> 函数来对中断下半部进行处理（下面会说）。</p><p>接下来看看 <code>handle_IRQ_event()</code> 函数的实现：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">handle_IRQ_event</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> irq, struct pt_regs * regs, struct irqaction * action)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> status;<br>    <span class="hljs-keyword">int</span> cpu = smp_processor_id();<br><br>    irq_enter(cpu, irq);<br><br>    status = <span class="hljs-number">1</span>; <span class="hljs-comment">/* Force the "do bottom halves" bit */</span><br><br>    <span class="hljs-keyword">if</span> (!(action-&gt;flags &amp; SA_INTERRUPT)) <span class="hljs-comment">// 如果中断处理能够在打开中断的情况下执行, 那么就打开中断</span><br>        __sti();<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        status |= action-&gt;flags;<br>        action-&gt;handler(irq, action-&gt;dev_id, regs);<br>        action = action-&gt;next;<br>    &#125; <span class="hljs-keyword">while</span> (action);<br>    <span class="hljs-keyword">if</span> (status &amp; SA_SAMPLE_RANDOM)<br>        add_interrupt_randomness(irq);<br>    __cli();<br><br>    irq_exit(cpu, irq);<br><br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>handle_IRQ_event()</code> 函数非常简单，就是遍历 action 链表并且执行其中的处理函数，比如对于 <code>时钟中断</code> 就是调用 <code>timer_interrupt()</code> 函数。这里要注意的是，如果中断处理过程能够开启中断的，那么就把中断打开（因为CPU接收到中断信号时会关闭中断）。</p><h2 id="中断处理-下半部（软中断）"><a href="#中断处理-下半部（软中断）" class="headerlink" title="中断处理 - 下半部（软中断）"></a>中断处理 - 下半部（软中断）</h2><p>由于中断处理一般在关闭中断的情况下执行，所以中断处理不能太耗时，否则后续发生的中断就不能实时地被处理。鉴于这个原因，Linux把中断处理分为两个部分，<code>上半部</code> 和 <code>下半部</code>，<code>上半部</code> 在前面已经介绍过，接下来就介绍一下 <code>下半部</code> 的执行。</p><p>一般中断 <code>上半部</code> 只会做一些最基础的操作（比如从网卡中复制数据到缓存中），然后对要执行的中断 <code>下半部</code> 进行标识，标识完调用 <code>do_softirq()</code> 函数进行处理。 </p><h3 id="softirq机制"><a href="#softirq机制" class="headerlink" title="softirq机制"></a>softirq机制</h3><p><code>中断下半部</code> 由 <code>softirq（软中断）</code> 机制来实现的，在Linux内核中，有一个名为 <code>softirq_vec</code> 的数组，如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">softirq_action</span> <span class="hljs-title">softirq_vec</span>[32];</span><br></code></pre></div></td></tr></table></figure><p>其类型为 <code>softirq_action</code> 结构，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">softirq_action</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">void</span>    (*action)(struct softirq_action *);<br>    <span class="hljs-keyword">void</span>    *data;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><code>softirq_vec</code> 数组是 <code>softirq</code> 机制的核心，<code>softirq_vec</code> 数组每个元素代表一种软中断。但在Linux中只定义了四种软中断，如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">enum</span><br>&#123;<br>    HI_SOFTIRQ=<span class="hljs-number">0</span>,<br>    NET_TX_SOFTIRQ,<br>    NET_RX_SOFTIRQ,<br>    TASKLET_SOFTIRQ<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><code>HI_SOFTIRQ</code> 是高优先级tasklet，而 <code>TASKLET_SOFTIRQ</code> 是普通tasklet，tasklet是基于softirq机制的一种任务队列（下面会介绍）。<code>NET_TX_SOFTIRQ</code> 和 <code>NET_RX_SOFTIRQ</code> 特定用于网络子模块的软中断（不作介绍）。</p><h3 id="注册softirq处理函数"><a href="#注册softirq处理函数" class="headerlink" title="注册softirq处理函数"></a>注册softirq处理函数</h3><p>要注册一个softirq处理函数，可以通过 <code>open_softirq()</code> 函数来进行，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">open_softirq</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nr, <span class="hljs-keyword">void</span> (*action)(struct softirq_action*), <span class="hljs-keyword">void</span> *data)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> flags;<br>    <span class="hljs-keyword">int</span> i;<br><br>    spin_lock_irqsave(&amp;softirq_mask_lock, flags);<br>    softirq_vec[nr].data = data;<br>    softirq_vec[nr].action = action;<br><br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;NR_CPUS; i++)<br>        softirq_mask(i) |= (<span class="hljs-number">1</span>&lt;&lt;nr);<br>    spin_unlock_irqrestore(&amp;softirq_mask_lock, flags);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>open_softirq()</code> 函数的主要工作就是向 <code>softirq_vec</code> 数组添加一个softirq处理函数。</p><p>Linux在系统初始化时注册了两种softirq处理函数，分别为 <code>TASKLET_SOFTIRQ</code> 和 <code>HI_SOFTIRQ</code>：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">void</span> __<span class="hljs-function">init <span class="hljs-title">softirq_init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br>    open_softirq(TASKLET_SOFTIRQ, tasklet_action, <span class="hljs-literal">NULL</span>);<br>    open_softirq(HI_SOFTIRQ, tasklet_hi_action, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="处理softirq"><a href="#处理softirq" class="headerlink" title="处理softirq"></a>处理softirq</h3><p>处理softirq是通过 <code>do_softirq()</code> 函数实现，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function">asmlinkage <span class="hljs-keyword">void</span> <span class="hljs-title">do_softirq</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> cpu = smp_processor_id();<br>    __u32 active, mask;<br><br>    <span class="hljs-keyword">if</span> (in_interrupt())<br>        <span class="hljs-keyword">return</span>;<br><br>    local_bh_disable();<br><br>    local_irq_disable();<br>    mask = softirq_mask(cpu);<br>    active = softirq_active(cpu) &amp; mask;<br><br>    <span class="hljs-keyword">if</span> (active) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">softirq_action</span> *<span class="hljs-title">h</span>;</span><br><br>restart:<br>        softirq_active(cpu) &amp;= ~active;<br><br>        local_irq_enable();<br><br>        h = softirq_vec;<br>        mask &amp;= ~active;<br><br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-keyword">if</span> (active &amp; <span class="hljs-number">1</span>)<br>                h-&gt;action(h);<br>            h++;<br>            active &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">while</span> (active);<br><br>        local_irq_disable();<br><br>        active = softirq_active(cpu);<br>        <span class="hljs-keyword">if</span> ((active &amp;= mask) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">goto</span> retry;<br>    &#125;<br><br>    local_bh_enable();<br><br>    <span class="hljs-keyword">return</span>;<br><br>retry:<br>    <span class="hljs-keyword">goto</span> restart;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>前面说了 <code>softirq_vec</code> 数组有32个元素，每个元素对应一种类型的softirq，那么Linux怎么知道哪种softirq需要被执行呢？在Linux中，每个CPU都有一个类型为 <code>irq_cpustat_t</code> 结构的变量，<code>irq_cpustat_t</code> 结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> __softirq_active;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> __softirq_mask;<br>    ...<br>&#125; <span class="hljs-keyword">irq_cpustat_t</span>;<br></code></pre></div></td></tr></table></figure><p>其中 <code>__softirq_active</code> 字段表示有哪种softirq触发了（int类型有32个位，每一个位代表一种softirq），而 <code>__softirq_mask</code> 字段表示哪种softirq被屏蔽了。Linux通过 <code>__softirq_active</code> 这个字段得知哪种softirq需要执行（只需要把对应位设置为1）。</p><p>所以，<code>do_softirq()</code> 函数首先通过 <code>softirq_mask(cpu)</code> 来获取当前CPU对应被屏蔽的softirq，而 <code>softirq_active(cpu) &amp; mask</code> 就是获取需要执行的softirq，然后就通过对比 <code>__softirq_active</code> 字段的各个位来判断是否要执行该类型的softirq。</p><h3 id="tasklet机制"><a href="#tasklet机制" class="headerlink" title="tasklet机制"></a>tasklet机制</h3><p>前面说了，tasklet机制是基于softirq机制的，tasklet机制其实就是一个任务队列，然后通过softirq执行。在Linux内核中有两种tasklet，一种是高优先级tasklet，一种是普通tasklet。这两种tasklet的实现基本一致，唯一不同的就是执行的优先级，高优先级tasklet会先于普通tasklet执行。</p><p>tasklet本质是一个队列，通过结构体 <code>tasklet_head</code> 存储，并且每个CPU有一个这样的队列，我们来看看结构体 <code>tasklet_head</code> 的定义：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tasklet_head</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tasklet_struct</span> *<span class="hljs-title">list</span>;</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tasklet_struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tasklet_struct</span> *<span class="hljs-title">next</span>;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> state;<br>    <span class="hljs-keyword">atomic_t</span> count;<br>    <span class="hljs-keyword">void</span> (*func)(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>);<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> data;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>从 <code>tasklet_head</code> 的定义可以知道，<code>tasklet_head</code> 结构是 <code>tasklet_struct</code> 结构队列的头部，而 <code>tasklet_struct</code> 结构的 <code>func</code> 字段正式任务要执行的函数指针。Linux定义了两种的tasklet队列，分别为 <code>tasklet_vec</code> 和 <code>tasklet_hi_vec</code>，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tasklet_head</span> <span class="hljs-title">tasklet_vec</span>[<span class="hljs-title">NR_CPUS</span>];</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tasklet_head</span> <span class="hljs-title">tasklet_hi_vec</span>[<span class="hljs-title">NR_CPUS</span>];</span><br></code></pre></div></td></tr></table></figure><p>可以看出，<code>tasklet_vec</code> 和 <code>tasklet_hi_vec</code> 都是数组，数组的元素个数为CPU的核心数，也就是每个CPU核心都有一个高优先级tasklet队列和一个普通tasklet队列。</p><h3 id="调度tasklet"><a href="#调度tasklet" class="headerlink" title="调度tasklet"></a>调度tasklet</h3><p>如果我们有一个tasklet需要执行，那么高优先级tasklet可以通过 <code>tasklet_hi_schedule()</code> 函数调度，而普通tasklet可以通过 <code>tasklet_schedule()</code> 调度。这两个函数基本一样，所以我们只分析其中一个：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tasklet_hi_schedule</span><span class="hljs-params">(struct tasklet_struct *t)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!test_and_set_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state)) &#123;<br>        <span class="hljs-keyword">int</span> cpu = smp_processor_id();<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> flags;<br><br>        local_irq_save(flags);<br>        t-&gt;next = tasklet_hi_vec[cpu].<span class="hljs-built_in">list</span>;<br>        tasklet_hi_vec[cpu].<span class="hljs-built_in">list</span> = t;<br>        __cpu_raise_softirq(cpu, HI_SOFTIRQ);<br>        local_irq_restore(flags);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>函数参数的类型是 <code>tasklet_struct</code> 结构的指针，表示需要执行的tasklet结构。<code>tasklet_hi_schedule()</code> 函数首先判断这个tasklet是否已经被添加到队列中，如果不是就添加到 <code>tasklet_hi_vec</code> 队列中，并且通过调用 <code>__cpu_raise_softirq(cpu, HI_SOFTIRQ)</code> 来告诉softirq需要执行 <code>HI_SOFTIRQ</code> 类型的softirq，我们来看看 <code>__cpu_raise_softirq()</code> 函数的实现：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> __cpu_raise_softirq(<span class="hljs-keyword">int</span> cpu, <span class="hljs-keyword">int</span> nr)<br>&#123;<br>    softirq_active(cpu) |= (<span class="hljs-number">1</span>&lt;&lt;nr);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看出，<code>__cpu_raise_softirq()</code> 函数就是把 <code>irq_cpustat_t</code> 结构的 <code>__softirq_active</code> 字段的 <code>nr位</code> 设置为1。对于 <code>tasklet_hi_schedule()</code> 函数就是把 <code>HI_SOFTIRQ</code> 位（0位）设置为1。</p><p>前面我们也介绍过，Linux在初始化时会注册两种softirq，<code>TASKLET_SOFTIRQ</code> 和 <code>HI_SOFTIRQ</code>：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">void</span> __<span class="hljs-function">init <span class="hljs-title">softirq_init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br>    open_softirq(TASKLET_SOFTIRQ, tasklet_action, <span class="hljs-literal">NULL</span>);<br>    open_softirq(HI_SOFTIRQ, tasklet_hi_action, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>所以当把 <code>irq_cpustat_t</code> 结构的 <code>__softirq_active</code> 字段的 <code>HI_SOFTIRQ</code> 位（0位）设置为1时，softirq机制就会执行 <code>tasklet_hi_action()</code> 函数，我们来看看 <code>tasklet_hi_action()</code> 函数的实现：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tasklet_hi_action</span><span class="hljs-params">(struct softirq_action *a)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> cpu = smp_processor_id();<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tasklet_struct</span> *<span class="hljs-title">list</span>;</span><br><br>    local_irq_disable();<br>    <span class="hljs-built_in">list</span> = tasklet_hi_vec[cpu].<span class="hljs-built_in">list</span>;<br>    tasklet_hi_vec[cpu].<span class="hljs-built_in">list</span> = <span class="hljs-literal">NULL</span>;<br>    local_irq_enable();<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">list</span> != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tasklet_struct</span> *<span class="hljs-title">t</span> = <span class="hljs-title">list</span>;</span><br><br>        <span class="hljs-built_in">list</span> = <span class="hljs-built_in">list</span>-&gt;next;<br><br>        <span class="hljs-keyword">if</span> (tasklet_trylock(t)) &#123;<br>            <span class="hljs-keyword">if</span> (atomic_read(&amp;t-&gt;count) == <span class="hljs-number">0</span>) &#123;<br>                clear_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state);<br><br>                t-&gt;func(t-&gt;data);  <span class="hljs-comment">// 调用tasklet处理函数</span><br>                tasklet_unlock(t);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            tasklet_unlock(t);<br>        &#125;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>tasklet_hi_action()</code> 函数非常简单，就是遍历 <code>tasklet_hi_vec</code> 队列并且执行其中tasklet的处理函数。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux系统调用原理</title>
    <link href="/2021/04/07/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86/"/>
    <url>/2021/04/07/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="一、什么是系统调用"><a href="#一、什么是系统调用" class="headerlink" title="一、什么是系统调用"></a>一、什么是系统调用</h2><p>系统调用 跟用户自定义函数一样也是一个函数，不同的是 系统调用 运行在内核态，而用户自定义函数运行在用户态。由于某些指令（如设置时钟、关闭/打开中断和I/O操作等）只能运行在内核态，所以操作系统必须提供一种能够进入内核态的方式，系统调用 就是这样的一种机制。</p><p>系统调用 是 Linux 内核提供的一段代码（函数），其实现了一些特定的功能，用户可以通过 int 0x80 中断（x86 CPU）或者 syscall 指令（x64 CPU）来调用 系统调用。</p><h2 id="二、进入系统调用"><a href="#二、进入系统调用" class="headerlink" title="二、进入系统调用"></a>二、进入系统调用</h2><p>本文主要介绍的是 x86 CPU 进入系统调用的方式<br>Linux 提供了 int 0x80 中断来让用户程序进入 系统调用，我们来看看 Linux 对 int 0x80 中断的处理初始化过程：</p><figure class="highlight lasso"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lasso"><span class="hljs-literal">void</span> __init trap_init(<span class="hljs-literal">void</span>)<br>&#123;<br>    <span class="hljs-params">...</span><br>    set_system_gate(SYSCALL_VECTOR, &amp;system_call);<br>    <span class="hljs-params">...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>系统初始化时，会在 trap_init() 函数中对 int 0x80 中断处理进行初始化，设置其中断处理过程入口为 system_call。system_call 是一段由汇编语言编写的代码，我们看看关键部分，如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">ENTRY(<span class="hljs-params">system_call</span>)</span><br>    ...<br>    call *<span class="hljs-constructor">SYMBOL_NAME(<span class="hljs-params">sys_call_table</span>)</span>(,%eax,<span class="hljs-number">4</span>)<br>    movl %eax,<span class="hljs-constructor">EAX(%<span class="hljs-params">esp</span>)</span>     # save the return value<br>    ...<br></code></pre></div></td></tr></table></figure><p>我们把上面的汇编改写成 C 代码如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs x86asm">void system_call()<br>&#123;<br>    ...<br>    // 变量 <span class="hljs-built_in">eax</span> 代表 <span class="hljs-built_in">eax</span> 寄存器的值<br>    <span class="hljs-keyword">syscall</span> = sys_call_table[<span class="hljs-built_in">eax</span>]<span class="hljs-comment">;</span><br>    <span class="hljs-built_in">eax</span> = <span class="hljs-keyword">syscall</span>()<span class="hljs-comment">;</span><br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>sys_call_table 变量是一个数组，数组的每一个元素代表一个 系统调用 的入口，其定义如下（在文件 arch/i386/kernel/entry.S 中）：</p><figure class="highlight isbl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs isbl">.data<br><span class="hljs-function"><span class="hljs-title">ENTRY</span>(<span class="hljs-variable">sys_call_table</span>)</span><br>    .long <span class="hljs-function"><span class="hljs-title">SYMBOL_NAME</span>(<span class="hljs-variable">sys_ni_syscall</span>)</span><br>    .long <span class="hljs-function"><span class="hljs-title">SYMBOL_NAME</span>(<span class="hljs-variable">sys_exit</span>)</span><br>    .long <span class="hljs-function"><span class="hljs-title">SYMBOL_NAME</span>(<span class="hljs-variable">sys_fork</span>)</span><br>    .long <span class="hljs-function"><span class="hljs-title">SYMBOL_NAME</span>(<span class="hljs-variable">sys_read</span>)</span><br>    .long <span class="hljs-function"><span class="hljs-title">SYMBOL_NAME</span>(<span class="hljs-variable">sys_write</span>)</span><br>    .long <span class="hljs-function"><span class="hljs-title">SYMBOL_NAME</span>(<span class="hljs-variable">sys_open</span>)</span><br>    .long <span class="hljs-function"><span class="hljs-title">SYMBOL_NAME</span>(<span class="hljs-variable">sys_close</span>)</span><br>    ...<br></code></pre></div></td></tr></table></figure><p>翻译成 C 代码如下：</p><figure class="highlight autohotkey"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs autohotkey">long sys_call_table[] = &#123;<br><span class="hljs-built_in">   sys_ni_syscall,</span><br><span class="hljs-built_in">   sys_exit,</span><br><span class="hljs-built_in">   sys_fork,</span><br><span class="hljs-built_in">   sys_read,</span><br><span class="hljs-built_in">   sys_write,</span><br><span class="hljs-built_in">   sys_open,</span><br><span class="hljs-built_in">   sys_close,</span><br>   ...<br>&#125;<span class="hljs-comment">;</span><br></code></pre></div></td></tr></table></figure><p>用户调用 系统调用 时，通过向 eax 寄存器写入要调用的 系统调用 编号，这个编号就是 sys_call_table 数组的下标。 system_call 过程获取 eax 寄存器的值，然后通过 eax 寄存器的值找到要调用的 系统调用 入口，并且进行调用。调用完成后，系统调用 会把返回值保存到 eax 寄存器中。</p><p><img src="/img/newimg/008eGmZEgy1gpb9mdbxdwj30fv0a1glx.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="三、系统调用实现"><a href="#三、系统调用实现" class="headerlink" title="三、系统调用实现"></a>三、系统调用实现</h2><p>当用户要调用 系统调用 时，需要通过向 eax 寄存器写入要调用的 系统调用 编号。因为 用户态 和 内核态 使用的栈不同，而调用 系统调用 是在用户态调用的，而进入 系统调用 后会变成内核态，所以参数就不能通过栈来传递。Linux 使用寄存器来传递参数，参数与寄存器的关系如下：</p><p>第1个参数放置在 ebx 寄存器。<br>第2个参数放置在 ecx 寄存器。<br>第3个参数放置在 edx 寄存器。<br>第4个参数放置在 esi 寄存器。<br>第5个参数放置在 edi 寄存器。<br>第6个参数放置在 ebp 寄存器。<br>而 Linux 进入中断处理程序时，会把这些寄存器的值保存到内核栈中，这样 系统调用 就能通过内核栈来获取到参数。</p><p>下面我们通过 sys_open() 系统调用来说明一下 系统调用 的运作方式，sys_open() 实现如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">asmlinkage long sys<span class="hljs-constructor">_open(<span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">filename</span>, <span class="hljs-params">int</span> <span class="hljs-params">flags</span>, <span class="hljs-params">int</span> <span class="hljs-params">mode</span>)</span><br>&#123;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>一般 系统调用 都需要使用 asmlinkage 编译选项，asmlinkage 编译选项是告诉编译器从栈中读取参数，其实际是封装了 GCC 的编译选项，如下：</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">#define asmlinkage CPP_ASMLINKAGE __attribute__((<span class="hljs-name">regparm</span>(<span class="hljs-number">0</span>)))<br></code></pre></div></td></tr></table></figure><p><strong>attribute</strong>((regparm(0))) 就是告诉 GCC 所有参数都从栈中读取，而 Linux 进入中断处理上下文时，会把 ebx、ecx、edx、esi、edi、ebp 寄存器的值保存到内核栈中，那么 系统调用 就可以从内核栈获取到参数的值。</p><p>但由于寄存器只能传递 32 位的整型值（x86 CPU），所以参数一般只能传递指针或者整型的数值，如果要获取指针对应结构的数据，就必须通过从用户空间复制到内核空间，如 sys_open() 系统调用获取要打开的文件路径：</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">asmlinkage long sys<span class="hljs-constructor">_open(<span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">filename</span>, <span class="hljs-params">int</span> <span class="hljs-params">flags</span>, <span class="hljs-params">int</span> <span class="hljs-params">mode</span>)</span><br>&#123;<br>    <span class="hljs-built_in">char</span><span class="hljs-operator"> * </span>tmp;<br>    ...<br>    tmp = getname(filename);<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>getname() 函数就是用于从用户空间复制数据到内核空间。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux虚拟文件系统</title>
    <link href="/2021/04/07/Linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/04/07/Linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h1><p>通常我们使用的磁盘和光盘都属于块设备，也就是说它们都是按照 <code>数据块</code> 来进行读写的，可以把磁盘和光盘想象成一个由数据块组成的巨大数组。但这样的读写方式对于人类来说不太友好，所以一般要在磁盘或者光盘上面挂载 <code>文件系统</code> 才能使用。那么什么是 <code>文件系统</code> 呢？ <code>文件系统</code> 是一种存储和组织数据的方法，它使得对其访问和查找变得容易。通过挂载文件系统后，我们可以使用如 <code>/home/docs/test.txt</code> 的方式来访问磁盘中的数据，而不用使用数据块编号来进行访问。</p><p>在Linux系统中，可以使用多种文件系统来挂载不同的设备，如 ext2、ext3、nfs等等。但提供给用户的文件处理接口是一致的，也就是说不管使用 ext2 文件系统还是使用 ext3 文件系统，处理文件的接口都是一样的。这样的好处是，用户不用关心使用了什么文件系统，只需要使用统一的方式去处理文件即可。那么Linux是如何做到的呢？这就得益于 <code>虚拟文件系统(Virtual File System，简称 VFS)</code>。</p><p><code>虚拟文件系统</code> 为不同的文件系统定义了一套规范，各个文件系统必须按照 <code>虚拟文件系统的规范</code> 编写才能接入到 <code>虚拟文件系统</code> 中。这有点像面向对象语言里面的 <code>接口</code>，当一个类实现了某个接口的所有方法时，便可以把这个类当做成此接口。VFS 主要为用户和内核架起一道桥梁，用户可以通过 VFS 提供的接口访问不同的文件系统，如下图：<br><img src="/img/newimg/008eGmZEgy1gpb9hxq5adj30bj0a1jrg.jpg" srcset="/img/loading.gif" alt=""></p><p>下面我们开始分析 <code>虚拟文件系统</code> 的实现原理。</p><h2 id="虚拟文件系统抽象数据结构"><a href="#虚拟文件系统抽象数据结构" class="headerlink" title="虚拟文件系统抽象数据结构"></a>虚拟文件系统抽象数据结构</h2><p>Linux奉行了Unix的理念：<code>一切皆文件</code>，比如一个目录是一个文件，一个设备也是一个文件等，因而文件系统在Linux中占有非常重要的地位。</p><p>因为要为不同类型的文件系统定义统一的接口层，所以 VFS 定义了一系列的规范，真实的文件系统必现按照 VFS 的规范来编写程序。VFS 抽象了几个数据结构来组织和管理不同的文件系统，分别为：<code>超级块（super_block）</code>、<code>索引节点（inode）</code>、<code>目录结构（dentry）</code> 和 <code>文件结构（file）</code>，要理解 VFS 就必须先了解这些数据结构的定义和作用。</p><h3 id="超级块-super-block"><a href="#超级块-super-block" class="headerlink" title="超级块(super block)"></a>超级块(super block)</h3><p>因为Linux支持多文件系统，所以在内核中必须通过一个数据结构来描述具体文件系统的信息和相关的操作等，VFS 定义了一个名为 <code>超级块（super_block）</code> 的数据结构来描述具体的文件系统，也就是说内核是通过超级块来认知具体的文件系统的，一个具体的文件系统会对应一个超级块结构，其定义如下（由于super_block的成员比较多，所以这里只列出部分）：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> &#123;</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;<br>    <span class="hljs-keyword">int</span> fs_flags;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *(*<span class="hljs-title">read_super</span>) (<span class="hljs-title">struct</span> <span class="hljs-title">super_block</span> *, <span class="hljs-title">void</span> *, <span class="hljs-title">int</span>);</span> <span class="hljs-comment">// 读取设备中文件系统超级块的方法</span><br>    ...<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_operations</span> &#123;</span><br>    <span class="hljs-keyword">void</span> (*read_inode) (struct inode *);        <span class="hljs-comment">// 把磁盘中的inode数据读取入到内存中</span><br>    <span class="hljs-keyword">void</span> (*write_inode) (struct inode *, <span class="hljs-keyword">int</span>);  <span class="hljs-comment">// 把inode的数据写入到磁盘中</span><br>    <span class="hljs-keyword">void</span> (*put_inode) (struct inode *);         <span class="hljs-comment">// 释放inode占用的内存</span><br>    <span class="hljs-keyword">void</span> (*delete_inode) (struct inode *);      <span class="hljs-comment">// 删除磁盘中的一个inode</span><br>    <span class="hljs-keyword">void</span> (*put_super) (struct super_block *);   <span class="hljs-comment">// 释放超级块占用的内存</span><br>    <span class="hljs-keyword">void</span> (*write_super) (struct super_block *); <span class="hljs-comment">// 把超级块写入到磁盘中</span><br>    ...<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>    <span class="hljs-title">s_list</span>;</span>     <span class="hljs-comment">/* Keep this first */</span><br>    <span class="hljs-keyword">kdev_t</span>              s_dev;         <span class="hljs-comment">// 设备号</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>       s_blocksize;   <span class="hljs-comment">// 数据块大小</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>       s_blocksize_bits;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>       s_lock;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>       s_dirt;       <span class="hljs-comment">// 是否脏</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> *<span class="hljs-title">s_type</span>;</span>  <span class="hljs-comment">// 文件系统类型</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_operations</span> *<span class="hljs-title">s_op</span>;</span>    <span class="hljs-comment">// 超级块相关的操作列表</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dquot_operations</span> *<span class="hljs-title">dq_op</span>;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>       s_flags;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>       s_magic;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span>       *<span class="hljs-title">s_root</span>;</span>      <span class="hljs-comment">// 挂载的根目录</span><br>    <span class="hljs-keyword">wait_queue_head_t</span>   s_wait;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>    <span class="hljs-title">s_dirty</span>;</span>    <span class="hljs-comment">/* dirty inodes */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>    <span class="hljs-title">s_files</span>;</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_device</span> *<span class="hljs-title">s_bdev</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>    <span class="hljs-title">s_mounts</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quota_mount_options</span> <span class="hljs-title">s_dquot</span>;</span><br><br>    <span class="hljs-keyword">union</span> &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">minix_sb_info</span>    <span class="hljs-title">minix_sb</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext2_sb_info</span> <span class="hljs-title">ext2_sb</span>;</span><br>        ...<br>    &#125; u;<br>    ...<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>下面我们介绍一下一些比较重要的成员：</p><ul><li>s_dev：用于保存设备的设备号</li><li>s_blocksize：用于保存文件系统的数据块大小（文件系统是以数据块为单位的）</li><li>s_type：文件系统的类型（提供了读取设备中文件系统超级块的方法）</li><li>s_op：超级块相关的操作列表</li><li>s_root：挂载的根目录</li></ul><h3 id="索引节点（inode）"><a href="#索引节点（inode）" class="headerlink" title="索引节点（inode）"></a>索引节点（inode）</h3><p><code>索引节点（inode）</code> 是 VFS 中最为重要的一个结构，用于描述一个文件的meta（元）信息，其包含的是诸如文件的大小、拥有者、创建时间、磁盘位置等和文件相关的信息，所有文件都有一个对应的 <code>inode</code> 结构。<code>inode</code> 的定义如下（由于inode的成员也是非常多，所以这里也只列出部分成员，具体可以参考Linux源码）：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_operations</span> &#123;</span><br>    <span class="hljs-keyword">int</span> (*create) (struct inode *,struct dentry *,<span class="hljs-keyword">int</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> * (*<span class="hljs-title">lookup</span>) (<span class="hljs-title">struct</span> <span class="hljs-title">inode</span> *,<span class="hljs-title">struct</span> <span class="hljs-title">dentry</span> *);</span><br>    <span class="hljs-keyword">int</span> (*link) (struct dentry *,struct inode *,struct dentry *);<br>    <span class="hljs-keyword">int</span> (*unlink) (struct inode *,struct dentry *);<br>    <span class="hljs-keyword">int</span> (*symlink) (struct inode *,struct dentry *,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *);<br>    ...<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><br>    <span class="hljs-keyword">loff_t</span> (*llseek) (struct file *, <span class="hljs-keyword">loff_t</span>, <span class="hljs-keyword">int</span>);<br>    <span class="hljs-keyword">ssize_t</span> (*read) (struct file *, <span class="hljs-keyword">char</span> *, <span class="hljs-keyword">size_t</span>, <span class="hljs-keyword">loff_t</span> *);<br>    <span class="hljs-keyword">ssize_t</span> (*write) (struct file *, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *, <span class="hljs-keyword">size_t</span>, <span class="hljs-keyword">loff_t</span> *);<br>    ...<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> &#123;</span><br>    ...<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>       i_ino;<br>    <span class="hljs-keyword">atomic_t</span>            i_count;<br>    <span class="hljs-keyword">kdev_t</span>              i_dev;<br>    <span class="hljs-keyword">umode_t</span>             i_mode;<br>    <span class="hljs-keyword">nlink_t</span>             i_nlink;<br>    <span class="hljs-keyword">uid_t</span>               i_uid;<br>    <span class="hljs-keyword">gid_t</span>               i_gid;<br>    <span class="hljs-keyword">kdev_t</span>              i_rdev;<br>    <span class="hljs-keyword">loff_t</span>              i_size;<br>    <span class="hljs-keyword">time_t</span>              i_atime;<br>    <span class="hljs-keyword">time_t</span>              i_mtime;<br>    <span class="hljs-keyword">time_t</span>              i_ctime;<br>    ...<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_operations</span> *<span class="hljs-title">i_op</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span>  *<span class="hljs-title">i_fop</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span>      *<span class="hljs-title">i_sb</span>;</span><br>    ...<br>    <span class="hljs-keyword">union</span> &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">minix_inode_info</span>     <span class="hljs-title">minix_i</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext2_inode_info</span>      <span class="hljs-title">ext2_i</span>;</span><br>        ...<br>    &#125; u;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>下面也介绍一下 <code>inode</code> 中几个比较重要的成员：</p><ul><li>i_uid：文件所属的用户</li><li>i_gid：文件所属的组</li><li>i_rdev：文件所在的设备号</li><li>i_size：文件的大小</li><li>i_atime：文件的最后访问时间</li><li>i_mtime：文件的最后修改时间</li><li>i_ctime：文件的创建时间</li><li>i_op：inode相关的操作列表</li><li>i_fop：文件相关的操作列表</li><li>i_sb：文件所在文件系统的超级块</li></ul><p>我们应该重点关注 <code>i_op</code> 和 <code>i_fop</code> 这两个成员。<code>i_op</code> 成员定义对目录相关的操作方法列表，譬如 <code>mkdir()</code>系统调用会触发 <code>inode-&gt;i_op-&gt;mkdir()</code> 方法，而 <code>link()</code> 系统调用会触发 <code>inode-&gt;i_op-&gt;link()</code> 方法。而 <code>i_fop</code> 成员则定义了对打开文件后对文件的操作方法列表，譬如 <code>read()</code> 系统调用会触发 <code>inode-&gt;i_fop-&gt;read()</code> 方法，而 <code>write()</code> 系统调用会触发 <code>inode-&gt;i_fop-&gt;write()</code> 方法。</p><h3 id="目录项（dentry）"><a href="#目录项（dentry）" class="headerlink" title="目录项（dentry）"></a>目录项（dentry）</h3><p>目录项的主要作用是方便查找文件。一个路径的各个组成部分，不管是目录还是普通的文件，都是一个目录项对象。如，在路径 <code>/home/liexusong/example.c</code> 中，目录 <code>/</code>, <code>home/</code>, <code>liexusong/</code> 和文件 <code>example.c</code> 都对应一个目录项对象。不同于前面的两个对象，目录项对象没有对应的磁盘数据结构，VFS 在遍历路径名的过程中现场将它们逐个地解析成目录项对象。其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry_operations</span> &#123;</span><br>    <span class="hljs-keyword">int</span> (*d_revalidate)(struct dentry *, <span class="hljs-keyword">int</span>);<br>    <span class="hljs-keyword">int</span> (*d_hash) (struct dentry *, struct qstr *);<br>    <span class="hljs-keyword">int</span> (*d_compare) (struct dentry *, struct qstr *, struct qstr *);<br>    <span class="hljs-keyword">int</span> (*d_delete)(struct dentry *);<br>    <span class="hljs-keyword">void</span> (*d_release)(struct dentry *);<br>    <span class="hljs-keyword">void</span> (*d_iput)(struct dentry *, struct inode *);<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> &#123;</span><br>    ...<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span>  * <span class="hljs-title">d_inode</span>;</span>    <span class="hljs-comment">// 目录项对应的inode</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> * <span class="hljs-title">d_parent</span>;</span>   <span class="hljs-comment">// 当前目录项对应的父目录</span><br>    ...<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">qstr</span> <span class="hljs-title">d_name</span>;</span>         <span class="hljs-comment">// 目录的名字</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> d_time;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry_operations</span>  *<span class="hljs-title">d_op</span>;</span> <span class="hljs-comment">// 目录项的辅助方法</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> * <span class="hljs-title">d_sb</span>;</span>       <span class="hljs-comment">// 所在文件系统的超级块对象</span><br>    ...<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> d_iname[DNAME_INLINE_LEN]; <span class="hljs-comment">// 当目录名不超过16个字符时使用</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="文件结构（file）"><a href="#文件结构（file）" class="headerlink" title="文件结构（file）"></a>文件结构（file）</h3><p>文件结构用于描述一个已打开的文件，其包含文件当前的读写偏移量，文件打开模式和文件操作函数列表等，文件结构定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>         <span class="hljs-title">f_list</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span>           *<span class="hljs-title">f_dentry</span>;</span>  <span class="hljs-comment">// 文件所属的dentry结构</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span>  *<span class="hljs-title">f_op</span>;</span>      <span class="hljs-comment">// 文件的操作列表</span><br>    <span class="hljs-keyword">atomic_t</span>                 f_count;   <span class="hljs-comment">// 计数器（表示有多少个用户打开此文件）</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>             f_flags;   <span class="hljs-comment">// 标识位  </span><br>    <span class="hljs-keyword">mode_t</span>                   f_mode;    <span class="hljs-comment">// 打开模式</span><br>    <span class="hljs-keyword">loff_t</span>                   f_pos;     <span class="hljs-comment">// 读写偏移量</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>            f_reada, f_ramax, f_raend, f_ralen, f_rawin;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fown_struct</span>       <span class="hljs-title">f_owner</span>;</span>   <span class="hljs-comment">// 所属者信息</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>             f_uid, f_gid;  <span class="hljs-comment">// 打开的用户id和组id</span><br>    <span class="hljs-keyword">int</span>                      f_error;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>            f_version;<br><br>    <span class="hljs-comment">/* needed for tty driver, and maybe others */</span><br>    <span class="hljs-keyword">void</span>                    *private_data;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>下图展示了各个数据结构之间的关系：<br><img src="/img/newimg/008eGmZEgy1gpb9i5r6fbj30t60q83z4.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="虚拟文件系统的实现"><a href="#虚拟文件系统的实现" class="headerlink" title="虚拟文件系统的实现"></a>虚拟文件系统的实现</h2><p>接下来我们分析一下虚拟文件系统的实现。</p><h3 id="注册文件系统"><a href="#注册文件系统" class="headerlink" title="注册文件系统"></a>注册文件系统</h3><p>Linux为了支持不同的文件系统而创造了虚拟文件系统，虚拟文件系统更像一个规范(或者说接口)，真实的文件系统需要实现虚拟文件系统的规范(接口)才能接入到Linux内核中。</p><p>要让Linux内核能够发现真实的文件系统，那么必须先使用 <code>register_filesystem()</code> 函数注册文件系统，<code>register_filesystem()</code> 函数实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">register_filesystem</span><span class="hljs-params">(struct file_system_type * fs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> ** <span class="hljs-title">tmp</span>;</span><br><br>    <span class="hljs-keyword">if</span> (!fs)<br>        <span class="hljs-keyword">return</span> -EINVAL;<br>    <span class="hljs-keyword">if</span> (fs-&gt;next)<br>        <span class="hljs-keyword">return</span> -EBUSY;<br>    tmp = &amp;file_systems;<br>    <span class="hljs-keyword">while</span> (*tmp) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>((*tmp)-&gt;name, fs-&gt;name) == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> -EBUSY;<br>        tmp = &amp;(*tmp)-&gt;next;<br>    &#125;<br>    *tmp = fs;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>register_filesystem()</code> 函数的实现很简单，就是把类型为 <code>struct file_system_type</code> 的 <code>fs</code> 添加到 <code>file_systems</code> 全局链表中。<code>struct file_system_type</code> 结构的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> &#123;</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;<br>    <span class="hljs-keyword">int</span> fs_flags;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *(*<span class="hljs-title">read_super</span>) (<span class="hljs-title">struct</span> <span class="hljs-title">super_block</span> *, <span class="hljs-title">void</span> *, <span class="hljs-title">int</span>);</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> * <span class="hljs-title">next</span>;</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>其中比较重要的字段是 <code>read_super</code>，用于读取文件系统的超级块结构。在Linux初始化时会注册各种文件系统，比如 <code>ext2</code> 文件系统会调用 <code>register_filesystem(&amp;ext2_fs_type)</code> 来注册。</p><p>当安装Linux系统时，需要把磁盘格式化为指定的文件系统，其实格式化就是把文件系统超级块信息写入到磁盘中。但Linux系统启动时，就会遍历所有注册过的文件系统，然后调用其 <code>read_super()</code> 接口来尝试读取超级块信息，因为每种文件系统的超级块都有不同的魔数，用于识别不同的文件系统，所以当调用 <code>read_super()</code> 接口返回成功时，表示读取超级块成功，而且识别出磁盘所使用的文件系统。具体过程可以通过 <code>mount_root()</code> 函数得知：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">void</span> __<span class="hljs-function">init <span class="hljs-title">mount_root</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br><br>    <span class="hljs-built_in">memset</span>(&amp;filp, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(filp));<br>    d_inode = get_empty_inode(); <span class="hljs-comment">// 获取一个新的inode</span><br>    d_inode-&gt;i_rdev = ROOT_DEV;<br>    filp.f_dentry = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> ( root_mountflags &amp; MS_RDONLY)<br>        filp.f_mode = <span class="hljs-number">1</span>; <span class="hljs-comment">/* read only */</span><br>    <span class="hljs-keyword">else</span><br>        filp.f_mode = <span class="hljs-number">3</span>; <span class="hljs-comment">/* read write */</span><br>    retval = blkdev_open(d_inode, &amp;filp);<br>    <span class="hljs-keyword">if</span> (retval == -EROFS) &#123;<br>        root_mountflags |= MS_RDONLY;<br>        filp.f_mode = <span class="hljs-number">1</span>;<br>        retval = blkdev_open(d_inode, &amp;filp);<br>    &#125;<br><br>    iput(d_inode);<br><br>    <span class="hljs-keyword">if</span> (retval)<br>        printk(<span class="hljs-string">"VFS: Cannot open root device %s\n"</span>, kdevname(ROOT_DEV));<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (fs_type = file_systems ; fs_type ; fs_type = fs_type-&gt;next) &#123; <span class="hljs-comment">// 试探性读取超级块</span><br>            <span class="hljs-keyword">if</span> (!(fs_type-&gt;fs_flags &amp; FS_REQUIRES_DEV))<br>                <span class="hljs-keyword">continue</span>;<br>            sb = read_super(ROOT_DEV,fs_type-&gt;name,root_mountflags,<span class="hljs-literal">NULL</span>,<span class="hljs-number">1</span>); <span class="hljs-comment">// 读取超级块</span><br>            <span class="hljs-keyword">if</span> (sb) &#123;<br>                sb-&gt;s_flags = root_mountflags;<br>                current-&gt;fs-&gt;root = dget(sb-&gt;s_root);  <span class="hljs-comment">// 设置根目录</span><br>                current-&gt;fs-&gt;pwd = dget(sb-&gt;s_root);   <span class="hljs-comment">// 设置当前工作目录</span><br>                vfsmnt = add_vfsmnt(sb, <span class="hljs-string">"/dev/root"</span>, <span class="hljs-string">"/"</span>);<br>                <span class="hljs-keyword">if</span> (vfsmnt)<br>                    <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在上面的for循环中，遍历了所有已注册的文件系统，并且调用其 <code>read_super()</code> 接口来尝试读取超级块信息，如果成功表示磁盘所使用的文件系统就是当前文件系统。成功读取超级块信息后，会把根目录的 <code>dentry</code> 结构保存到当前进程的 <code>root</code> 和 <code>pwd</code> 字段中，<code>root</code> 表示根目录，<code>pwd</code> 表示当前工作目录。</p><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>要使用一个文件前必须打开文件，打开文件使用 <code>open()</code> 系统调用来实现，而 <code>open()</code> 系统调用最终会调用内核的 <code>sys_open()</code> 函数，<code>sys_open()</code> 函数实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">asmlinkage <span class="hljs-keyword">long</span> <span class="hljs-title">sys_open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * filename, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">int</span> mode)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> * tmp;<br>    <span class="hljs-keyword">int</span> fd, error;<br><br>    tmp = getname(filename);<br>    fd = PTR_ERR(tmp);<br>    <span class="hljs-keyword">if</span> (!IS_ERR(tmp)) &#123;<br>        fd = get_unused_fd();<br>        <span class="hljs-keyword">if</span> (fd &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> * <span class="hljs-title">f</span>;</span><br>            lock_kernel();<br>            f = filp_open(tmp, flags, mode);<br>            unlock_kernel();<br>            error = PTR_ERR(f);<br>            <span class="hljs-keyword">if</span> (IS_ERR(f))<br>                <span class="hljs-keyword">goto</span> out_error;<br>            fd_install(fd, f);<br>        &#125;<br>out:<br>        putname(tmp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> fd;<br><br>out_error:<br>    put_unused_fd(fd);<br>    fd = error;<br>    <span class="hljs-keyword">goto</span> out;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>sys_open()</code> 函数的主要流程是：</p><ul><li>通过调用 <code>get_unused_fd()</code> 函数获取一个空闲的文件描述符。</li><li>调用 <code>filp_open()</code> 函数打开文件，返回打开文件的file结构。</li><li>调用 <code>fd_install()</code> 函数把文件描述符与file结构关联起来。</li><li>返回文件描述符，也就是 <code>open()</code> 系统调用的返回值。</li></ul><p>在上面的过程中，最重要的是调用 <code>filp_open()</code> 函数打开文件，<code>filp_open()</code> 函数的实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">struct file *<span class="hljs-title">filp_open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * filename, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">int</span> mode)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> * <span class="hljs-title">inode</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> * <span class="hljs-title">dentry</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> * <span class="hljs-title">f</span>;</span><br>    <span class="hljs-keyword">int</span> flag,error;<br><br>    error = -ENFILE;<br>    f = get_empty_filp(); <span class="hljs-comment">// 获取一个空闲的file结构</span><br>    ...<br>    dentry = open_namei(filename,flag,mode); <span class="hljs-comment">// 通过文件路径打开文件</span><br>    inode = dentry-&gt;d_inode;<br>    ...<br>    f-&gt;f_dentry = dentry; <span class="hljs-comment">// 设置file结构的f_dentry字段为打开文件的dentry结构</span><br>    f-&gt;f_pos = <span class="hljs-number">0</span>;<br>    f-&gt;f_reada = <span class="hljs-number">0</span>;<br>    f-&gt;f_op = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (inode-&gt;i_op)<br>        f-&gt;f_op = inode-&gt;i_op-&gt;default_file_ops; <span class="hljs-comment">// 把文件的操作函数列表从inode结构复制到file结构中</span><br>    <span class="hljs-keyword">if</span> (inode-&gt;i_sb)<br>        file_move(f, &amp;inode-&gt;i_sb-&gt;s_files);<br>    <span class="hljs-keyword">if</span> (f-&gt;f_op &amp;&amp; f-&gt;f_op-&gt;open) &#123;<br>        error = f-&gt;f_op-&gt;open(inode,f);<br>        <span class="hljs-keyword">if</span> (error)<br>            <span class="hljs-keyword">goto</span> cleanup_all;<br>    &#125;<br>    f-&gt;f_flags &amp;= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);<br><br>    <span class="hljs-keyword">return</span> f;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>filp_open()</code> 函数首先调用 <code>get_empty_filp()</code> 函数获取一个空闲的file结构，然后调用 <code>open_namei()</code> 函数来打开对应路径的文件。<code>open_namei()</code> 函数会返回一个 <code>dentry结构</code>，就是对应文件路径的 <code>dentry结构</code>。所以 <code>open_namei()</code> 函数才是打开文件的核心函数，其实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">struct dentry * <span class="hljs-title">open_namei</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * pathname, <span class="hljs-keyword">int</span> flag, <span class="hljs-keyword">int</span> mode)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> acc_mode, error;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">inode</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> *<span class="hljs-title">dentry</span>;</span><br><br>    mode &amp;= S_IALLUGO &amp; ~current-&gt;fs-&gt;umask;<br>    mode |= S_IFREG;<br><br>    dentry = lookup_dentry(pathname, <span class="hljs-literal">NULL</span>, lookup_flags(flag)); <span class="hljs-comment">// 通过路径一级一级的查找对应的dentry</span><br>    <span class="hljs-keyword">if</span> (IS_ERR(dentry))<br>        <span class="hljs-keyword">return</span> dentry;<br><br>    acc_mode = ACC_MODE(flag);<br>    <span class="hljs-keyword">if</span> (flag &amp; O_CREAT) &#123;  <span class="hljs-comment">// 如果是创建文件</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> *<span class="hljs-title">dir</span>;</span><br><br>        <span class="hljs-keyword">if</span> (dentry-&gt;d_inode) &#123;<br>            <span class="hljs-keyword">if</span> (!(flag &amp; O_EXCL))<br>                <span class="hljs-keyword">goto</span> nocreate;<br>            error = -EEXIST;  <span class="hljs-comment">// 已经存在返回错误</span><br>            <span class="hljs-keyword">goto</span> <span class="hljs-built_in">exit</span>;<br>        &#125;<br><br>        ...<br><br>        <span class="hljs-keyword">if</span> (dentry-&gt;d_inode) &#123;<br>            error = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (flag &amp; O_EXCL)<br>                error = -EEXIST;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果文件不存在</span><br>            error = vfs_create(dir-&gt;d_inode, dentry,mode); <span class="hljs-comment">// 创建文件</span><br>            ...<br>        &#125;<br>        ...<br>    &#125;<br><br>    ...<br><br>    <span class="hljs-keyword">return</span> dentry;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面的代码去掉了很多权限验证的代码，<code>open_namei()</code> 函数首先会调用 <code>lookup_dentry()</code> 函数打开文件并获得文件打开后的 <code>dentry结构</code>，如果文件不存在并且打开文件的时候设置了 <code>O_CREAT</code> 标志位，那么就调用 <code>vfs_create()</code> 函数创建文件。我们先来看看 <code>vfs_create()</code> 函数的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vfs_create</span><span class="hljs-params">(struct inode *dir, struct dentry *dentry, <span class="hljs-keyword">int</span> mode)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> error;<br><br>    error = may_create(dir, dentry);<br>    <span class="hljs-keyword">if</span> (error)<br>        <span class="hljs-keyword">goto</span> exit_lock;<br><br>    error = -EACCES;    <span class="hljs-comment">/* shouldn't it be ENOSYS? */</span><br>    <span class="hljs-keyword">if</span> (!dir-&gt;i_op || !dir-&gt;i_op-&gt;create)<br>        <span class="hljs-keyword">goto</span> exit_lock;<br><br>    DQUOT_INIT(dir);<br>    error = dir-&gt;i_op-&gt;create(dir, dentry, mode);<br>exit_lock:<br>    <span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>从 <code>vfs_create()</code> 函数的实现可知，最终会调用 <code>inode结构</code> 的 <code>create()</code> 方法来创建文件。这个方法由真实的文件系统提供，所以真实文件系统只需要把创建文件的方法挂载到 <code>inode结构</code> 上即可，虚拟文件系统不需要知道真实文件系统的实现过程，这就是虚拟文件系统可以支持多种文件系统的真正原因。</p><p>而 <code>lookup_dentry()</code> 函数最终会调用 <code>real_lookup()</code> 函数来逐级目录查找并打开。<code>real_lookup()</code> 函数代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> struct dentry * <span class="hljs-title">real_lookup</span><span class="hljs-params">(struct dentry * parent, struct qstr * name, <span class="hljs-keyword">int</span> flags)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> * <span class="hljs-title">result</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">dir</span> = <span class="hljs-title">parent</span>-&gt;<span class="hljs-title">d_inode</span>;</span><br><br>    down(&amp;dir-&gt;i_sem);<br>    result = d_lookup(parent, name);<br>    <span class="hljs-keyword">if</span> (!result) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> * <span class="hljs-title">dentry</span> = <span class="hljs-title">d_alloc</span>(<span class="hljs-title">parent</span>, <span class="hljs-title">name</span>);</span><br>        result = ERR_PTR(-ENOMEM);<br>        <span class="hljs-keyword">if</span> (dentry) &#123;<br>            result = dir-&gt;i_op-&gt;lookup(dir, dentry);<br>            <span class="hljs-keyword">if</span> (result)<br>                dput(dentry);<br>            <span class="hljs-keyword">else</span><br>                result = dentry;<br>        &#125;<br>        up(&amp;dir-&gt;i_sem);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    up(&amp;dir-&gt;i_sem);<br>    <span class="hljs-keyword">if</span> (result-&gt;d_op &amp;&amp; result-&gt;d_op-&gt;d_revalidate)<br>        result-&gt;d_op-&gt;d_revalidate(result, flags);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>参数 <code>parent</code> 是父目录的 <code>dentry结构</code>，而参数 <code>name</code> 是要打开的目录或者文件的名称。<code>real_lookup()</code> 函数最终也会调用父目录的 <code>inode结构</code> 的 <code>lookup()</code> 方法来查找并打开文件，然后返回打开后的子目录或者文件的 <code>dentry结构</code>。<code>lookup()</code> 方法需要把要打开的目录或者文件的 <code>inode结构</code> 从磁盘中读入到内存中（如果目录或者文件存在的话），并且把其 <code>inode结构</code> 保存到 <code>dentry结构</code> 的 <code>d_inode</code> 字段中。</p><p><code>filp_open()</code> 函数会把 <code>inode结构</code> 的文件操作函数列表复制到 <code>file结构</code> 中，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">struct file *<span class="hljs-title">filp_open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * filename, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">int</span> mode)</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br>    f-&gt;f_op = inode-&gt;i_op-&gt;default_file_ops;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样，<code>file结构</code> 就有操作文件的函数列表。</p><h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>读取文件内容通过 <code>read()</code> 系统调用完成，而 <code>read()</code> 系统调用最终会调用 <code>sys_read()</code> 内核函数，<code>sys_read()</code> 内核函数的实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">asmlinkage ssize_t <span class="hljs-title">sys_read</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">char</span> * buf, <span class="hljs-keyword">size_t</span> count)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">ssize_t</span> ret;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> * <span class="hljs-title">file</span>;</span><br><br>    ret = -EBADF;<br>    file = fget(fd);<br>    <span class="hljs-keyword">if</span> (file) &#123;<br>        <span class="hljs-keyword">if</span> (file-&gt;f_mode &amp; FMODE_READ) &#123;<br>            ret = locks_verify_area(FLOCK_VERIFY_READ, file-&gt;f_dentry-&gt;d_inode,<br>                        file, file-&gt;f_pos, count);<br>            <span class="hljs-keyword">if</span> (!ret) &#123;<br>                <span class="hljs-keyword">ssize_t</span> (*read)(struct file *, <span class="hljs-keyword">char</span> *, <span class="hljs-keyword">size_t</span>, <span class="hljs-keyword">loff_t</span> *);<br>                ret = -EINVAL;<br>                <span class="hljs-keyword">if</span> (file-&gt;f_op &amp;&amp; (read = file-&gt;f_op-&gt;read) != <span class="hljs-literal">NULL</span>)<br>                    ret = read(file, buf, count, &amp;file-&gt;f_pos);<br>            &#125;<br>        &#125;<br>        fput(file);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>sys_read()</code> 函数首先会调用 <code>fget()</code> 函数把文件描述符转换成 <code>file结构</code>，然后再通过调用 <code>file结构</code> 的 <code>read()</code> 方法来读取文件内容，<code>read()</code> 方法是由真实文件系统提供的，所以最终的过程会根据不同的文件系统而进行不同的操作，比如ext2文件系统最终会调用 <code>generic_file_read()</code> 函数来读取文件的内容。</p><p>把内容写入到文件是通过调用 <code>write()</code> 系统调用实现，而 <code>write()</code> 系统调用最终会调用 <code>sys_write()</code> 内核函数，<code>sys_write()</code> 函数的实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">asmlinkage ssize_t <span class="hljs-title">sys_write</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * buf, <span class="hljs-keyword">size_t</span> count)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">ssize_t</span> ret;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> * <span class="hljs-title">file</span>;</span><br><br>    ret = -EBADF;<br>    file = fget(fd);<br>    <span class="hljs-keyword">if</span> (file) &#123;<br>        <span class="hljs-keyword">if</span> (file-&gt;f_mode &amp; FMODE_WRITE) &#123;<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">inode</span> = <span class="hljs-title">file</span>-&gt;<span class="hljs-title">f_dentry</span>-&gt;<span class="hljs-title">d_inode</span>;</span><br>            ret = locks_verify_area(FLOCK_VERIFY_WRITE, inode, file,<br>                file-&gt;f_pos, count);<br>            <span class="hljs-keyword">if</span> (!ret) &#123;<br>                <span class="hljs-keyword">ssize_t</span> (*write)(struct file *, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *, <span class="hljs-keyword">size_t</span>, <span class="hljs-keyword">loff_t</span> *);<br>                ret = -EINVAL;<br>                <span class="hljs-keyword">if</span> (file-&gt;f_op &amp;&amp; (write = file-&gt;f_op-&gt;write) != <span class="hljs-literal">NULL</span>)<br>                    ret = write(file, buf, count, &amp;file-&gt;f_pos);<br>            &#125;<br>        &#125;<br>        fput(file);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>sys_write()</code> 函数的实现与 <code>sys_read()</code> 类似，首先会调用 <code>fget()</code> 函数把文件描述符转换成 <code>file结构</code>，然后再通过调用 <code>file结构</code> 的 <code>write()</code> 方法来把内容写入到文件中，对于ext2文件系统，<code>write()</code> 方法对应的是 <code>ext2_file_write()</code> 函数。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux 直接I/O 原理与实现</title>
    <link href="/2021/04/07/Linux-%E7%9B%B4%E6%8E%A5I-O-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/04/07/Linux-%E7%9B%B4%E6%8E%A5I-O-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="缓存I-O"><a href="#缓存I-O" class="headerlink" title="缓存I/O"></a>缓存I/O</h2><p>一般来说，当调用 <code>open()</code> 系统调用打开文件时，如果不指定 <code>O_DIRECT</code> 标志，那么就是使用缓存I/O来对文件进行读写操作。我们先来看看 <code>open()</code> 系统调用的定义：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">int</span> flags, ... <span class="hljs-comment">/*, mode_t mode */</span> )</span></span>;<br></code></pre></div></td></tr></table></figure><p>下面说明一下各个参数的作用：</p><ul><li><code>pathname</code>：指定要打开的文件路径。</li><li><code>flags</code>：指定打开文件的标志。</li><li><code>mode</code>：可选，指定打开文件的权限。</li></ul><p>其中 <code>flags</code> 参数可选值如下表：</p><table><thead><tr><th>标志</th><th>说明</th></tr></thead><tbody><tr><td>O_RDONLY</td><td>以只读的方式打开文件</td></tr><tr><td>O_WRONLY</td><td>以只写的方式打开文件</td></tr><tr><td>O_RDWR</td><td>以读写的方式打开文件</td></tr><tr><td>O_CREAT</td><td>若文件不存在，则创建该文件</td></tr><tr><td>O_EXCL</td><td>以独占模式打开文件；若同时设置 O_EXCL 和 O_CREATE, 那么若文件已经存在，则打开操作会失败</td></tr><tr><td>O_NOCTTY</td><td>若设置该描述符，则该文件不可以被当成终端处理</td></tr><tr><td>O_TRUNC</td><td>截断文件，若文件存在，则删除该文件</td></tr><tr><td>O_APPEND</td><td>若设置了该描述符，则在写文件之前，文件指针会被设置到文件的底部</td></tr><tr><td>O_NONBLOCK</td><td>以非阻塞的方式打开文件</td></tr><tr><td>O_NELAY</td><td>同 O_NELAY，若同时设置 O_NELAY 和 O_NONBLOCK，O_NONBLOCK 优先起作用</td></tr><tr><td>FASYNC</td><td>若设置该描述符，则 I/O 事件通知是通过信号发出的</td></tr><tr><td>O_SYNC</td><td>该描述符会对普通文件的写操作产生影响，若设置了该描述符，则对该文件的写操作会等到数据被写到磁盘上才算结束</td></tr><tr><td>O_DIRECT</td><td>该描述符提供对直接 I/O 的支持</td></tr><tr><td>O_LARGEFILE</td><td>该描述符提供对超过 2GB 大文件的支持</td></tr><tr><td>O_DIRECTORY</td><td>该描述符表明所打开的文件必须是目录，否则打开操作失败</td></tr><tr><td>O_NOFOLLOW</td><td>若设置该描述符，则不解析路径名尾部的符号链接</td></tr></tbody></table><p><code>flags</code> 参数用于指定打开文件的标志，比如指定 <code>O_RDONLY</code>，那么就只能以只读方式对文件进行读写。这些标志都能通过 <code>位或 (|)</code> 操作来设置多个标志如：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-built_in">open</span>(<span class="hljs-string">"/path/to/file"</span>, O_RDONLY|O_APPEND|O_DIRECT);<br></code></pre></div></td></tr></table></figure><p>但 <code>O_RDONLY</code>、<code>O_WRONLY</code> 和 <code>O_RDWR</code> 这三个标志是互斥的，也就是说这三个标志不能同时设置，只能设置其中一个。</p><p>当打开文件不指定 <code>O_DIRECT</code> 标志时，那么就默认使用 <code>缓存I/O</code> 方式打开。我们可以通过下图来了解 <code>缓存I/O</code> 处于文件系统的什么位置：</p><p><img src="/img/newimg/008eGmZEgy1gpb9d1ta9mj30fw0fvwf1.jpg" srcset="/img/loading.gif" alt=""></p><p>上图中红色框部分就是 <code>缓存I/O</code> 所在位置，位于 <code>虚拟文件系统</code> 与 <code>真实文件系统</code> 中间。</p><p>也就是说，当虚拟文件系统读文件时，首先从缓存中查找要读取的文件内容是否存在缓存中，如果存在就直接从缓存中读取。对文件进行写操作时也一样，首先写入到缓存中，然后由操作系统同步到块设备（如磁盘）中。</p><h2 id="缓存I-O-的优缺点"><a href="#缓存I-O-的优缺点" class="headerlink" title="缓存I/O 的优缺点"></a>缓存I/O 的优缺点</h2><p><code>缓存I/O</code> 的引入是为了减少对块设备的 I/O 操作，但是由于读写操作都先要经过缓存，然后再从缓存复制到用户空间，所以多了一次内存复制操作。如下图所示：</p><p><img src="/img/newimg/008eGmZEgy1gpb9dgsnzwj30o40jlwgc.jpg" srcset="/img/loading.gif" alt=""></p><p>所以 <code>缓存I/O</code> 的优点是减少对块设备的 I/O 操作，而缺点就是需要多一次的内存复制。另外，有些应用程序需要自己管理 I/O 缓存的（如数据库系统），那么就需要使用 <code>直接I/O</code> 了。</p><h2 id="直接I-O"><a href="#直接I-O" class="headerlink" title="直接I/O"></a>直接I/O</h2><p><code>直接I/O</code> 就是对用户进行的 I/O 操作直接与块设备进行交互，而不进行缓存。</p><ul><li><code>直接I/O</code> 的优点是：由于不对 I/O 数据块进行缓存，所以可以直接跟用户数据进行交互，减少一次内存的拷贝。</li><li><code>直接I/O</code> 的缺点是：每次 I/O 操作都直接与块设备进行交互，增加了对块设备的读写操作。</li></ul><p>但由于应用程序可以自行对数据块进行缓存，所以更加灵活，适合一些对 I/O 操作比较敏感的应用，如数据库系统。</p><h2 id="直接I-O-实现"><a href="#直接I-O-实现" class="headerlink" title="直接I/O 实现"></a>直接I/O 实现</h2><p>当调用 <code>open()</code> 系统调用时，在 <code>flags</code> 参数指定 <code>O_DIRECT</code> 标志即可使用 <code>直接I/O</code>。我们从 <code>虚拟文件系统</code> 开始跟踪 Linux 对 <code>直接I/O</code> 的处理过程。</p><p>当调用 <code>open()</code> 系统调用时，会触发调用 <code>sys_open()</code> 系统调用，我们先来看看 <code>sys_open()</code> 函数的实现：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function">asmlinkage <span class="hljs-keyword">long</span> <span class="hljs-title">sys_open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">int</span> mode)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> *tmp;<br>    <span class="hljs-keyword">int</span> fd, error;<br>    ...<br>    tmp = getname(filename); <span class="hljs-comment">// 把文件名从用户空间拷贝到内核空间</span><br>    fd = PTR_ERR(tmp);<br>    <span class="hljs-keyword">if</span> (!IS_ERR(tmp)) &#123;<br>        fd = get_unused_fd(); <span class="hljs-comment">// 申请一个还没有使用的文件描述符</span><br>        <span class="hljs-keyword">if</span> (fd &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 根据文件路径打开文件, 并获取文件对象</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span> = <span class="hljs-title">filp_open</span>(<span class="hljs-title">tmp</span>, <span class="hljs-title">flags</span>, <span class="hljs-title">mode</span>);</span><br>            error = PTR_ERR(f);<br>            <span class="hljs-keyword">if</span> (IS_ERR(f))<br>                <span class="hljs-keyword">goto</span> out_error;<br>            fd_install(fd, f); <span class="hljs-comment">// 把文件对象与文件描述符关联起来</span><br>        &#125;<br>out:<br>        putname(tmp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> fd;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>打开文件的整个流程比较复杂，但对我们分析 <code>直接I/O</code> 并没有太大关系，之前在虚拟文件系统一章已经分析过，这里就不再重复了，可以参考之前的文章：<a href="https://github.com/liexusong/linux-source-code-analyze/blob/master/virtual_file_system.md" target="_blank" rel="noopener">虚拟文件系统</a></p><p>我们主要关注的是，<code>sys_open()</code> 函数最后会调用 <code>dentry_open()</code> 把 <code>flags</code> 参数保存到文件对象的 <code>f_flags</code> 字段中，调用链：<code>sys_open() -&gt; filp_open() -&gt; dentry_open()</code>：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function">struct file *<span class="hljs-title">dentry_open</span><span class="hljs-params">(struct dentry *dentry, struct vfsmount *mnt, <span class="hljs-keyword">int</span> flags)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span><br>    ...<br>    f = get_empty_filp();<br>    f-&gt;f_flags = flags;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>也就是说，<code>sys_open()</code> 函数会打开文件，然后把 <code>flags</code> 参数保存到文件对象的 <code>f_flgas</code> 字段中。接下来，我们分析一下读文件操作时，是怎么对 <code>直接I/O</code> 进行处理的。读文件操作使用 <code>read()</code> 系统调用，而 <code>read()</code> 最终会调用内核的 <code>sys_read()</code> 函数，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function">asmlinkage ssize_t <span class="hljs-title">sys_read</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">char</span> *buf, <span class="hljs-keyword">size_t</span> count)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">ssize_t</span> ret;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span>;</span><br><br>    file = fget(fd);<br>    <span class="hljs-keyword">if</span> (file) &#123;<br>        ...<br>            <span class="hljs-keyword">if</span> (!ret) &#123;<br>                <span class="hljs-keyword">ssize_t</span> (*<span class="hljs-built_in">read</span>)(struct file *, <span class="hljs-keyword">char</span> *, <span class="hljs-keyword">size_t</span>, <span class="hljs-keyword">loff_t</span> *);<br>                ret = -EINVAL;<br>                <span class="hljs-comment">// ext2文件系统对应的是: generic_file_read() 函数</span><br>                <span class="hljs-keyword">if</span> (file-&gt;f_op &amp;&amp; (<span class="hljs-built_in">read</span> = file-&gt;f_op-&gt;<span class="hljs-built_in">read</span>) != <span class="hljs-literal">NULL</span>)<br>                    ret = <span class="hljs-built_in">read</span>(file, buf, count, &amp;file-&gt;f_pos);<br>            &#125;<br>        ...<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>由于 <code>sys_read()</code> 函数属于虚拟文件系统范畴，所以其最终会调用真实文件系统的 <code>file-&gt;f_op-&gt;read()</code> 函数，<code>ext2文件系统</code> 对应的是 <code>generic_file_read()</code> 函数，我们来分析下 <code>generic_file_read()</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">ssize_t</span> generic_file_read(struct file *filp, <span class="hljs-keyword">char</span> * buf, <span class="hljs-keyword">size_t</span> count, <span class="hljs-keyword">loff_t</span> *ppos)<br>&#123;<br>    <span class="hljs-keyword">ssize_t</span> retval;<br>    ...<br>    <span class="hljs-keyword">if</span> (filp-&gt;f_flags &amp; O_DIRECT) <span class="hljs-comment">// 如果标记了使用直接IO</span><br>        <span class="hljs-keyword">goto</span> o_direct;<br>    ...<br> o_direct:<br>    &#123;<br>        <span class="hljs-keyword">loff_t</span> pos = *ppos, <span class="hljs-built_in">size</span>;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_space</span> *<span class="hljs-title">mapping</span> = <span class="hljs-title">filp</span>-&gt;<span class="hljs-title">f_dentry</span>-&gt;<span class="hljs-title">d_inode</span>-&gt;<span class="hljs-title">i_mapping</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">inode</span> = <span class="hljs-title">mapping</span>-&gt;<span class="hljs-title">host</span>;</span><br>        ...<br>        <span class="hljs-built_in">size</span> = inode-&gt;i_size;<br>        <span class="hljs-keyword">if</span> (pos &lt; <span class="hljs-built_in">size</span>) &#123;<br>            <span class="hljs-keyword">if</span> (pos + count &gt; <span class="hljs-built_in">size</span>)<br>                count = <span class="hljs-built_in">size</span> - pos;<br>            retval = generic_file_direct_IO(READ, filp, buf, count, pos);<br>            <span class="hljs-keyword">if</span> (retval &gt; <span class="hljs-number">0</span>)<br>                *ppos = pos + retval;<br>        &#125;<br>        UPDATE_ATIME(filp-&gt;f_dentry-&gt;d_inode);<br>        <span class="hljs-keyword">goto</span> out;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>从上面代码可以看出，如果在调用 <code>open()</code> 时指定了 <code>O_DIRECT</code> 标志，那么 <code>generic_file_read()</code> 函数就会调用 <code>generic_file_direct_IO()</code> 函数对 I/O 操作进行处理。由于 <code>generic_file_direct_IO()</code> 函数的实现曲折迂回，所以下面主要分析重要部分：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> ssize_t <span class="hljs-title">generic_file_direct_IO</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rw, struct file *filp, <span class="hljs-keyword">char</span> *buf, <span class="hljs-keyword">size_t</span> count, <span class="hljs-keyword">loff_t</span> offset)</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br>    <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>        iosize = count;<br>        <span class="hljs-keyword">if</span> (iosize &gt; chunk_size)<br>            iosize = chunk_size;<br><br>        <span class="hljs-comment">// 为用户虚拟内存空间申请物理内存页</span><br>        retval = map_user_kiobuf(rw, iobuf, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)buf, iosize);<br>        <span class="hljs-keyword">if</span> (retval)<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-comment">// ext2 文件系统对应 ext2_direct_IO() 函数,</span><br>        <span class="hljs-comment">// 而 ext2_direct_IO() 函数直接调用了 generic_direct_IO() 函数</span><br>        retval = mapping-&gt;a_ops-&gt;direct_IO(rw, inode, iobuf, (offset+progress) &gt;&gt; blocksize_bits, blocksize);<br>        ...<br>    &#125;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>generic_file_direct_IO()</code> 函数主要的处理有两部分：</p><ul><li>调用 <code>map_user_kiobuf()</code> 函数为用户虚拟内存空间申请物理内存页。</li><li>调用真实文件系统的 <code>direct_IO()</code> 接口对 <code>直接I/O</code> 进行处理。</li></ul><p><code>map_user_kiobuf()</code> 函数属于内存管理部分，可以参考之前的 <a href="https://github.com/liexusong/linux-source-code-analyze/blob/master/virtual_memory_address_manager.md" target="_blank" rel="noopener">内存管理</a> 相关的文章进行分析，这里就不重复了。</p><p><code>generic_file_direct_IO()</code> 函数最终会调用真实文件系统的 <code>direct_IO()</code> 接口，对于 <code>ext2文件系统</code>，<code>direct_IO()</code> 接口对应的是 <code>ext2_direct_IO()</code> 函数，而 <code>ext2_direct_IO()</code> 函数只是简单的封装了 <code>generic_direct_IO()</code> 函数，所以我们来分析下 <code>generic_direct_IO()</code> 函数的实现：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">generic_direct_IO</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rw, struct inode *inode, struct kiobuf *iobuf,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> blocknr, <span class="hljs-keyword">int</span> blocksize, <span class="hljs-keyword">get_block_t</span> *get_block)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i, nr_blocks, retval;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *blocks = iobuf-&gt;blocks;<br><br>    nr_blocks = iobuf-&gt;length / blocksize;<br>    <span class="hljs-comment">// 获取要读取的数据块号列表</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nr_blocks; i++, blocknr++) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> <span class="hljs-title">bh</span>;</span><br><br>        bh.b_state = <span class="hljs-number">0</span>;<br>        bh.b_dev = inode-&gt;i_dev;<br>        bh.b_size = blocksize;<br><br>        retval = get_block(inode, blocknr, &amp;bh, rw == READ ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>);<br>        ...<br>        blocks[i] = bh.b_blocknr;<br>    &#125;<br><br>    <span class="hljs-comment">// 开始进行I/O操作</span><br>    retval = brw_kiovec(rw, <span class="hljs-number">1</span>, &amp;iobuf, inode-&gt;i_dev, iobuf-&gt;blocks, blocksize);<br><br> out:<br>    <span class="hljs-keyword">return</span> retval;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>generic_direct_IO()</code> 函数的逻辑也比较简单，首先调用 <code>get_block()</code> 获取要读取的数据块号列表，然后调用 <code>brw_kiovec()</code> 函数进行 I/O 操作。所以 <code>brw_kiovec()</code> 函数才是 I/O 操作的最终触发点。我们继续分析：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">brw_kiovec</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rw, <span class="hljs-keyword">int</span> nr, struct kiobuf *iovec[],</span></span><br><span class="hljs-function"><span class="hljs-params">           <span class="hljs-keyword">kdev_t</span> dev, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> b[], <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nr; i++) &#123;<br>        ...<br>        <span class="hljs-keyword">for</span> (pageind = <span class="hljs-number">0</span>; pageind &lt; iobuf-&gt;nr_pages; pageind++) &#123;<br>            <span class="hljs-built_in">map</span>  = iobuf-&gt;maplist[pageind];<br>            ...<br>            <span class="hljs-keyword">while</span> (length &gt; <span class="hljs-number">0</span>) &#123;<br>                blocknr = b[bufind++];<br>                ...<br>                tmp = bhs[bhind++];<br><br>                tmp-&gt;b_size = <span class="hljs-built_in">size</span>;<br>                set_bh_page(tmp, <span class="hljs-built_in">map</span>, offset); <span class="hljs-comment">// 设置保存I/O操作后的数据的内存地址 (用户空间的内存)</span><br>                tmp-&gt;b_this_page = tmp;<br><br>                init_buffer(tmp, end_buffer_io_kiobuf, iobuf); <span class="hljs-comment">// 设置完成I/O后的收尾工作回调函数为: end_buffer_io_kiobuf()</span><br>                tmp-&gt;b_dev = dev;<br>                tmp-&gt;b_blocknr = blocknr;<br>                tmp-&gt;b_state = (<span class="hljs-number">1</span> &lt;&lt; BH_Mapped) | (<span class="hljs-number">1</span> &lt;&lt; BH_Lock) | (<span class="hljs-number">1</span> &lt;&lt; BH_Req);<br>                ...<br>                submit_bh(rw, tmp); <span class="hljs-comment">// 提交 I/O 操作 (通用块I/O层)</span><br><br>                <span class="hljs-keyword">if</span> (bhind &gt;= KIO_MAX_SECTORS) &#123;<br>                    kiobuf_wait_for_io(iobuf);<br>                    err = wait_kio(rw, bhind, bhs, <span class="hljs-built_in">size</span>);<br>                    ...<br>                &#125;<br><br>            skip_block:<br>                length -= <span class="hljs-built_in">size</span>;<br>                offset += <span class="hljs-built_in">size</span>;<br><br>                <span class="hljs-keyword">if</span> (offset &gt;= PAGE_SIZE) &#123;<br>                    offset = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125; <span class="hljs-comment">/* End of block loop */</span><br>        &#125; <span class="hljs-comment">/* End of page loop */</span><br>    &#125; <span class="hljs-comment">/* End of iovec loop */</span><br>    ...<br>    <span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>brw_kiovec()</code> 函数主要完成 3 个工作：</p><ul><li>设置用于保存 I/O 操作后的数据的内存地址 (用户申请的内存)。</li><li>设置 I/O 操作完成后的收尾回调函数为: end_buffer_io_kiobuf()。</li><li>提交 I/O 操作到通用块层。</li></ul><p>可以看出，对于 I/O 操作后的数据会直接保存到用户空间的内存，而没有通过内核缓存作为中转，从而达到 <code>直接I/O</code> 的目的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Netfilter 与 iptables 原理</title>
    <link href="/2021/04/07/Netfilter-%E4%B8%8E-iptables-%E5%8E%9F%E7%90%86/"/>
    <url>/2021/04/07/Netfilter-%E4%B8%8E-iptables-%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Netfilter-与-iptables-原理"><a href="#Netfilter-与-iptables-原理" class="headerlink" title="Netfilter 与 iptables 原理"></a>Netfilter 与 iptables 原理</h1><p><code>Netfilter</code> 可能了解的人比较少，但是 <code>iptables</code> 用过 Linux 的都应该知道。本文主要介绍 <code>Netfilter</code> 与 <code>iptables</code> 的原理，而下一篇将会介绍 <code>Netfilter</code> 与 <code>iptables</code> 的实现。</p><h2 id="什么是-Netfilter"><a href="#什么是-Netfilter" class="headerlink" title="什么是 Netfilter"></a>什么是 Netfilter</h2><p><code>Netfilter</code> 顾名思义就是网络过滤器，其主要功能就是对进出内核协议栈的数据包进行过滤或者修改，有名的 <code>iptables</code> 就是建立在 <code>Netfilter</code> 之上。</p><p><code>Netfilter</code> 通过向内核协议栈中不同的位置注册 <code>钩子函数（Hooks）</code> 来对数据包进行过滤或者修改操作，这些位置称为 <code>挂载点</code>，主要有 5 个：<code>PRE_ROUTING</code>、<code>LOCAL_IN</code>、<code>FORWARD</code>、<code>LOCAL_OUT</code> 和 <code>POST_ROUTING</code>，如下图所示：</p><p><img src="/img/newimg/008eGmZEgy1gpb8zqdc1cj311g0b0wg5.jpg" srcset="/img/loading.gif" alt=""></p><p>这 5 个 <code>挂载点</code> 的意义如下：</p><ul><li><p><code>PRE_ROUTING</code>：路由前。数据包进入IP层后，但还没有对数据包进行路由判定前。</p></li><li><p><code>LOCAL_IN</code>：进入本地。对数据包进行路由判定后，如果数据包是发送给本地的，在上送数据包给上层协议前。</p></li><li><p><code>FORWARD</code>：转发。对数据包进行路由判定后，如果数据包不是发送给本地的，在转发数据包出去前。</p></li><li><p><code>LOCAL_OUT</code>：本地输出。对于输出的数据包，在没有对数据包进行路由判定前。</p></li><li><p><code>POST_ROUTING</code>：路由后。对于输出的数据包，在对数据包进行路由判定后。</p></li></ul><p>从上图可以看出，路由判定是数据流向的关键点。</p><ul><li><p>第一个路由判定通过查找输入数据包 <code>IP头部</code> 的目的 <code>IP地址</code> 是否为本机的 <code>IP地址</code>，如果是本机的 <code>IP地址</code>，说明数据是发送给本机的。否则说明数据包是发送给其他主机，经过本机只是进行中转。</p></li><li><p>第二个路由判定根据输出数据包 <code>IP头部</code> 的目的 <code>IP地址</code> 从路由表中查找对应的路由信息，然后根据路由信息获取下一跳主机（或网关）的 <code>IP地址</code>，然后进行数据传输。</p></li></ul><p>通过向这些 <code>挂载点</code> 注册钩子函数，就能够对处于不同阶段的数据包进行过滤或者修改操作。由于钩子函数能够注册多个，所以内核使用链表来保存这些钩子函数，如下图所示：</p><p><img src="/img/newimg/008eGmZEgy1gpb8zve72cj30jm07lwf7.jpg" srcset="/img/loading.gif" alt=""></p><p>如上图所示，当数据包进入本地（<code>LOCAL_IN</code> 挂载点）时，就会相继调用 <code>ipt_hook</code> 和 <code>fw_confirm</code> 钩子函数来处理数据包。另外，钩子函数还有优先级，优先级越小越先执行。</p><p>正因为挂载点是通过链表来存储钩子函数，所以挂载点又被称为 <code>链</code>，挂载点对应的链名称如下所示：</p><ul><li><p><code>LOCAL_IN</code> 挂载点：又称为 <code>INPUT链</code>。</p></li><li><p><code>LOCAL_OUT</code> 挂载点：又称为 <code>OUTPUT链</code>。</p></li><li><p><code>FORWARD</code> 挂载点：又称为 <code>PORWARD链</code>。</p></li><li><p><code>PRE_ROUTING</code> 挂载点：又称为 <code>PREROUTING链</code>。</p></li><li><p><code>POST_ROUTING</code> 挂载点：又称为 <code>POSTOUTING链</code>。</p></li></ul><h2 id="什么是-iptables"><a href="#什么是-iptables" class="headerlink" title="什么是 iptables"></a>什么是 iptables</h2><p><code>iptables</code> 是建立在 <code>Netfilter</code> 之上的数据包过滤器，也就是说，<code>iptables</code> 通过向 <code>Netfilter</code> 的挂载点上注册钩子函数来实现对数据包过滤的。<code>iptables</code> 的实现比较复杂，所以先要慢慢介绍一下它的一些基本概念。</p><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><p>从 <code>iptables</code> 这个名字可以看出，它一定包含了 <code>表</code> 这个概念。<code>表</code> 是指一系列规则，可以看成是规则表。<code>iptables</code> 通过把这些规则表挂载在 <code>Netfilter</code> 的不同链上，对进出内核协议栈的数据包进行过滤或者修改操作。</p><p><code>iptables</code> 定义了 4 种表，每种表都有其不同的用途：</p><p><strong>1. Filter表</strong></p><p><code>Filter表</code> 用于过滤数据包。是 <code>iptables</code> 的默认表，因此如果你配置规则时没有指定表，那么就默认使用 <code>Filter表</code>，它分别挂载在以下 3 个链上：</p><ul><li><code>INPUT链</code></li><li><code>OUTPUT链</code></li><li><code>PORWARD链</code></li></ul><p><strong>2. NAT表</strong></p><p><code>NAT表</code> 用于对数据包的网络地址转换(IP、端口)，它分别挂载在以下 3 个链上：</p><ul><li><code>PREROUTING链</code></li><li><code>POSTOUTING链</code></li><li><code>OUTPUT链</code></li></ul><p><strong>3. Mangle表</strong></p><p><code>Mangle表</code> 用于修改数据包的服务类型或TTL，并且可以配置路由实现QOS，它分别挂载在以下 5 个链上：</p><ul><li><code>PREROUTING链</code></li><li><code>INPUT链</code></li><li><code>PORWARD链</code></li><li><code>OUTPUT链</code></li><li><code>POSTOUTING链</code></li></ul><p><strong>4. Raw表</strong></p><p><code>Raw表</code> 用于判定数据包是否被状态跟踪处理，它分别挂载在以下 2 个链上：</p><ul><li><code>PREROUTING链</code></li><li><code>OUTPUT链</code></li></ul><p>我们通过下图来展示各个表所挂载的链：</p><p><img src="/img/newimg/008eGmZEgy1gpb9047qwej311g0fjtb9.jpg" srcset="/img/loading.gif" alt=""></p><p>上图展示了，数据包从网络中进入到内核协议栈的过程中，要执行的 <code>iptables</code> 规则，如果在执行某条 <code>iptables</code> 规则失败后，会直接把数据包丢弃，不会继续执行下面的规则。</p><p>拿其中一个链来看，如下图所示：</p><p><img src="/img/newimg/008eGmZEgy1gpb907tvhsj30eh0jv0ti.jpg" srcset="/img/loading.gif" alt=""></p><p>也就是说，当数据包从网络中进入到内核协议栈后，在路由判定前会分别执行 <code>Raw表</code>、<code>Mangle表</code> 和 <code>NAT表</code> 中的规则。如果在执行规则时，某一条规则拒绝了数据包，那么数据包便会被丢弃，从而不会继续执行下面的规则。</p><h2 id="添加-iptables-规则"><a href="#添加-iptables-规则" class="headerlink" title="添加 iptables 规则"></a>添加 iptables 规则</h2><p>上面介绍了 <code>iptables</code> 的原理，下面主要介绍怎么向 <code>iptables</code> 中添加规则。要向 <code>iptables</code> 中添加规则，可以使用 <code>iptables</code> 命令，其使用格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">iptables [选项 参数] ...<br></code></pre></div></td></tr></table></figure><p>可选的选项如下：</p><figure class="highlight diff"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-t &lt;表&gt;：指定要操纵的表；</span><br><span class="hljs-deletion">-A &lt;链&gt;：向规则链中添加条目；</span><br><span class="hljs-deletion">-D &lt;链&gt;：从规则链中删除条目；</span><br><span class="hljs-deletion">-I &lt;链&gt;：向规则链中插入条目；</span><br><span class="hljs-deletion">-R &lt;链&gt;：替换规则链中的条目；</span><br><span class="hljs-deletion">-L：显示规则链中已有的条目；</span><br><span class="hljs-deletion">-F：清楚规则链中已有的条目；</span><br><span class="hljs-deletion">-Z：清空规则链中的数据包计算器和字节计数器；</span><br><span class="hljs-deletion">-N：创建新的用户自定义规则链；</span><br><span class="hljs-deletion">-P：定义规则链中的默认目标；</span><br><span class="hljs-deletion">-h：显示帮助信息；</span><br><span class="hljs-deletion">-p：指定要匹配的数据包协议类型；</span><br><span class="hljs-deletion">-s：指定要匹配的数据包源ip地址；</span><br><span class="hljs-deletion">-j &lt;动作&gt;：指定要进行的动作行为；</span><br><span class="hljs-deletion">-i &lt;网络接口&gt;：指定数据包进入本机的网络接口；</span><br><span class="hljs-deletion">-o &lt;网络接口&gt;：指定数据包要离开本机所使用的网络接口。</span><br><span class="hljs-deletion">--dport &lt;端口&gt;：匹配目标端口号。</span><br><span class="hljs-deletion">--sport &lt;端口&gt;：匹配来源端口号。</span><br></code></pre></div></td></tr></table></figure><p><code>iptables</code> 规则的选项比较多，一般来说，一条 <code>iptables</code> 规则主要由四个部分组成，如下图所示：</p><p><img src="/img/newimg/008eGmZEgy1gpb90ga6tzj30fv01pglh.jpg" srcset="/img/loading.gif" alt=""></p><ul><li><p>第一部分可以通过 <code>-t</code> 选项来指定操作的表，如 <code>filter</code>、<code>nat</code>、<code>mangle</code> 或 <code>raw</code>。</p></li><li><p>第二部分可以通过 <code>-A</code>、<code>-D</code>、<code>-I</code> 或 <code>-R</code> 选项来指定操作的链，如 <code>INPUT</code>、<code>OUTPUT</code>、<code>FORWARD</code>、<code>PREROUTING</code> 或 <code>POSTOUTING</code>。</p></li><li><p>第三部分主要设置规则的匹配条件，如匹配源IP地址或者端口等。</p></li><li><p>第四部分主要设置规则匹配成功后进行的动作，如接收或拒绝等。</p></li></ul><p>第一和第二部分比较简单，我们详细介绍一下第三和第四部分。</p><h3 id="匹配条件"><a href="#匹配条件" class="headerlink" title="匹配条件"></a>匹配条件</h3><p><code>匹配条件</code> 分为 <code>基本匹配条件</code> 与 <code>扩展匹配条件</code>，基本匹配条件包括 <code>源IP地址</code> 和 <code>目标IP地址</code> 等，扩展匹配条件包括 <code>源端口</code> 和 <code>目标端口</code> 等。</p><h3 id="处理动作"><a href="#处理动作" class="headerlink" title="处理动作"></a>处理动作</h3><p><code>处理动作</code> 是指当匹配条件成功后要进行的一系列操作过程，动作也可以分为 <code>基本动作</code> 和 <code>扩展动作</code>。</p><p>此处列出一些常用的动作：</p><ul><li><p><code>ACCEPT</code>：允许数据包通过。</p></li><li><p><code>DROP</code>：直接丢弃数据包，不给任何回应信息。</p></li><li><p><code>REJECT</code>：拒绝数据包通过，必要时会给数据发送端一个响应的信息，客户端刚请求就会收到拒绝的信息。</p></li><li><p><code>SNAT</code>：源IP地址转换。</p></li><li><p><code>MASQUERADE</code>：是SNAT的一种特殊形式，适用于动态IP上。</p></li><li><p><code>DNAT</code>：目标IP地址转换。</p></li><li><p><code>REDIRECT</code>：在本机做端口映射。</p></li><li><p><code>LOG</code>：在 <code>/var/log/messages</code> 文件中记录日志信息，然后将数据包传递给下一条规则，也就是说除了记录以外不对数据包做任何其他操作，仍然让下一条规则去匹配。</p></li></ul><p>下面我们通过几个简单的例子来阐明 <code>iptables</code> 命令的使用：</p><p><strong>1. 允许本地回环接口(即运行本机访问本机)</strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">iptables -A INPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT  # 不指定表名时, 默认为filter表<br></code></pre></div></td></tr></table></figure><p><strong>2. 允许访问80端口</strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">iptables -A INPUT -p tcp --dport 80 -j ACCEPT<br></code></pre></div></td></tr></table></figure><p><strong>3. 禁止数据转发</strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">iptables -A FORWARD -j REJECT<br></code></pre></div></td></tr></table></figure><p><strong>4. 禁止IP段访问</strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">iptables -I INPUT -s 124.45.0.0/16 -j DROP   # 禁止IP段从123.45.0.1到123.45.255.254访问<br></code></pre></div></td></tr></table></figure><p><strong>5. 查看已添加的 iptables 规则</strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">iptables -L -n -v<br></code></pre></div></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了 <code>Netfilter</code> 与 <code>iptables</code> 的原理，并且还介绍了 <code>iptables</code> 命令的简单使用。由于 <code>iptables</code> 是一个复杂的系统，所以本文不能完整的介绍其所有功能，有兴趣的可以继续查阅其他相关的资料。</p><p>下一篇文章我们将会介绍 <code>Netfilter</code> 和 <code>iptables</code> 的实现过程。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是linux内核的零拷贝技术</title>
    <link href="/2021/04/07/%E4%BB%80%E4%B9%88%E6%98%AFlinux%E5%86%85%E6%A0%B8%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/"/>
    <url>/2021/04/07/%E4%BB%80%E4%B9%88%E6%98%AFlinux%E5%86%85%E6%A0%B8%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<p><code>零拷贝技术</code> 是编写高性能服务器的一个关键技术，在介绍 <code>零拷贝技术</code> 前先说明一下 <code>用户空间</code> 与 <code>内核空间</code>。</p><h2 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h2><p>通俗的说，<code>用户空间</code>就是运行着用户编写的应用程序的虚拟内存空间。在32位的操作系统中，每个进程都有 4GB 独立的虚拟内存空间，而 0 ~ 3GB 的虚拟内存空间就是用户空间 。</p><h2 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h2><p><code>内核空间</code> 就是运行着操作系统代码的虚拟内存空间，而 3GB ~ 4GB 的虚拟内存空间就是内核空间。</p><p>图 1 展示了 <code>用户空间</code> 与 <code>内核空间</code> 在进程虚拟内存空间所在的位置：<br><img src="/img/newimg/008eGmZEgy1gpb723axkhj308h0ca3yi.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="发送文件"><a href="#发送文件" class="headerlink" title="发送文件"></a>发送文件</h2><p>为什么要介绍 <code>用户空间</code> 和 <code>内核空间</code> 呢？</p><p>我们先来回忆一下，服务端发送一个文件给客户端一般需要进行什么操作。一般来说，服务端发送一个文件给客户端的步骤如下：</p><p>首先需要调用 read 读取文件的数据到用户空间缓冲区中。</p><p>然后再调用 write 把缓冲区的数据发送给客户端 Socket。</p><p>伪代码如下：</p><figure class="highlight applescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs applescript"><span class="hljs-keyword">while</span> ((n = <span class="hljs-built_in">read</span>(<span class="hljs-built_in">file</span>, buf, <span class="hljs-number">4069</span>)) &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">write</span>(sock, buf , n);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在上面的过程中，调用了 <code>read</code> 和 <code>write</code> 两个系统调用。<code>read</code> 系统调用是从文件中读取数据到用户空间的缓冲区中，所以调用 <code>read</code> 时需要从内核空间复制数据到用户空间，如图 2 所示：<br><img src="/img/newimg/008eGmZEgy1gpb73a0wbpj30i00aj3yp.jpg" srcset="/img/loading.gif" alt=""></p><p>图2 就是数据的复制过程，首先会从文件中读取数据到内核的 页缓存（page cache），然后再从页缓存中复制到用户空间的缓冲区中。</p><p>而当调用 <code>write</code> 系统调用把用户空间缓冲区中的数据发送到客户端 Socket 时，首先会把缓冲区的数据复制到内核的 Socket 缓冲区中，网卡驱动会把 Socket 缓冲区的数据发送出去，如图 3 所示：<br><img src="/img/newimg/008eGmZEgy1gpb73ztbllj30hw0bt3z0.jpg" srcset="/img/loading.gif" alt=""></p><p>从上图可以看出，服务端发送文件给客户端的过程中需要进行两次数据复制，第一次是从内核空间的页缓存复制到用户空间的缓冲区，第二次是从用户空间的缓冲区复制到内核空间的 Socket 缓冲区。</p><p>仔细观察我们可以发现，上图中的页缓存其实可以直接复制到 Socket 缓冲区，而不需要复制到用户空间缓冲区的。如图 4 所示：<br><img src="/img/newimg/008eGmZEgy1gpb74cezj9j30ia08bt8z.jpg" srcset="/img/loading.gif" alt=""></p><p>如上图所示，不需要用户空间作为数据中转的技术叫 零拷贝技术。那么，我们可以通过哪个系统调用来实现上图中的技术呢？答案就是 sendfile，我们来看看 sendfile 系统调用的原型：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/sendfile.h&gt;</span></span><br><br><span class="hljs-keyword">ssize_t</span> sendfile(<span class="hljs-keyword">int</span> out_fd, <span class="hljs-keyword">int</span> in_fd, <span class="hljs-keyword">off_t</span> *offset, <span class="hljs-keyword">size_t</span> count);<br></code></pre></div></td></tr></table></figure><p>下面介绍一下 sendfile 各个参数的作用：</p><blockquote><p>out_fd：数据接收方文件句柄（一般为 Socket 句柄）。<br>in_fd：数据提供方文件句柄（一般为文件句柄）。<br>offset：如果 offset 不为 NULL，表示从哪里开始发送数据的偏移量。<br>count：表示需要发送多少字节的数据。</p></blockquote><p>sendfile 发送数据的过程如图 5 所示：<br><img src="/img/newimg/008eGmZEgy1gpb75ev649j30if0ahaag.jpg" srcset="/img/loading.gif" alt=""><br>对比图 5 与 图 3，我们发现使用 <code>sendfile</code> 可以减少一次系统调用，并且减少一次数据拷贝过程。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要通过 <code>sendfile</code> 系统调用来介绍 <code>零拷贝技术</code>，但 零拷贝技术 不单只有 <code>sendfile</code>，如 <code>mmap</code>、<code>splice</code> 和 <code>直接I/O</code> 等都是 <code>零拷贝技术</code> 的实现，有兴趣的可以参考 Linux 官方文档或相关资料。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>境界</title>
    <link href="/2021/01/26/%E5%A2%83%E7%95%8C/"/>
    <url>/2021/01/26/%E5%A2%83%E7%95%8C/</url>
    
    <content type="html"><![CDATA[<p>《五灯会元》卷十七中，有一则唐朝禅师青原惟信禅师的语录:“老僧三十年前未参禅时，见山是山，见水是水。及至后来亲见知识，有个入处，见山不是山，见水不是水。而今得个休歇处，依前见山只是山，见水只是水。”</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ Golang之HelloWorld</title>
    <link href="/2021/01/08/RabbitMQ-Golang%E4%B9%8BHelloWorld/"/>
    <url>/2021/01/08/RabbitMQ-Golang%E4%B9%8BHelloWorld/</url>
    
    <content type="html"><![CDATA[<p>本文翻译自RabbitMQ官网的Go语言客户端系列教程，共分为六篇，本文是第一篇——HelloWorld。</p><p>这些教程涵盖了使用RabbitMQ创建消息传递应用程序的基础知识。 你需要安装RabbitMQ服务器才能完成这些教程，请参阅安装指南或使用Docker镜像。 这些教程的代码是开源的，官方网站也是如此。</p><h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件 "></a><center>先决条件 </center></h3><p>本教程假设RabbitMQ已安装并运行在本机上的标准端口（5672）。如果你使用不同的主机、端口或凭据，则需要调整连接设置。</p><h3 id="RabbitMQ-Go语言客户端教程（一）"><a href="#RabbitMQ-Go语言客户端教程（一）" class="headerlink" title="RabbitMQ Go语言客户端教程（一） "></a><center>RabbitMQ Go语言客户端教程（一） </center></h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>RabbitMQ是一个消息代理：它接受并转发消息。你可以把它想象成一个邮局：当你把你想要邮寄的邮件放进一个邮箱时，你可以确定邮差先生或女士最终会把邮件送到你的收件人那里。在这个比喻中，RabbitMQ是一个邮箱、一个邮局和一个邮递员。</p><p>RabbitMQ和邮局的主要区别在于它不处理纸张，而是接受、存储和转发二进制数据块——消息。</p><p>RabbitMQ和一般的消息传递都使用一些术语。</p><blockquote><p>生产仅意味着发送。发送消息的程序是生产者：<br><img src="/img/newimg/008eGmZEgy1gmgnk1d1gnj301z01fdfl.jpg" srcset="/img/loading.gif" alt=""></p></blockquote><blockquote><p>队列是位于RabbitMQ内部的邮箱的名称。尽管消息通过RabbitMQ和你的应用程序流动，但它们只能存储在队列中。队列只受主机内存和磁盘限制的限制，实际上它是一个大的消息缓冲区。许多生产者可以向一个队列发送消息，而许多消费者可以尝试从一个队列接收数据。以下是我们表示队列的方式：</p></blockquote><p><img src="/img/newimg/008eGmZEgy1gmgnk9o4loj303m02j0ol.jpg" srcset="/img/loading.gif" alt=""></p><blockquote><p>消费与接收具有相似的含义。消费者是一个主要等待接收消息的程序：<br><img src="/img/newimg/008eGmZEgy1gmgnki4ehmj301z01fjr5.jpg" srcset="/img/loading.gif" alt=""><br>请注意，生产者，消费者和代理（broker）不必位于同一主机上。实际上，在大多数应用程序中它们不是。一个应用程序既可以是生产者，也可以是消费者。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Golang黑科技之——string与[]byte转换</title>
    <link href="/2021/01/07/Golang%E9%BB%91%E7%A7%91%E6%8A%80%E4%B9%8B%E2%80%94%E2%80%94string%E4%B8%8E-byte%E8%BD%AC%E6%8D%A2/"/>
    <url>/2021/01/07/Golang%E9%BB%91%E7%A7%91%E6%8A%80%E4%B9%8B%E2%80%94%E2%80%94string%E4%B8%8E-byte%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>我们知道，相对于C语言，golang是类型安全的语言。但是安全的代价就是性能的妥协。<br>下面我们通过Golang中的“黑科技”来一窥Golang不想让我们看到的“秘密”——string的底层数据。<br>通过reflect包，我们可以知道，在Golang底层，string和slice其实都是struct：</p><figure class="highlight elm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">SliceHeader</span> struct &#123;<br><span class="hljs-type">Data</span> uintptr<br><span class="hljs-type">Len</span>  int<br><span class="hljs-type">Cap</span>  int<br>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-type">StringHeader</span> struct &#123;<br><span class="hljs-type">Data</span> uintptr<br><span class="hljs-type">Len</span>  int<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中Data是一个指针，指向实际的数据地址，Len表示数据长度。<br>但是，在string和[]byte转换过程中，Golang究竟悄悄帮我们做了什么，来达到安全的目的？<br>在Golang语言规范里面，string数据是禁止修改的，试图通过&amp;s[0], &amp;b[0]取得string和slice数据指针地址也是不能通过编译的。<br>下面，我们就通过Golang的“黑科技”来一窥Golang背后的“秘密”。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">//return GoString's buffer slice(enable modify string)</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StringBytes</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">Bytes</span></span> &#123;<br><span class="hljs-keyword">var</span> bh reflect.SliceHeader<br>sh := (*reflect.StringHeader)(unsafe.Pointer(&amp;s))<br>bh.Data, bh.Len, bh.Cap = sh.Data, sh.Len, sh.Len<br><span class="hljs-keyword">return</span> *(*Bytes)(unsafe.Pointer(&amp;bh))<br>&#125;<br><br><span class="hljs-comment">// convert b to string without copy</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BytesString</span><span class="hljs-params">(b []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">String</span></span> &#123;<br><span class="hljs-keyword">return</span> *(*String)(unsafe.Pointer(&amp;b))<br>&#125;<br><br><span class="hljs-comment">// returns &amp;s[0], which is not allowed in go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StringPointer</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">unsafe</span>.<span class="hljs-title">Pointer</span></span> &#123;<br>p := (*reflect.StringHeader)(unsafe.Pointer(&amp;s))<br><span class="hljs-keyword">return</span> unsafe.Pointer(p.Data)<br>&#125;<br><br><span class="hljs-comment">// returns &amp;b[0], which is not allowed in go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BytesPointer</span><span class="hljs-params">(b []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">unsafe</span>.<span class="hljs-title">Pointer</span></span> &#123;<br>p := (*reflect.SliceHeader)(unsafe.Pointer(&amp;b))<br><span class="hljs-keyword">return</span> unsafe.Pointer(p.Data)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>以上4个函数的神奇之处在于，通过unsafe.Pointer和reflect.XXXHeader取到了数据首地址，并实现了string和[]byte的直接转换（这些操作在语言层面是禁止的）。<br>下面我们就通过这几个“黑科技”来测试一下语言底层的秘密：</p><figure class="highlight x86asm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs x86asm">func TestPointer(t *testing<span class="hljs-number">.</span>T) &#123;<br>s := []string&#123;<br><span class="hljs-string">""</span>,<br><span class="hljs-string">""</span>,<br><span class="hljs-string">"hello"</span>,<br><span class="hljs-string">"hello"</span>,<br>fmt<span class="hljs-number">.</span>Sprintf(<span class="hljs-string">""</span>),<br>fmt<span class="hljs-number">.</span>Sprintf(<span class="hljs-string">""</span>),<br>fmt<span class="hljs-number">.</span>Sprintf(<span class="hljs-string">"hello"</span>),<br>fmt<span class="hljs-number">.</span>Sprintf(<span class="hljs-string">"hello"</span>),<br>&#125;<br>fmt<span class="hljs-number">.</span>Println(<span class="hljs-string">"String to bytes:"</span>)<br>for i, v := range s &#123;<br>b := unsafe<span class="hljs-number">.</span>StringBytes(v)<br>b2 := []<span class="hljs-built_in">byte</span>(v)<br>if b<span class="hljs-number">.</span>Writeable() &#123;<br>b[<span class="hljs-number">0</span>] = <span class="hljs-string">'x'</span><br>&#125;<br>fmt<span class="hljs-number">.</span>Printf(<span class="hljs-string">"%d\ts=%5s\tptr(v)=%-12v\tptr(StringBytes(v)=%-12v\tptr([]byte(v)=%-12v\n"</span>,<br>i, v, unsafe<span class="hljs-number">.</span>StringPointer(v), b<span class="hljs-number">.</span>Pointer(), unsafe<span class="hljs-number">.</span>BytesPointer(b2))<br>&#125;<br><br>b := [][]<span class="hljs-built_in">byte</span>&#123;<br>[]<span class="hljs-built_in">byte</span>&#123;&#125;,<br>[]<span class="hljs-built_in">byte</span>&#123;<span class="hljs-string">'h'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'l'</span>, <span class="hljs-string">'l'</span>, <span class="hljs-string">'o'</span>&#125;,<br>&#125;<br>fmt<span class="hljs-number">.</span>Println(<span class="hljs-string">"Bytes to string:"</span>)<br>for i, v := range b &#123;<br>s1 := unsafe<span class="hljs-number">.</span>BytesString(v)<br>s2 := string(v)<br>fmt<span class="hljs-number">.</span>Printf(<span class="hljs-string">"%d\ts=%5s\tptr(v)=%-12v\tptr(StringBytes(v)=%-12v\tptr(string(v)=%-12v\n"</span>,<br>i, s1, unsafe<span class="hljs-number">.</span>BytesPointer(v), s1<span class="hljs-number">.</span>Pointer(), unsafe<span class="hljs-number">.</span>StringPointer(s2))<br>&#125;<br><br>&#125;<br><br>const N = <span class="hljs-number">3000000</span><br><br>func Benchmark_Normal(b *testing<span class="hljs-number">.</span>B) &#123;<br>for i := <span class="hljs-number">1</span><span class="hljs-comment">; i &lt; N; i++ &#123;</span><br>s := fmt<span class="hljs-number">.</span>Sprintf(<span class="hljs-string">"12345678901234567890123456789012345678901234567890"</span>)<br>bb := []<span class="hljs-built_in">byte</span>(s)<br>bb[<span class="hljs-number">0</span>] = <span class="hljs-string">'x'</span><br>s = string(bb)<br>s = s<br>&#125;<br>&#125;<br>func Benchmark_Direct(b *testing<span class="hljs-number">.</span>B) &#123;<br>for i := <span class="hljs-number">1</span><span class="hljs-comment">; i &lt; N; i++ &#123;</span><br>s := fmt<span class="hljs-number">.</span>Sprintf(<span class="hljs-string">"12345678901234567890123456789012345678901234567890"</span>)<br>bb := unsafe<span class="hljs-number">.</span>StringBytes(s)<br>bb[<span class="hljs-number">0</span>] = <span class="hljs-string">'x'</span><br>s = s<br>&#125;<br>&#125;<br><br>//<span class="hljs-keyword">test</span> result<br>//String to bytes:<br>//<span class="hljs-number">0</span>s=     <span class="hljs-built_in">ptr</span>(v)=<span class="hljs-number">0x51bd70</span>    <span class="hljs-built_in">ptr</span>(StringBytes(v)=<span class="hljs-number">0x51bd70</span>    <span class="hljs-built_in">ptr</span>([]<span class="hljs-built_in">byte</span>(v)=<span class="hljs-number">0xc042021c58</span><br>//<span class="hljs-number">1</span>s=     <span class="hljs-built_in">ptr</span>(v)=<span class="hljs-number">0x51bd70</span>    <span class="hljs-built_in">ptr</span>(StringBytes(v)=<span class="hljs-number">0x51bd70</span>    <span class="hljs-built_in">ptr</span>([]<span class="hljs-built_in">byte</span>(v)=<span class="hljs-number">0xc042021c58</span><br>//<span class="hljs-number">2</span>s=hello<span class="hljs-built_in">ptr</span>(v)=<span class="hljs-number">0x51c2fa</span>    <span class="hljs-built_in">ptr</span>(StringBytes(v)=<span class="hljs-number">0x51c2fa</span>    <span class="hljs-built_in">ptr</span>([]<span class="hljs-built_in">byte</span>(v)=<span class="hljs-number">0xc042021c58</span><br>//<span class="hljs-number">3</span>s=hello<span class="hljs-built_in">ptr</span>(v)=<span class="hljs-number">0x51c2fa</span>    <span class="hljs-built_in">ptr</span>(StringBytes(v)=<span class="hljs-number">0x51c2fa</span>    <span class="hljs-built_in">ptr</span>([]<span class="hljs-built_in">byte</span>(v)=<span class="hljs-number">0xc042021c58</span><br>//<span class="hljs-number">4</span>s=     <span class="hljs-built_in">ptr</span>(v)=&lt;nil&gt;       <span class="hljs-built_in">ptr</span>(StringBytes(v)=&lt;nil&gt;       <span class="hljs-built_in">ptr</span>([]<span class="hljs-built_in">byte</span>(v)=<span class="hljs-number">0xc042021c58</span><br>//<span class="hljs-number">5</span>s=     <span class="hljs-built_in">ptr</span>(v)=&lt;nil&gt;       <span class="hljs-built_in">ptr</span>(StringBytes(v)=&lt;nil&gt;       <span class="hljs-built_in">ptr</span>([]<span class="hljs-built_in">byte</span>(v)=<span class="hljs-number">0xc042021c58</span><br>//<span class="hljs-number">6</span>s=xello<span class="hljs-built_in">ptr</span>(v)=<span class="hljs-number">0xc0420444b5</span><span class="hljs-built_in">ptr</span>(StringBytes(v)=<span class="hljs-number">0xc0420444b5</span><span class="hljs-built_in">ptr</span>([]<span class="hljs-built_in">byte</span>(v)=<span class="hljs-number">0xc042021c58</span><br>//<span class="hljs-number">7</span>s=xello<span class="hljs-built_in">ptr</span>(v)=<span class="hljs-number">0xc0420444ba</span><span class="hljs-built_in">ptr</span>(StringBytes(v)=<span class="hljs-number">0xc0420444ba</span><span class="hljs-built_in">ptr</span>([]<span class="hljs-built_in">byte</span>(v)=<span class="hljs-number">0xc042021c58</span><br>//Bytes to string:<br>//<span class="hljs-number">0</span>s=     <span class="hljs-built_in">ptr</span>(v)=<span class="hljs-number">0x5c38b8</span>    <span class="hljs-built_in">ptr</span>(StringBytes(v)=<span class="hljs-number">0x5c38b8</span>    <span class="hljs-built_in">ptr</span>(string(v)=&lt;nil&gt;<br>//<span class="hljs-number">1</span>s=hello<span class="hljs-built_in">ptr</span>(v)=<span class="hljs-number">0xc0420445e0</span><span class="hljs-built_in">ptr</span>(StringBytes(v)=<span class="hljs-number">0xc0420445e0</span><span class="hljs-built_in">ptr</span>(string(v)=<span class="hljs-number">0xc042021c38</span><br>//Benchmark_Normal-<span class="hljs-number">4</span>   <span class="hljs-number">1000000000</span>         <span class="hljs-number">0.87</span> ns/op<br>//Benchmark_Direct-<span class="hljs-number">4</span>   <span class="hljs-number">2000000000</span>         <span class="hljs-number">0.24</span> ns/op<br></code></pre></div></td></tr></table></figure><p>结论如下：</p><p>1.string常量会在编译期分配到只读段，对应数据地址不可写入，并且相同的string常量不会重复存储。<br>2.fmt.Sprintf生成的字符串分配在堆上，对应数据地址可修改。<br>3.常量空字符串有数据地址，动态生成的字符串没有设置数据地址<br>4.Golang string和[]byte转换,会将数据复制到堆上，返回数据指向复制的数据<br>5.动态生成的字符串，即使内容一样，数据也是在不同的空间<br>6.只有动态生成的string，数据可以被黑科技修改<br>8.string和[]byte通过复制转换，性能损失接近4倍</p>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一条命令搞定 github clone 慢的问题</title>
    <link href="/2020/12/27/%E4%B8%80%E6%9D%A1%E5%91%BD%E4%BB%A4%E6%90%9E%E5%AE%9A-github-clone-%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2020/12/27/%E4%B8%80%E6%9D%A1%E5%91%BD%E4%BB%A4%E6%90%9E%E5%AE%9A-github-clone-%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">git config <span class="hljs-params">--global</span> url.<span class="hljs-string">"https://github.com/"</span><span class="hljs-string">.insteadOf</span> https:<span class="hljs-string">//github.com.cnpmjs.org/</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>etcd 集群恢复</title>
    <link href="/2020/12/24/etcd-%E9%9B%86%E7%BE%A4%E6%81%A2%E5%A4%8D/"/>
    <url>/2020/12/24/etcd-%E9%9B%86%E7%BE%A4%E6%81%A2%E5%A4%8D/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>etcd  v3集群搭建</title>
    <link href="/2020/12/24/etcd-v3%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/12/24/etcd-v3%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何处理容器数据磁盘被写满</title>
    <link href="/2020/12/23/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E7%A3%81%E7%9B%98%E8%A2%AB%E5%86%99%E6%BB%A1/"/>
    <url>/2020/12/23/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E7%A3%81%E7%9B%98%E8%A2%AB%E5%86%99%E6%BB%A1/</url>
    
    <content type="html"><![CDATA[<p>容器数据磁盘被写满造成的危害:</p><blockquote><p>不能创建 Pod (一直 ContainerCreating)</p><p>不能删除 Pod (一直 Terminating)</p></blockquote><p>判断是否被写满:</p><p>容器数据目录大多会单独挂数据盘，路径一般是 /var/lib/docker，也可能是 /data/docker 或 /opt/docker，取决于节点被添加时的配置：</p><p><img src="/img/newimg/008eGmZEgy1gmgmy7xa7tj30iw0370t7.jpg" srcset="/img/loading.gif" alt=""></p><p>可通过 <code>docker info</code> 确定：</p><figure class="highlight crystal"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crystal"><br>$ docker info<br>...<br>Docker Root <span class="hljs-symbol">Dir:</span> /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">docker</span></span><br>...<br></code></pre></div></td></tr></table></figure><p>如果没有单独挂数据盘，则会使用系统盘存储。判断是否被写满：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">$ df<br>Filesystem     <span class="hljs-number">1</span>K-blocks     Used Available Use% Mounted on<br>...<br>/dev/vda1       <span class="hljs-number">51474044</span>  <span class="hljs-number">4619112</span>  <span class="hljs-number">44233548</span>  <span class="hljs-number">10</span>% /<br>...<br>/dev/vdb        <span class="hljs-number">20511356</span> <span class="hljs-number">20511356</span>         <span class="hljs-number">0</span> <span class="hljs-number">100</span>% /var/lib/docker<br></code></pre></div></td></tr></table></figure><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="先恢复业务，清理磁盘空间"><a href="#先恢复业务，清理磁盘空间" class="headerlink" title="先恢复业务，清理磁盘空间"></a>先恢复业务，清理磁盘空间</h3><p>重启 dockerd (清理容器日志输出和可写层文件)</p><p>重启前需要稍微腾出一点空间，不然重启 docker 会失败，可以手动删除一些docker的log文件或可写层文件，通常删除log:</p><figure class="highlight crystal"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crystal">$ cd /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">docker</span>/<span class="hljs-title">containers</span></span><br>$ du -sh * <span class="hljs-comment"># 找到比较大的目录</span><br>$ cd dda02c9a7491fa797ab730c1568ba06cba74cecd4e4a82e9d90d00fa11de743c<br>$ cat /dev/null &gt; dda02c9a7491fa797ab730c1568ba06cba74cecd4e4a82e9d90d00fa11de743c-json.log.<span class="hljs-number">9</span> <span class="hljs-comment"># 删除log文件</span><br></code></pre></div></td></tr></table></figure><p>注意: 使用 cat /dev/null &gt; 方式删除而不用 rm，因为用 rm 删除的文件，docker 进程可能不会释放文件，空间也就不会释放；log 的后缀数字越大表示越久远，先删除旧日志。</p><blockquote><p>将该 node 标记不可调度，并将其已有的 pod 驱逐到其它节点，这样重启dockerd就会让该节点的pod对应的容器删掉，容器相关的日志(标准输出)与容器内产生的数据文件(可写层)也会被清理：</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-number">1</span><span class="hljs-string">.停止主机在集群内使用</span><br><span class="hljs-string">$</span> <span class="hljs-string">kubectl</span> <span class="hljs-string">drain</span> <span class="hljs-number">10.179</span><span class="hljs-number">.80</span><span class="hljs-number">.31</span><br><span class="hljs-number">2</span><span class="hljs-string">.重启</span> <span class="hljs-attr">dockerd:</span><br><span class="hljs-string">systemctl</span> <span class="hljs-string">restart</span> <span class="hljs-string">dockerd</span><br><span class="hljs-number">3</span><span class="hljs-string">.取消不可调度的标记:</span><br><span class="hljs-string">kubectl</span> <span class="hljs-string">uncordon</span> <span class="hljs-number">10.179</span><span class="hljs-number">.80</span><span class="hljs-number">.31</span><br></code></pre></div></td></tr></table></figure><h3 id="定位根因，彻底解决"><a href="#定位根因，彻底解决" class="headerlink" title="定位根因，彻底解决"></a>定位根因，彻底解决</h3><p>问题定位方法见附录，这里列举根因对应的解决方法：</p><blockquote><p>日志输出量大导致磁盘写满:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">减少日志输出<br><br>增大磁盘空间<br><br>减小单机可调度的pod数量<br></code></pre></div></td></tr></table></figure><p>可写层量大导致磁盘写满: </p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">优化程序逻辑，不写文件到容器内或控制写入文件的大小与数量<br></code></pre></div></td></tr></table></figure><p>镜像占用空间大导致磁盘写满:</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">增大磁盘空间<br><br>删除不需要的镜像<br></code></pre></div></td></tr></table></figure><h3 id="查找方法"><a href="#查找方法" class="headerlink" title="查找方法"></a>查找方法</h3><ol><li>查看docker的磁盘空间占用情况</li></ol><p>docker system df -v<br><img src="/img/newimg/008eGmZEgy1gmgn4jmblej31ye0t67cg.jpg" srcset="/img/loading.gif" alt=""></p><ol start="2"><li><p>定位容器写满磁盘的原因<br>进入容器数据目录(假设是 /var/lib/docker，并且存储驱动是 aufs):</p><figure class="highlight crystal"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crystal"><br>$ cd /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">docker</span></span><br>$ du -sh *<br></code></pre></div></td></tr></table></figure><p><img src="/img/newimg/008eGmZEgy1gmgn5x21vgj31b00ge0v9.jpg" srcset="/img/loading.gif" alt=""></p></li><li><p>找出日志输出量大的 pod</p></li></ol><p>docker默认pod 中每个容器输出的日志最大存储 1G (日志轮转，最大10个文件，每个文件最大100m，可用 docker inpect 查看):</p><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">$ docker inspect fef835ebfc88<br>[<br>    &#123;<br>         <span class="hljs-string">...</span><br>        <span class="hljs-string">"HostConfig"</span>: &#123;<br>            <span class="hljs-string">...</span><br>            <span class="hljs-string">"LogConfig"</span>: &#123;<br>                <span class="hljs-string">"Type"</span>: <span class="hljs-string">"json-file"</span>,<br>                <span class="hljs-string">"Config"</span>: &#123;<br>                    <span class="hljs-string">"max-file"</span>: <span class="hljs-string">"10"</span>,<br>                    <span class="hljs-string">"max-size"</span>: <span class="hljs-string">"100m"</span><br>                &#125;<br>            &#125;,<br><span class="hljs-string">...</span><br></code></pre></div></td></tr></table></figure><ol start="4"><li>查看哪些容器日志输出量大：<br><img src="/img/newimg/008eGmZEgy1gmgna18xb1j30us0l0dlk.jpg" srcset="/img/loading.gif" alt=""></li></ol><figure class="highlight crystal"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crystal"><br>$ cd /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">docker</span>/<span class="hljs-title">containers</span></span><br>$ du -sh *<br></code></pre></div></td></tr></table></figure><p>目录名即为容器id，使用前几位与 <code>docker ps</code> 结果匹配可找出对应容器，最后就可以推算出是哪些 pod 搞的鬼</p><ol start="5"><li>找出可写层数据量大的 pod<br>可写层的数据主要是容器内程序自身写入的，无法控制大小，可写层越大说明容器写入的文件越多或越大，通常是容器内程序将log写到文件里了，查看一下哪个容器的可写层数据量大：</li></ol><figure class="highlight crystal"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crystal"><br>$ cd /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">docker</span>/<span class="hljs-title">aufs</span>/<span class="hljs-title">diff</span></span><br>$ du -sh *<br></code></pre></div></td></tr></table></figure><p><img src="/img/newimg/008eGmZEgy1gmgnb5vy6ej30vk0g4hbr.jpg" srcset="/img/loading.gif" alt=""></p><p>通过可写层目录(diff的子目录)反查容器id:</p><figure class="highlight crystal"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crystal">$ grep <span class="hljs-number">834</span>d97500892f56b24c6e63ffd4e520fc29c6c0d809a3472055116f59fb1d2be /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">docker</span>/<span class="hljs-title">image</span>/<span class="hljs-title">aufs</span>/<span class="hljs-title">layerdb</span>/<span class="hljs-title">mounts</span>/*/<span class="hljs-title">mount</span>-<span class="hljs-title">id</span></span><br>/var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">docker</span>/<span class="hljs-title">image</span>/<span class="hljs-title">aufs</span>/<span class="hljs-title">layerdb</span>/<span class="hljs-title">mounts</span>/<span class="hljs-title">eb76fcd31dfbe5fc949b67e4ad717e002847d15334791715ff7d96bb2c8785f9</span>/<span class="hljs-title">mount</span>-<span class="hljs-title">id</span>:834<span class="hljs-title">d97500892f56b24c6e63ffd4e520fc29c6c0d809a3472055116f59fb1d2be</span></span><br></code></pre></div></td></tr></table></figure><p><code>mounts</code> 后面一级的id即为容器id: eb76fcd31dfbe5fc949b67e4ad717e002847d15334791715ff7d96bb2c8785f9，使用前几位与 docker ps 结果匹配可找出对应容器，最后就可以推算出是哪些 pod 搞的鬼</p><ol start="6"><li>找出体积大的镜像<br>看看哪些镜像比较占空间<br><img src="/img/newimg/008eGmZEgy1gmgnc8wapnj31bg0k0n36.jpg" srcset="/img/loading.gif" alt=""></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>树莓派4bubuntu连wifi固定ip</title>
    <link href="/2020/12/23/%E6%A0%91%E8%8E%93%E6%B4%BE4bubuntu%E8%BF%9Ewifi%E5%9B%BA%E5%AE%9Aip/"/>
    <url>/2020/12/23/%E6%A0%91%E8%8E%93%E6%B4%BE4bubuntu%E8%BF%9Ewifi%E5%9B%BA%E5%AE%9Aip/</url>
    
    <content type="html"><![CDATA[<p>树莓派4B 安装ubuntu 20.04 LTS wifi配置固定ip</p><p>每次都随机比较难找……</p><p>1.首先参考之前的那篇 (树莓派 ubuntu 连wifi)</p><blockquote><p>ubuntu 从18.04 版本开始网络配置工具已经改为netplan了</p></blockquote><h3 id="编辑netplan目录下的yaml配置文件"><a href="#编辑netplan目录下的yaml配置文件" class="headerlink" title="编辑netplan目录下的yaml配置文件"></a>编辑netplan目录下的yaml配置文件</h3><p>sudo vim  /etc/netplan/50-cloud-init.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">root@ubuntu:~#</span> <span class="hljs-string">cat</span> <span class="hljs-string">/etc/netplan/50-cloud-init.yaml</span><br><span class="hljs-comment"># This file is generated from information provided by the datasource.  Changes</span><br><span class="hljs-comment"># to it will not persist across an instance reboot.  To disable cloud-init's</span><br><span class="hljs-comment"># network configuration capabilities, write a file</span><br><span class="hljs-comment"># /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following:</span><br><span class="hljs-comment"># network: &#123;config: disabled&#125;</span><br><span class="hljs-attr">network:</span><br>    <span class="hljs-attr">ethernets:</span><br>        <span class="hljs-attr">eth0:</span><br>            <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">true</span><br>            <span class="hljs-attr">optional:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">wifis:</span><br>        <span class="hljs-attr">wlan0:</span><br>            <span class="hljs-attr">access-points:</span><br>                <span class="hljs-attr">"wifi name":</span><br>                        <span class="hljs-attr">password:</span> <span class="hljs-string">wifi</span> <span class="hljs-string">passwd</span><br>            <span class="hljs-attr">addresses:</span> <span class="hljs-string">[192.168.0.101/24]</span><br>            <span class="hljs-attr">gateway4:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>            <span class="hljs-attr">nameservers:</span><br>              <span class="hljs-attr">addresses:</span> <span class="hljs-string">[8.8.8.8,114.114.114.114]</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><h3 id="检查语法"><a href="#检查语法" class="headerlink" title="检查语法"></a>检查语法</h3><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog">sudo netplan <span class="hljs-keyword">generate</span><br></code></pre></div></td></tr></table></figure><h1 id="使配置生效"><a href="#使配置生效" class="headerlink" title="使配置生效"></a>使配置生效</h1><figure class="highlight coq"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coq">sudo netplan <span class="hljs-built_in">apply</span><br></code></pre></div></td></tr></table></figure><h1 id="查看ip地址"><a href="#查看ip地址" class="headerlink" title="查看ip地址"></a>查看ip地址</h1><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-symbol">root@</span>ubuntu:~# ip a<br><span class="hljs-number">1</span>: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="hljs-number">65536</span> qdisc noqueue state UNKNOWN group <span class="hljs-keyword">default</span> qlen <span class="hljs-number">1000</span><br>    link/loopback <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> brd <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><br>    inet <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>/<span class="hljs-number">8</span> scope host lo<br>       valid_lft forever preferred_lft forever<br>    inet6 ::<span class="hljs-number">1</span>/<span class="hljs-number">128</span> scope host<br>       valid_lft forever preferred_lft forever<br><span class="hljs-number">2</span>: eth0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu <span class="hljs-number">1500</span> qdisc mq state DOWN group <span class="hljs-keyword">default</span> qlen <span class="hljs-number">1000</span><br>    link/ether dc:a6:<span class="hljs-number">32</span>:cc:<span class="hljs-number">25</span>:ab brd ff:ff:ff:ff:ff:ff<br><span class="hljs-number">3</span>: wlan0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="hljs-number">1500</span> qdisc fq_codel state UP group <span class="hljs-keyword">default</span> qlen <span class="hljs-number">1000</span><br>    link/ether dc:a6:<span class="hljs-number">32</span>:cc:<span class="hljs-number">25</span>:ad brd ff:ff:ff:ff:ff:ff<br>    inet <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.101</span>/<span class="hljs-number">24</span> brd <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.255</span> scope global wlan0<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::dea6:<span class="hljs-number">32f</span>f:fecc:<span class="hljs-number">25</span>ad/<span class="hljs-number">64</span> scope link<br>       valid_lft forever preferred_lft forever<br><span class="hljs-number">4</span>: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu <span class="hljs-number">1500</span> qdisc noqueue state DOWN group <span class="hljs-keyword">default</span><br>    link/ether <span class="hljs-number">02</span>:<span class="hljs-number">42</span>:<span class="hljs-number">4f</span>:<span class="hljs-number">5f</span>:<span class="hljs-number">9</span>b:<span class="hljs-number">71</span> brd ff:ff:ff:ff:ff:ff<br>    inet <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>/<span class="hljs-number">16</span> brd <span class="hljs-number">172.17</span><span class="hljs-number">.255</span><span class="hljs-number">.255</span> scope global docker0<br>       valid_lft forever preferred_lft forever<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang Gin 实战(-)|快速安装入门</title>
    <link href="/2020/12/22/Golang-Gin-%E5%AE%9E%E6%88%98-%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85%E5%85%A5%E9%97%A8/"/>
    <url>/2020/12/22/Golang-Gin-%E5%AE%9E%E6%88%98-%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GitHub OAuth 第三方登录示例教程</title>
    <link href="/2020/12/21/GitHub-OAuth-%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95%E7%A4%BA%E4%BE%8B%E6%95%99%E7%A8%8B/"/>
    <url>/2020/12/21/GitHub-OAuth-%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95%E7%A4%BA%E4%BE%8B%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>OAuth 2.0 的四种方式</title>
    <link href="/2020/12/21/OAuth-2-0-%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/2020/12/21/OAuth-2-0-%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>OAuth 2.0 的一个简单解释</title>
    <link href="/2020/12/21/OAuth-2-0-%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8A/"/>
    <url>/2020/12/21/OAuth-2-0-%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8A/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.jxhs.me/2020/12/21/%E7%90%86%E8%A7%A3OAuth-2-0/">OAuth 2.0</a> 是目前最流行的授权机制，用来授权第三方应用，获取用户数据。</p><p>这个标准比较抽象，使用了很多术语，初学者不容易理解。其实说起来并不复杂，下面我就通过一个简单的类比，帮助大家轻松理解，OAuth 2.0 到底是什么。</p><h3 id="一、快递员问题"><a href="#一、快递员问题" class="headerlink" title="一、快递员问题"></a>一、快递员问题</h3><p>我住在一个大型的居民小区。<br><img src="/img/newimg/0081Kckwgy1glvm5d78v3j30m80etq4n.jpg" srcset="/img/loading.gif" alt=""></p><p>小区有门禁系统。</p><p><img src="/img/newimg/0081Kckwgy1glvm6d9hggj30m80gh75d.jpg" srcset="/img/loading.gif" alt=""></p><p>进入的时候需要输入密码。<br><img src="/img/newimg/0081Kckwgy1glvm6m43h6j30e00b10t8.jpg" srcset="/img/loading.gif" alt=""><br>我经常网购和外卖，每天都有快递员来送货。我必须找到一个办法，让快递员通过门禁系统，进入小区。<br><img src="/img/newimg/0081Kckwgy1glvm6z4zumj30dc0a0aaw.jpg" srcset="/img/loading.gif" alt=""></p><p>如果我把自己的密码，告诉快递员，他就拥有了与我同样的权限，这样好像不太合适。万一我想取消他进入小区的权力，也很麻烦，我自己的密码也得跟着改了，还得通知其他的快递员。</p><p>有没有一种办法，让快递员能够自由进入小区，又不必知道小区居民的密码，而且他的唯一权限就是送货，其他需要密码的场合，他都没有权限？</p><h3 id="二、授权机制的设计"><a href="#二、授权机制的设计" class="headerlink" title="二、授权机制的设计"></a>二、授权机制的设计</h3><p>于是，我设计了一套授权机制。</p><p>第一步，门禁系统的密码输入器下面，增加一个按钮，叫做”获取授权”。快递员需要首先按这个按钮，去申请授权。</p><p>第二步，他按下按钮以后，屋主（也就是我）的手机就会跳出对话框：有人正在要求授权。系统还会显示该快递员的姓名、工号和所属的快递公司。</p><p>我确认请求属实，就点击按钮，告诉门禁系统，我同意给予他进入小区的授权。</p><p>第三步，门禁系统得到我的确认以后，向快递员显示一个进入小区的令牌（access token）。令牌就是类似密码的一串数字，只在短期内（比如七天）有效。</p><p>第四步，快递员向门禁系统输入令牌，进入小区。</p><p>有人可能会问，为什么不是远程为快递员开门，而要为他单独生成一个令牌？这是因为快递员可能每天都会来送货，第二天他还可以复用这个令牌。另外，有的小区有多重门禁，快递员可以使用同一个令牌通过它们。</p><h3 id="三、互联网场景"><a href="#三、互联网场景" class="headerlink" title="三、互联网场景"></a>三、互联网场景</h3><p>我们把上面的例子搬到互联网，就是 OAuth 的设计了。</p><p>首先，居民小区就是储存用户数据的网络服务。比如，微信储存了我的好友信息，获取这些信息，就必须经过微信的”门禁系统”。</p><p>其次，快递员（或者说快递公司）就是第三方应用，想要穿过门禁系统，进入小区。</p><p>最后，我就是用户本人，同意授权第三方应用进入小区，获取我的数据。</p><p>简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。</p><h3 id="四、令牌与密码"><a href="#四、令牌与密码" class="headerlink" title="四、令牌与密码"></a>四、令牌与密码</h3><p>令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异。</p><p>（1）令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。</p><p>（2）令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。</p><p>（3）令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。</p><p>上面这些设计，保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全。这就是 OAuth 2.0 的优点。</p><p>注意，只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。 这也是为什么令牌的有效期，一般都设置得很短的原因。</p><p>OAuth 2.0 对于如何颁发令牌的细节，规定得非常详细。具体来说，一共分成四种授权类型（authorization grant），即四种颁发令牌的方式，适用于不同的互联网场景。下一篇文章，我就来介绍这四种类型，并给出代码实例。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>理解OAuth 2.0</title>
    <link href="/2020/12/21/%E7%90%86%E8%A7%A3OAuth-2-0/"/>
    <url>/2020/12/21/%E7%90%86%E8%A7%A3OAuth-2-0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/OAuth" target="_blank" rel="noopener">OAuth</a>是一个关于授权（authorization）的开放网络标准，在全世界得到广泛应用，目前的版本是2.0版。</p><p>本文对OAuth 2.0的设计思路和运行流程，做一个简明通俗的解释，主要参考材料为<a href="http://www.rfcreader.com/#rfc6749" target="_blank" rel="noopener">RFC 6749</a>。</p><h3 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h3><p>为了理解OAuth的适用场合，让我举一个假设的例子。</p><p>有一个”云冲印”的网站，可以将用户储存在Google的照片，冲印出来。用户为了使用该服务，必须让”云冲印”读取自己储存在Google上的照片。<br><img src="/img/newimg/0081Kckwgy1glxnw8oyx0j308c08ca9w.jpg" srcset="/img/loading.gif" alt=""><br>问题是只有得到用户的授权，Google才会同意”云冲印”读取这些照片。那么，”云冲印”怎样获得用户的授权呢？</p><p>传统方法是，用户将自己的Google用户名和密码，告诉”云冲印”，后者就可以读取用户的照片了。这样的做法有以下几个严重的缺点。</p><blockquote><p>（1）”云冲印”为了后续的服务，会保存用户的密码，这样很不安全。</p><p>（2）Google不得不部署密码登录，而我们知道，单纯的密码登录并不安全。</p><p>（3）”云冲印”拥有了获取用户储存在Google所有资料的权力，用户没法限制”云冲印”获得授权的范围和有效期。</p><p>（4）用户只有修改密码，才能收回赋予”云冲印”的权力。但是这样做，会使得其他所有获得用户授权的第三方应用程序全部失效。</p><p>（5）只要有一个第三方应用程序被破解，就会导致用户密码泄漏，以及所有被密码保护的数据泄漏。</p></blockquote><p>OAuth就是为了解决上面这些问题而诞生的。</p><h3 id="二、名词定义"><a href="#二、名词定义" class="headerlink" title="二、名词定义"></a>二、名词定义</h3><p>在详细讲解OAuth 2.0之前，需要了解几个专用名词。它们对读懂后面的讲解，尤其是几张图，至关重要。</p><blockquote><p>（1） Third-party application：第三方应用程序，本文中又称”客户端”（client），即上一节例子中的”云冲印”。</p><p>（2）HTTP service：HTTP服务提供商，本文中简称”服务提供商”，即上一节例子中的Google。</p><p>（3）Resource Owner：资源所有者，本文中又称”用户”（user）。</p><p>（4）User Agent：用户代理，本文中就是指浏览器。</p><p>（5）Authorization server：认证服务器，即服务提供商专门用来处理认证的服务器。</p><p>（6）Resource server：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</p></blockquote><p>知道了上面这些名词，就不难理解，OAuth的作用就是让”客户端”安全可控地获取”用户”的授权，与”服务商提供商”进行互动。</p><h3 id="三、OAuth的思路"><a href="#三、OAuth的思路" class="headerlink" title="三、OAuth的思路"></a>三、OAuth的思路</h3><p>OAuth在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。”客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。</p><p>“客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。</p><h3 id="四、运行流程"><a href="#四、运行流程" class="headerlink" title="四、运行流程"></a>四、运行流程</h3><p>OAuth 2.0的运行流程如下图，摘自RFC 6749。</p><blockquote><p>（A）用户打开客户端以后，客户端要求用户给予授权。</p><p>（B）用户同意给予客户端授权。</p><p>（C）客户端使用上一步获得的授权，向认证服务器申请令牌。</p><p>（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</p><p>（E）客户端使用令牌，向资源服务器申请获取资源。</p><p>（F）资源服务器确认令牌无误，同意向客户端开放资源。</p></blockquote><p>不难看出来，上面六个步骤之中，B是关键，即用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。</p><p>下面一一讲解客户端获取授权的四种模式。</p><h3 id="五、客户端的授权模式"><a href="#五、客户端的授权模式" class="headerlink" title="五、客户端的授权模式"></a>五、客户端的授权模式</h3><p>客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0定义了四种授权方式。</p><ol><li>授权码模式（authorization code）</li><li>简化模式（implicit）</li><li>密码模式（resource owner password credentials）</li><li>客户端模式（client credentials）</li></ol><h3 id="六、授权码模式"><a href="#六、授权码模式" class="headerlink" title="六、授权码模式"></a>六、授权码模式</h3><p>授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与”服务提供商”的认证服务器进行互动。</p><p><img src="/img/newimg/0081Kckwgy1glxo1y1y1tj30l80epq2u.jpg" srcset="/img/loading.gif" alt=""></p><p>它的步骤如下：</p><blockquote><p>（A）用户访问客户端，后者将前者导向认证服务器。</p><p>（B）用户选择是否给予客户端授权。</p><p>（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的”重定向URI”（redirection URI），同时附上一个授权码。</p><p>（D）客户端收到授权码，附上早先的”重定向URI”，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。</p><p>（E）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。</p></blockquote><p>下面是上面这些步骤所需要的参数。</p><p>A步骤中，客户端申请认证的URI，包含以下参数：</p><ol><li>response_type：表示授权类型，必选项，此处的值固定为”code”</li><li>client_id：表示客户端的ID，必选项</li><li>redirect_uri：表示重定向URI，可选项</li><li>scope：表示申请的权限范围，可选项</li><li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li></ol><p>下面是一个例子。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><br>GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz<br>        &amp;redirect_uri=https%<span class="hljs-number">3</span>A%<span class="hljs-number">2</span>F%<span class="hljs-number">2</span>Fclient%<span class="hljs-number">2</span>Eexample%<span class="hljs-number">2</span>Ecom%<span class="hljs-number">2</span>Fcb HTTP/<span class="hljs-number">1.1</span><br>Host: server.example.com<br></code></pre></div></td></tr></table></figure><p>C步骤中，服务器回应客户端的URI，包含以下参数：</p><ol><li>code：表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。</li><li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li></ol><p>下面是一个例子。</p><figure class="highlight pf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pf"><br>HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">302</span> Found<br>Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA<br>          &amp;<span class="hljs-keyword">state</span>=xyz<br></code></pre></div></td></tr></table></figure><p>D步骤中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数：</p><ol><li>grant_type：表示使用的授权模式，必选项，此处的值固定为”authorization_code”。</li><li>code：表示上一步获得的授权码，必选项。</li><li>redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。</li><li>client_id：表示客户端ID，必选项。</li></ol><p>下面是一个例子。</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs"><span class="hljs-keyword">POST</span> <span class="hljs-string">/token</span> HTTP/1.1<br><span class="hljs-attribute">Host</span>: server.example.com<br><span class="hljs-attribute">Authorization</span>: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW<br><span class="hljs-attribute">Content-Type</span>: application/x-www-form-urlencoded<br><br>grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA<br>&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb<br></code></pre></div></td></tr></table></figure><p>E步骤中，认证服务器发送的HTTP回复，包含以下参数：</p><ol><li>access_token：表示访问令牌，必选项。</li><li>token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。</li><li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li><li>refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。</li><li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li></ol><p>下面是一个例子。</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs"><br>HTTP/1.1 <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content-Type</span>: application/json;charset=UTF-8<br><span class="hljs-attribute">Cache-Control</span>: no-store<br><span class="hljs-attribute">Pragma</span>: no-cache<br><br>&#123;<br>  "access_token":"2YotnFZFEjr1zCsicMWpAA",<br>  "token_type":"example",<br>  "expires_in":3600,<br>  "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",<br>  "example_parameter":"example_value"<br>&#125;<br></code></pre></div></td></tr></table></figure><p>从上面代码可以看到，相关参数使用JSON格式发送（Content-Type: application/json）。此外，HTTP头信息中明确指定不得缓存。</p><h3 id="七、简化模式"><a href="#七、简化模式" class="headerlink" title="七、简化模式"></a>七、简化模式</h3><p>简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了”授权码”这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。</p><p><img src="/img/newimg/0081Kckwgy1glxo798xs2j30in0fxq30.jpg" srcset="/img/loading.gif" alt=""><br>它的步骤如下：</p><blockquote><p>（A）客户端将用户导向认证服务器。</p><p>（B）用户决定是否给于客户端授权。</p><p>（C）假设用户给予授权，认证服务器将用户导向客户端指定的”重定向URI”，并在URI的Hash部分包含了访问令牌。</p><p>（D）浏览器向资源服务器发出请求，其中不包括上一步收到的Hash值。</p><p>（E）资源服务器返回一个网页，其中包含的代码可以获取Hash值中的令牌。</p><p>（F）浏览器执行上一步获得的脚本，提取出令牌。</p><p>（G）浏览器将令牌发给客户端。</p></blockquote><p>下面是上面这些步骤所需要的参数。</p><p>A步骤中，客户端发出的HTTP请求，包含以下参数：</p><ol><li>response_type：表示授权类型，此处的值固定为”token”，必选项。</li><li>client_id：表示客户端的ID，必选项。</li><li>redirect_uri：表示重定向的URI，可选项。</li><li>scope：表示权限范围，可选项。</li><li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li></ol><p>下面是一个例子。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">GET /authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;state=xyz<br>    &amp;redirect_uri=https%<span class="hljs-number">3</span>A%<span class="hljs-number">2</span>F%<span class="hljs-number">2</span>Fclient%<span class="hljs-number">2</span>Eexample%<span class="hljs-number">2</span>Ecom%<span class="hljs-number">2</span>Fcb HTTP/<span class="hljs-number">1.1</span><br>Host: server.example.com<br></code></pre></div></td></tr></table></figure><p>C步骤中，认证服务器回应客户端的URI，包含以下参数：</p><ol><li>access_token：表示访问令牌，必选项。</li><li>token_type：表示令牌类型，该值大小写不敏感，必选项。</li><li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li><li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li><li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li></ol><p>下面是一个例子。</p><figure class="highlight pf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pf">HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">302</span> Found<br>Location: http://example.com/cb<span class="hljs-comment">#access_token=2YotnFZFEjr1zCsicMWpAA</span><br>          &amp;<span class="hljs-keyword">state</span>=xyz&amp;token_type=example&amp;expires_in=<span class="hljs-number">3600</span><br></code></pre></div></td></tr></table></figure><p>在上面的例子中，认证服务器用HTTP头信息的Location栏，指定浏览器重定向的网址。注意，在这个网址的Hash部分包含了令牌。</p><p>根据上面的D步骤，下一步浏览器会访问Location指定的网址，但是Hash部分不会发送。接下来的E步骤，服务提供商的资源服务器发送过来的代码，会提取出Hash中的令牌。</p><h3 id="八、密码模式"><a href="#八、密码模式" class="headerlink" title="八、密码模式"></a>八、密码模式</h3><p>密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向”服务商提供商”索要授权。</p><p>在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。<br><img src="/img/newimg/0081Kckwgy1glxoajbd2fj30m70ba0sq.jpg" srcset="/img/loading.gif" alt=""><br>它的步骤如下：</p><blockquote><p>（A）用户向客户端提供用户名和密码。</p><p>（B）客户端将用户名和密码发给认证服务器，向后者请求令牌。</p><p>（C）认证服务器确认无误后，向客户端提供访问令牌。</p></blockquote><p>B步骤中，客户端发出的HTTP请求，包含以下参数：</p><ol><li>grant_type：表示授权类型，此处的值固定为”password”，必选项。</li><li>username：表示用户名，必选项。</li><li>password：表示用户的密码，必选项。</li><li>scope：表示权限范围，可选项。</li></ol><p>下面是一个例子。</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs"><br><span class="hljs-keyword">POST</span> <span class="hljs-string">/token</span> HTTP/1.1<br><span class="hljs-attribute">Host</span>: server.example.com<br><span class="hljs-attribute">Authorization</span>: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW<br><span class="hljs-attribute">Content-Type</span>: application/x-www-form-urlencoded<br><br>grant_type=password&amp;username=johndoe&amp;password=A3ddj3w<br></code></pre></div></td></tr></table></figure><p>C步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs"><br>HTTP/1.1 <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content-Type</span>: application/json;charset=UTF-8<br><span class="hljs-attribute">Cache-Control</span>: no-store<br><span class="hljs-attribute">Pragma</span>: no-cache<br><br>&#123;<br>  "access_token":"2YotnFZFEjr1zCsicMWpAA",<br>  "token_type":"example",<br>  "expires_in":3600,<br>  "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",<br>  "example_parameter":"example_value"<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面代码中，各个参数的含义参见《授权码模式》一节。</p><p>整个过程中，客户端不得保存用户的密码。</p><h3 id="九、客户端模式"><a href="#九、客户端模式" class="headerlink" title="九、客户端模式"></a>九、客户端模式</h3><p>客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向”服务提供商”进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求”服务提供商”提供服务，其实不存在授权问题。</p><p><img src="/img/newimg/0081Kckwgy1glxodml3s2j30ma053wec.jpg" srcset="/img/loading.gif" alt=""><br>它的步骤如下：</p><blockquote><p>（A）客户端向认证服务器进行身份认证，并要求一个访问令牌。</p><p>（B）认证服务器确认无误后，向客户端提供访问令牌。</p></blockquote><p>A步骤中，客户端发出的HTTP请求，包含以下参数：</p><ol><li>granttype：表示授权类型，此处的值固定为”clientcredentials”，必选项。</li><li>scope：表示权限范围，可选项。</li></ol><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs"><br><span class="hljs-keyword">POST</span> <span class="hljs-string">/token</span> HTTP/1.1<br><span class="hljs-attribute">Host</span>: server.example.com<br><span class="hljs-attribute">Authorization</span>: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW<br><span class="hljs-attribute">Content-Type</span>: application/x-www-form-urlencoded<br><br>grant_type=client_credentials<br></code></pre></div></td></tr></table></figure><p>认证服务器必须以某种方式，验证客户端身份。</p><p>B步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs"><br>HTTP/1.1 <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content-Type</span>: application/json;charset=UTF-8<br><span class="hljs-attribute">Cache-Control</span>: no-store<br><span class="hljs-attribute">Pragma</span>: no-cache<br><br>&#123;<br>  "access_token":"2YotnFZFEjr1zCsicMWpAA",<br>  "token_type":"example",<br>  "expires_in":3600,<br>  "example_parameter":"example_value"<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="十、更新令牌"><a href="#十、更新令牌" class="headerlink" title="十、更新令牌"></a>十、更新令牌</h3><p>如果用户访问的时候，客户端的”访问令牌”已经过期，则需要使用”更新令牌”申请一个新的访问令牌。</p><p>客户端发出更新令牌的HTTP请求，包含以下参数：</p><ol><li><p>granttype：表示使用的授权模式，此处的值固定为”refreshtoken”，必选项。</p></li><li><p>refresh_token：表示早前收到的更新令牌，必选项。</p></li><li><p>scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致。<br>下面是一个例子。</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile">POST /token HTTP/1.1<br><span class="hljs-section">Host: server.example.com</span><br><span class="hljs-section">Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="hljs-section">Content-Type: application/x-www-form-urlencoded</span><br>  <br>grant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA<br></code></pre></div></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>OAuth 2.0</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gin框架路由拆分与注册</title>
    <link href="/2020/12/18/gin%E6%A1%86%E6%9E%B6%E8%B7%AF%E7%94%B1%E6%8B%86%E5%88%86%E4%B8%8E%E6%B3%A8%E5%86%8C/"/>
    <url>/2020/12/18/gin%E6%A1%86%E6%9E%B6%E8%B7%AF%E7%94%B1%E6%8B%86%E5%88%86%E4%B8%8E%E6%B3%A8%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<p>本文总结了我平时在项目中积累的关于gin框架路由拆分与注册的若干方法。</p><h3 id="基本的路由注册"><a href="#基本的路由注册" class="headerlink" title="基本的路由注册"></a>基本的路由注册</h3><p>下面最基础的gin路由注册方式，适用于路由条目比较少的简单项目或者项目demo。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">"net/http"</span><br><br><span class="hljs-string">"github.com/gin-gonic/gin"</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helloHandler</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.JSON(http.StatusOK, gin.H&#123;<br><span class="hljs-string">"message"</span>: <span class="hljs-string">"Hello q1mi!"</span>,<br>&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br>r.GET(<span class="hljs-string">"/hello"</span>, helloHandler)<br><span class="hljs-keyword">if</span> err := r.Run(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">"startup service failed, err:%v\n"</span>, err)<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="路由拆分成单独文件或包"><a href="#路由拆分成单独文件或包" class="headerlink" title="路由拆分成单独文件或包"></a>路由拆分成单独文件或包</h3><p>当项目的规模增大后就不太适合继续在项目的<code>main.go</code>文件中去实现路由注册相关逻辑了，我们会倾向于把路由部分的代码都拆分出来，形成一个单独的文件或包：</p><p>我们在<code>routers.go</code>文件中定义并注册路由信息：</p><figure class="highlight swift"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs swift">package main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">"net/http"</span><br><br><span class="hljs-string">"github.com/gin-gonic/gin"</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helloHandler</span><span class="hljs-params">(<span class="hljs-built_in">c</span> *gin.Context)</span></span> &#123;<br><span class="hljs-built_in">c</span>.<span class="hljs-type">JSON</span>(http.<span class="hljs-type">StatusOK</span>, gin.<span class="hljs-type">H</span>&#123;<br><span class="hljs-string">"message"</span>: <span class="hljs-string">"Hello q1mi!"</span>,<br>&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setupRouter</span><span class="hljs-params">()</span></span> *gin.<span class="hljs-type">Engine</span> &#123;<br>r := gin.<span class="hljs-type">Default</span>()<br>r.<span class="hljs-type">GET</span>(<span class="hljs-string">"/hello"</span>, helloHandler)<br><span class="hljs-keyword">return</span> r<br>&#125;<br></code></pre></div></td></tr></table></figure><p>此时<code>main.go</code>中调用上面定义好的<code>setupRouter</code>函数：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := setupRouter()<br><span class="hljs-keyword">if</span> err := r.Run(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">"startup service failed, err:%v\n"</span>, err)<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>此时的目录结构：</p><figure class="highlight maxima"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs maxima">gin_demo<br>├── <span class="hljs-built_in">go</span>.<span class="hljs-built_in">mod</span><br>├── <span class="hljs-built_in">go</span>.<span class="hljs-built_in">sum</span><br>├── main.<span class="hljs-built_in">go</span><br>└── routers.<span class="hljs-built_in">go</span><br></code></pre></div></td></tr></table></figure><p>把路由部分的代码单独拆分成包的话也是可以的，拆分后的目录结构如下：</p><figure class="highlight maxima"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs maxima">gin_demo<br>├── <span class="hljs-built_in">go</span>.<span class="hljs-built_in">mod</span><br>├── <span class="hljs-built_in">go</span>.<span class="hljs-built_in">sum</span><br>├── main.<span class="hljs-built_in">go</span><br>└── routers<br>    └── routers.<span class="hljs-built_in">go</span><br></code></pre></div></td></tr></table></figure><p><code>routers/routers.go</code>需要注意此时<code>setupRouter</code>需要改成首字母大写：</p><figure class="highlight swift"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs swift">package routers<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">"net/http"</span><br><br><span class="hljs-string">"github.com/gin-gonic/gin"</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helloHandler</span><span class="hljs-params">(<span class="hljs-built_in">c</span> *gin.Context)</span></span> &#123;<br><span class="hljs-built_in">c</span>.<span class="hljs-type">JSON</span>(http.<span class="hljs-type">StatusOK</span>, gin.<span class="hljs-type">H</span>&#123;<br><span class="hljs-string">"message"</span>: <span class="hljs-string">"Hello q1mi!"</span>,<br>&#125;)<br>&#125;<br><br><span class="hljs-comment">// SetupRouter 配置路由信息</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SetupRouter</span><span class="hljs-params">()</span></span> *gin.<span class="hljs-type">Engine</span> &#123;<br>r := gin.<span class="hljs-type">Default</span>()<br>r.<span class="hljs-type">GET</span>(<span class="hljs-string">"/hello"</span>, helloHandler)<br><span class="hljs-keyword">return</span> r<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>main.go</code>文件内容如下：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">"fmt"</span><br><span class="hljs-string">"gin_demo/routers"</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := routers.SetupRouter()<br><span class="hljs-keyword">if</span> err := r.Run(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">"startup service failed, err:%v\n"</span>, err)<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="路由拆分成多个文件"><a href="#路由拆分成多个文件" class="headerlink" title="路由拆分成多个文件"></a>路由拆分成多个文件</h3><p>当我们的业务规模继续膨胀，单独的一个<code>routers</code>文件或包已经满足不了我们的需求了，</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">func</span> <span class="hljs-selector-tag">SetupRouter</span>() *<span class="hljs-selector-tag">gin</span><span class="hljs-selector-class">.Engine</span> &#123;<br><span class="hljs-attribute">r </span>:= gin.<span class="hljs-built_in">Default</span>()<br>r.<span class="hljs-built_in">GET</span>(<span class="hljs-string">"/hello"</span>, helloHandler)<br>  r.<span class="hljs-built_in">GET</span>(<span class="hljs-string">"/xx1"</span>, xxHandler1)<br>  ...<br>  r.<span class="hljs-built_in">GET</span>(<span class="hljs-string">"/xx30"</span>, xxHandler30)<br>return r<br>&#125;<br></code></pre></div></td></tr></table></figure><p>因为我们把所有的路由注册都写在一个<code>SetupRouter</code>函数中的话就会太复杂了。</p><p>我们可以分开定义多个路由文件，例如：</p><figure class="highlight maxima"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs maxima">gin_demo<br>├── <span class="hljs-built_in">go</span>.<span class="hljs-built_in">mod</span><br>├── <span class="hljs-built_in">go</span>.<span class="hljs-built_in">sum</span><br>├── main.<span class="hljs-built_in">go</span><br>└── routers<br>    ├── blog.<span class="hljs-built_in">go</span><br>    └── shop.<span class="hljs-built_in">go</span><br></code></pre></div></td></tr></table></figure><p><code>routers/shop.go</code>中添加一个<code>LoadShop</code>的函数，将shop相关的路由注册到指定的路由器：</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">func <span class="hljs-constructor">LoadShop(<span class="hljs-params">e</span> <span class="hljs-operator">*</span><span class="hljs-params">gin</span>.Engine)</span>  &#123;<br>e.<span class="hljs-constructor">GET(<span class="hljs-string">"/hello"</span>, <span class="hljs-params">helloHandler</span>)</span><br>  e.<span class="hljs-constructor">GET(<span class="hljs-string">"/goods"</span>, <span class="hljs-params">goodsHandler</span>)</span><br>  e.<span class="hljs-constructor">GET(<span class="hljs-string">"/checkout"</span>, <span class="hljs-params">checkoutHandler</span>)</span><br>  ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>routers/blog.go</code>中添加一个<code>LoadBlog</code>的函数，将blog相关的路由注册到指定的路由器：</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">func <span class="hljs-constructor">LoadBlog(<span class="hljs-params">e</span> <span class="hljs-operator">*</span><span class="hljs-params">gin</span>.Engine)</span> &#123;<br>e.<span class="hljs-constructor">GET(<span class="hljs-string">"/post"</span>, <span class="hljs-params">postHandler</span>)</span><br>  e.<span class="hljs-constructor">GET(<span class="hljs-string">"/comment"</span>, <span class="hljs-params">commentHandler</span>)</span><br>  ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在main函数中实现最终的注册逻辑如下：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br>routers.LoadBlog(r)<br>routers.LoadShop(r)<br><span class="hljs-keyword">if</span> err := r.Run(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">"startup service failed, err:%v\n"</span>, err)<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="路由拆分到不同的APP"><a href="#路由拆分到不同的APP" class="headerlink" title="路由拆分到不同的APP"></a>路由拆分到不同的APP</h3><p>有时候项目规模实在太大，那么我们就更倾向于把业务拆分的更详细一些，例如把不同的业务代码拆分成不同的APP。</p><p>因此我们在项目目录下单独定义一个<code>app</code>目录，用来存放我们不同业务线的代码文件，这样就很容易进行横向扩展。大致目录结构如下：</p><figure class="highlight maxima"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs maxima">gin_demo<br>├── app<br>│   ├── blog<br>│   │   ├── handler.<span class="hljs-built_in">go</span><br>│   │   └── router.<span class="hljs-built_in">go</span><br>│   └── shop<br>│       ├── handler.<span class="hljs-built_in">go</span><br>│       └── router.<span class="hljs-built_in">go</span><br>├── <span class="hljs-built_in">go</span>.<span class="hljs-built_in">mod</span><br>├── <span class="hljs-built_in">go</span>.<span class="hljs-built_in">sum</span><br>├── main.<span class="hljs-built_in">go</span><br>└── routers<br>    └── routers.<span class="hljs-built_in">go</span><br></code></pre></div></td></tr></table></figure><p>其中<code>app/blog/router.go</code>用来定义post相关路由信息，具体内容如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">func <span class="hljs-constructor">Routers(<span class="hljs-params">e</span> <span class="hljs-operator">*</span><span class="hljs-params">gin</span>.Engine)</span> &#123;<br>e.<span class="hljs-constructor">GET(<span class="hljs-string">"/post"</span>, <span class="hljs-params">postHandler</span>)</span><br>e.<span class="hljs-constructor">GET(<span class="hljs-string">"/comment"</span>, <span class="hljs-params">commentHandler</span>)</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>app/shop/router.go</code>用来定义shop相关路由信息，具体内容如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">func <span class="hljs-constructor">Routers(<span class="hljs-params">e</span> <span class="hljs-operator">*</span><span class="hljs-params">gin</span>.Engine)</span> &#123;<br>e.<span class="hljs-constructor">GET(<span class="hljs-string">"/goods"</span>, <span class="hljs-params">goodsHandler</span>)</span><br>e.<span class="hljs-constructor">GET(<span class="hljs-string">"/checkout"</span>, <span class="hljs-params">checkoutHandler</span>)</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>routers/routers.go</code>中根据需要定义<code>Include</code>函数用来注册子app中定义的路由，<code>Init</code>函数用来进行路由的初始化操作：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Option <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*gin.Engine)</span></span><br><br><span class="hljs-keyword">var</span> options = []Option&#123;&#125;<br><br><span class="hljs-comment">// 注册app的路由配置</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Include</span><span class="hljs-params">(opts ...Option)</span></span> &#123;<br>options = <span class="hljs-built_in">append</span>(options, opts...)<br>&#125;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span> *<span class="hljs-title">gin</span>.<span class="hljs-title">Engine</span></span> &#123;<br>r := gin.Default()<br><span class="hljs-keyword">for</span> _, opt := <span class="hljs-keyword">range</span> options &#123;<br>opt(r)<br>&#125;<br><span class="hljs-keyword">return</span> r<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>main.go</code>中按如下方式先注册子app中的路由，然后再进行路由的初始化：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 加载多个APP的路由配置</span><br>routers.Include(shop.Routers, blog.Routers)<br><span class="hljs-comment">// 初始化路由</span><br>r := routers.Init()<br><span class="hljs-keyword">if</span> err := r.Run(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">"startup service failed, err:%v\n"</span>, err)<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>gin</code>框架是一个非常容易扩展的web框架，本文是我在日常编码中总结的一点点经验，不过web框架都差不多 flask django也是这么玩儿的。。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>怎样理解openresty中的cosocket</title>
    <link href="/2020/12/01/%E6%80%8E%E6%A0%B7%E7%90%86%E8%A7%A3openresty%E4%B8%AD%E7%9A%84cosocket/"/>
    <url>/2020/12/01/%E6%80%8E%E6%A0%B7%E7%90%86%E8%A7%A3openresty%E4%B8%AD%E7%9A%84cosocket/</url>
    
    <content type="html"><![CDATA[<p>cosocket 是各种 lua-resty-* 非阻塞库的基础，没 有 cosocket，开发者就无法用 Lua 来快速连接各种外部的网络服务。</p><p>在早期的 OpenResty 版本中，如果想要去与 Redis、memcached 这些服务交互的话，需要使用 redis2-nginx-module、redis-nginx-module 和 memc-nginx-module这些 C 模块.这些模块至今仍然在 OpenResty 的发行包中。</p><p>cosocket 功能加入以后，它们都已经被 lua-resty-redis 和 lua-resty-memcached 替代，基 本上没人再去使用 C 模块连接外部服务了。</p><h3 id="什么是-cosocket"><a href="#什么是-cosocket" class="headerlink" title="什么是 cosocket"></a>什么是 cosocket</h3><p>cosocket是 OpenResty 中的专有名词，是把协程和网络套接字的英文 拼在一起形成的，即 cosocket = coroutine + socket。所以，可以把 cosocket 翻译为“协程套接字”。</p><p>cosocket 不仅需要 Lua 协程特性的支持，也需要 Nginx 中非常重要的事件机制的支持，这两者结合在一 起，最终实现了非阻塞网络 I/O。另外，cosocket 支持 TCP、UDP 和 Unix Domain Socket。</p><p>在 OpenResty 中调用一个 cosocket 相关函数，内部实现便是下面这张图的样子：<br><img src="/img/newimg/0081Kckwgy1glrwdfkpjvj30ye0fkjuz.jpg" srcset="/img/loading.gif" alt=""><br>用户的 Lua 脚本每触发一个网络操作，都会有协程的 yield 以及 resume。</p><p>遇到网络 I/O 时，它会交出控制权（yield），把网络事件注册到 Nginx 监听列表中，并把权限交给 Nginx；当有 Nginx 事件达到触发条件时，便唤醒对应的协程继续处理（resume）。</p><p>OpenResty 正是以此为基础，封装实现 connect、send、receive 等操作，形成了现在的 cosocket API。以处理 TCP 的 API 为例来介绍一下。处理 UDP 和 Unix Domain Socket ，与TCP 的接口基 本是一样的。</p><h3 id="cosocket-API-和指令简介"><a href="#cosocket-API-和指令简介" class="headerlink" title="cosocket API 和指令简介"></a>cosocket API 和指令简介</h3><p>TCP 相关的 cosocket API 可以分为下面这几类：</p><blockquote><p>创建对象：ngx.socket.tcp。<br>设置超时：tcpsock:settimeout 和 tcpsock:settimeouts。<br>建立连接：tcpsock:connect。<br>发送数据：tcpsock:send。<br>接受数据：tcpsock:receive、tcpsock:receiveany 和 tcpsock:receiveuntil。<br>连接池：tcpsock:setkeepalive。<br>关闭连接：tcpsock:close。</p></blockquote><p>这些 API 可以使用的上下文：</p><figure class="highlight ceylon"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ceylon"><br>rewrite<span class="hljs-number">_</span><span class="hljs-meta">by</span><span class="hljs-number">_</span>lua*, access<span class="hljs-number">_</span><span class="hljs-meta">by</span><span class="hljs-number">_</span>lua*, content<span class="hljs-number">_</span><span class="hljs-meta">by</span><span class="hljs-number">_</span>lua*, ngx.timer.*, ssl<span class="hljs-number">_</span>certificate<span class="hljs-number">_</span><span class="hljs-meta">by</span><span class="hljs-number">_</span>lua*, ssl<span class="hljs-number">_</span>session<span class="hljs-number">_f</span>etch<span class="hljs-number">_</span><span class="hljs-meta">by</span><span class="hljs-number">_</span>lua*<span class="hljs-number">_</span><br></code></pre></div></td></tr></table></figure><p>由于 Nginx 内核的各种限制，cosocket API 在 set_by_lua<em>， log_by_lua*， header_filter_by_lua</em> 和 body_filter_by_lua* 中是无法使用的。而在 init_by_lua* 和 init_worker_by_lua* 中暂时也不能用，不过 Nginx 内核对这两个阶段并没有限制。</p><p>此外，与这些 API 相关的，还有 8 个 lua_socket_ 开头的 Nginx 指令：</p><blockquote><p>lua_socket_connect_timeout：连接超时，默认 60 秒。<br>lua_socket_send_timeout：发送超时，默认 60 秒。<br>lua_socket_send_lowat：发送阈值（low water），默认为 0。<br>lua_socket_read_timeout： 读取超时，默认 60 秒。<br>lua_socket_buffer_size：读取数据的缓存区大小，默认 4k/8k。<br>lua_socket_pool_size：连接池大小，默认 30。<br>lua_socket_keepalive_timeout：连接池 cosocket 对象的空闲时间，默认 60 秒。<br>lua_socket_log_errors：cosocket 发生错误时，是否记录日志，默认为 on。</p></blockquote><p>有些指令和 API 的功能一样的，比如设置超时时间和连接池大小等。不过，如果两者有冲突的话，API 的优先级高于指令，会覆盖指令设置的值。所以，一般来说，都推荐使用 API来做设 置，这样也会更加灵活。 </p><p>通过一个具体的例子，来理解如何使用这些 cosocket API。发送 TCP 请求到一个网站，并把返回的内容打印出来：</p><figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata">resty -<span class="hljs-keyword">e</span> '<span class="hljs-keyword">local</span> sock = ngx.socket.tcp()<br>    sock:settimeout(1000) -- <span class="hljs-keyword">one</span> second timeout<br>    <span class="hljs-keyword">local</span> ok, <span class="hljs-keyword">err</span> = sock:connect(<span class="hljs-string">"www.baidu.com"</span>, 80)<br>    <span class="hljs-keyword">if</span> not ok then<br>        ngx.say(<span class="hljs-string">"failed to connect: "</span>, <span class="hljs-keyword">err</span>)<br>        <span class="hljs-keyword">return</span><br>    end<br><span class="hljs-keyword">local</span> req_data = <span class="hljs-string">"GET / HTTP/1.1\r\nHost: www.baidu.com\r\n\r\n"</span><br><span class="hljs-keyword">local</span> bytes, <span class="hljs-keyword">err</span> = sock:send(req_data)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">err</span> then<br>    ngx.say(<span class="hljs-string">"failed to send: "</span>, <span class="hljs-keyword">err</span>)<br>    <span class="hljs-keyword">return</span><br>end<br><span class="hljs-keyword">local</span> data, <span class="hljs-keyword">err</span>, partial = sock:receive()<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">err</span> then<br>    ngx.say(<span class="hljs-string">"failed to receive: "</span>, <span class="hljs-keyword">err</span>)<br>    <span class="hljs-keyword">return</span><br>end<br>sock:<span class="hljs-keyword">close</span>()<br>ngx.say(<span class="hljs-string">"response is: "</span>, data)<br></code></pre></div></td></tr></table></figure><p>分析下这段代码:</p><blockquote><p>首先，通过 ngx.socket.tcp() ，创建 TCP 的 cosocket 对象，名字是 sock。<br>然后，使用 settimeout() ，把超时时间设置为 1 秒。注这里的超时没有区分 connect、receive，是统一的设置。<br>接着，使用 connect() 去连接指定网站的 80 端口，如果失败就直接退出。<br>连接成功的话，就使用 send() 来发送构造好的数据，如果发送失败就退出。<br>发送数据成功的话，就使用 receive() 来接收网站返回的数据。这里 receive() 的默认参数值是 <em>l，也就是只返回第一行的数据；如果参数设&gt;置为了</em>a，就是持续接收数据，直到连接关闭；<br>最后，调用 close() ，主动关闭 socket 连接。</p></blockquote><p>接 下来，我们对这个示例再做一些调整:<br>第一个动作，对 socket 连接、发送和读取这三个动作，分别设置超时时间。</p><p>settimeout() 作用是把超时时间统一设置为一个值。如果要想分开设置，就需要使用 settimeouts() 函数，比如下面这样的写法：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">sock:settimeouts(<span class="hljs-number">1000</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">3000</span>)<br></code></pre></div></td></tr></table></figure><p>表示连接超时为 1 秒，发送超时为 2 秒，读取超时为 3 秒。在OpenResty 和 lua-resty 库中，大部分和时间相关的 API 的参数，都以毫秒为单位</p><p>第二个动作，receive接收指定大小的内容。</p><p>receive() 接口可以接收一行数据，也可以持续接收数据。如果只想接收 10K 大小的数据，应该使用receiveany() ，它就是专为满足这种需求而设计的</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">local</span> <span class="hljs-class"><span class="hljs-keyword">data</span>, err, partial = sock:receiveany(10240)</span><br></code></pre></div></td></tr></table></figure><p>关于receive，还有另一个很常见的用户需求，那就是一直获取数据，直到遇到指定字符串才停止。</p><p>receiveuntil() 专门用来解决这类问题，它不会像 receive() 和 receiveany() 一样返回字符串， 而会返回一个迭代器。这样就可以在循环中调用它来分段读取匹配到的数据，当读取完毕时，就会返回 nil。</p><figure class="highlight applescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs applescript"><span class="hljs-keyword">local</span> reader = sock:receiveuntil(<span class="hljs-string">"\r\n"</span>)<br><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span> do<br>    <span class="hljs-keyword">local</span> data, err, partial = reader(<span class="hljs-number">4</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">if</span> err <span class="hljs-keyword">then</span><br>            ngx.<span class="hljs-built_in">say</span>(<span class="hljs-string">"failed to read the data stream: "</span>, err)<br>            break<br>        <span class="hljs-keyword">end</span><br>        ngx.<span class="hljs-built_in">say</span>(<span class="hljs-string">"read done"</span>)<br>        break<br>    <span class="hljs-keyword">end</span><br>    ngx.<span class="hljs-built_in">say</span>(<span class="hljs-string">"read chunk: ["</span>, data, <span class="hljs-string">"]"</span>)<br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><p>receiveuntil 会返回 \r\n 之前的数据，并通过迭代器每次读取其中的 4 个字节，</p><p>第三个动作，不直接关闭 socket，而是放入连接池中。</p><p>没有连接池的话，每次请求进来都要新建一个连接，就会导致 cosocket 对象被频繁地创建和销 毁，造成不必要的性能损耗。</p><p>为了避免这个问题，在使用完一个 cosocket 后，可以调用 setkeepalive() 放到连接池中</p><figure class="highlight applescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs applescript"><span class="hljs-keyword">local</span> ok, err = sock:setkeepalive(<span class="hljs-number">2</span> * <span class="hljs-number">1000</span>, <span class="hljs-number">100</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span><br>    ngx.<span class="hljs-built_in">say</span>(<span class="hljs-string">"failed to set reusable: "</span>, err)<br><span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><p>这段代码设置了连接的空闲时间为 2 秒，连接池的大小为 100。这样，在调用 connect() 函数时，就会优先从连接池中获取 cosocket 对象。</p><p>关于连接池的使用，有两点需要注意：</p><p>第一，不能把发生错误的连接放入连接池，否则下次使用时，就会导致收发数据失败。这也是为什么需要判断每一个 API 调用是否成功的一个原因。</p><p>第二，要搞清楚连接的数量。连接池是 worker 级别的，每个 worker 都有自己的连接池。所以，如果有 10 个 worker，连接池大小设置为 30，那么对于后端的服务来讲，就等于有 300个连接。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>apisix与consul服务发现的结合使用</title>
    <link href="/2020/11/30/apisix%E4%B8%8Econsul%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E7%9A%84%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/11/30/apisix%E4%B8%8Econsul%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E7%9A%84%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>首先简单介绍一下apisix,是一个机遇openresty开发的云原生网关。功能类比于nginx+upsync 可无reload，apisix支持自身配置放在etcd中，原生高可用架构。并且支持 <code>consul</code>  <code>eruka</code>  <code>nacos</code>。</p><h2 id="实践逻辑如下"><a href="#实践逻辑如下" class="headerlink" title="实践逻辑如下"></a>实践逻辑如下</h2><h4 id="安装以下实验环境"><a href="#安装以下实验环境" class="headerlink" title="安装以下实验环境"></a>安装以下实验环境</h4><p>以下三个点作为验证环境的安装步骤。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">1.</span>安装好apisix以及相关依赖(openresty,etcd)<br><span class="hljs-number">2.</span>安装好consul组件作为服务注册与发现。<br><span class="hljs-number">3.</span>run demo案例作为业务服务。<br></code></pre></div></td></tr></table></figure><h4 id="验证逻辑"><a href="#验证逻辑" class="headerlink" title="验证逻辑"></a>验证逻辑</h4><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">1.</span>run demo代码,本身是一个http服务,并且把自己注册到consul中,持续健康检查监听。<br><span class="hljs-number">2.</span>访问 demo的http服务发现可访问<br><span class="hljs-number">3.</span>在apisix中创建url,后端服务对应demo注册到consul的servername。<br><span class="hljs-number">4.</span>使用apisix创建的url访问服务，发现访问结果与之前一致。<br></code></pre></div></td></tr></table></figure><h2 id="Install-Consul"><a href="#Install-Consul" class="headerlink" title="Install Consul"></a>Install Consul</h2><ol><li><p>download consul</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">wget https:<span class="hljs-regexp">//</span>releases.hashicorp.com<span class="hljs-regexp">/consul/</span><span class="hljs-number">1.7</span>.<span class="hljs-number">3</span><span class="hljs-regexp">/consul_1.7.3_linux_amd64.zip</span><br></code></pre></div></td></tr></table></figure></li><li><p>unzip to <code>/usr/bin</code> </p></li></ol><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">sudo unzip consul_1<span class="hljs-number">.7</span><span class="hljs-number">.3</span>_linux_amd64.zip -d /usr/bin<br></code></pre></div></td></tr></table></figure><ol start="3"><li><p>create consul service file</p><figure class="highlight crystal"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crystal">sudo vim /<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">systemd</span>/<span class="hljs-title">system</span>/<span class="hljs-title">consul</span>.<span class="hljs-title">service</span></span><br><br>[Unit]<br>Description=consul<br>[Service]<br>ExecStart=<span class="hljs-regexp">/usr/bin</span><span class="hljs-regexp">/consul agent -config-dir /etc</span><span class="hljs-regexp">/consul</span><br><span class="hljs-regexp">KillSignal=SIGINT</span><br></code></pre></div></td></tr></table></figure></li><li><p>create server json file</p><figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy">sudo mkdir <span class="hljs-regexp">/etc/</span>consul/<br><br>sudo vim <span class="hljs-regexp">/etc/</span>consul/server.json<br><br>&#123;<br><span class="hljs-string">"data_dir"</span>: <span class="hljs-string">"/var/consul"</span>,<br><span class="hljs-string">"log_level"</span>: <span class="hljs-string">"INFO"</span>,<br><span class="hljs-string">"node_name"</span>: <span class="hljs-string">"test"</span>,<br><span class="hljs-string">"server"</span>: <span class="hljs-literal">true</span>,<br><span class="hljs-string">"ui"</span>: <span class="hljs-literal">true</span>,<br><span class="hljs-string">"bootstrap_expect"</span>: <span class="hljs-number">1</span>,<br><span class="hljs-string">"client_addr"</span>: <span class="hljs-string">"0.0.0.0"</span>,<br><span class="hljs-string">"advertise_addr"</span>: <span class="hljs-string">"127.0.0.1"</span>,<br><span class="hljs-string">"ports"</span>: &#123;<br><span class="hljs-string">"dns"</span>: <span class="hljs-number">53</span><br>&#125;,<br><span class="hljs-string">"advertise_addr_wan"</span>: <span class="hljs-string">"127.0.0.1"</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>start consul</p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">sudo systemctl <span class="hljs-literal">start</span> consul<br></code></pre></div></td></tr></table></figure></li></ol><h2 id="start-service-golang-version"><a href="#start-service-golang-version" class="headerlink" title="start service - golang version"></a>start service - golang version</h2><p><img src="/img/newimg/0081Kckwgy1glwqp0m8muj30qj0qbjvm.jpg" srcset="/img/loading.gif" alt=""></p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">git clone http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/api7/consul-test-golang.git<br><br>yum -<span class="hljs-keyword">y</span> install glang <br><br><span class="hljs-keyword">go</span> env -<span class="hljs-keyword">w</span> GO111MODULE=<span class="hljs-keyword">on</span><br><br><span class="hljs-keyword">go</span> env -<span class="hljs-keyword">w</span> GOPROXY=http<span class="hljs-variable">s:</span>//goproxy.io,direct<br><br><br><span class="hljs-keyword">cd</span> consul-test-golang<br><br>nohup <span class="hljs-keyword">go</span> run main.<span class="hljs-keyword">go</span> &amp;<br></code></pre></div></td></tr></table></figure><h2 id="install-etcd-–-need-by-Apache-APISIX"><a href="#install-etcd-–-need-by-Apache-APISIX" class="headerlink" title="install etcd  – need by Apache APISIX"></a>install etcd  – need by Apache APISIX</h2><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">sudo yum <span class="hljs-keyword">install</span> etcd<br><br>nohup /usr/<span class="hljs-keyword">bin</span>/etcd <span class="hljs-comment">--enable-v2=true &amp;</span><br></code></pre></div></td></tr></table></figure><h2 id="install-openresty-–-need-by-Apache-APISIX"><a href="#install-openresty-–-need-by-Apache-APISIX" class="headerlink" title="install openresty – need by Apache APISIX"></a>install openresty – need by Apache APISIX</h2><figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy">wget <span class="hljs-string">https:</span><span class="hljs-comment">//openresty.org/package/centos/openresty.repo</span><br><br>sudo mv openresty.repo <span class="hljs-regexp">/etc/</span>yum.repos.d/<br><br>sudo yum install openresty -y<br></code></pre></div></td></tr></table></figure><h2 id="install-Apache-APISIX"><a href="#install-Apache-APISIX" class="headerlink" title="install Apache APISIX"></a>install Apache APISIX</h2><ol><li>install from RPM, and you can get the latest version from <a href="https://github.com/apache/incubator-apisix/releases" target="_blank" rel="noopener">https://github.com/apache/incubator-apisix/releases</a></li></ol><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">wget https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/apache/i</span>ncubator-apisix<span class="hljs-regexp">/releases/</span>download<span class="hljs-regexp">/1.3/</span>apisix-<span class="hljs-number">1.3</span>-<span class="hljs-number">0</span>.el7.noarch.rpm<br><br>sudo yum install apisix-<span class="hljs-number">1.3</span>-<span class="hljs-number">0</span>.el7.noarch.rpm -y<br></code></pre></div></td></tr></table></figure><ol start="2"><li>change config.yaml</li></ol><p>vi /usr/local/apisix/conf/config.yaml</p><p>add consul address to <code>dns_resolver</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">dns_resolver:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br></code></pre></div></td></tr></table></figure><ol start="3"><li>start Apache APISIX:<figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">sudo apisix <span class="hljs-literal">start</span><br></code></pre></div></td></tr></table></figure></li></ol><h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><ol><li>add route in Apache APISIX:<figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy">curl <span class="hljs-string">http:</span><span class="hljs-comment">//127.0.0.1:9080/apisix/admin/routes/1 -H 'X-API-KEY: edd1c9f034335f136f87ad84b625c8f1' -X PUT -i -d '</span><br>&#123;<br>    <span class="hljs-string">"uri"</span>: <span class="hljs-string">"/healthz"</span>,<br>    <span class="hljs-string">"upstream"</span>: &#123;<br>        <span class="hljs-string">"type"</span>: <span class="hljs-string">"roundrobin"</span>,<br>        <span class="hljs-string">"nodes"</span>: &#123;<br>            <span class="hljs-string">"go-consul-test.service.consul:8080"</span>: <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>&#125;<span class="hljs-string">'</span><br></code></pre></div></td></tr></table></figure></li></ol><p><strong>go-consul-test.service.consul is registered DNS SRV by consul-test-golang service</strong></p><ol start="2"><li>test：<br><img src="/img/newimg/0081Kckwgy1glwqqxoe77j313y086q47.jpg" srcset="/img/loading.gif" alt=""></li></ol><figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy">curl <span class="hljs-string">http:</span><span class="hljs-comment">//127.0.0.1:8080/healthz | jq</span><br></code></pre></div></td></tr></table></figure><p><img src="/img/newimg/0081Kckwgy1glwqsd3qemj314g07u75i.jpg" srcset="/img/loading.gif" alt=""></p><figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy">curl <span class="hljs-string">http:</span><span class="hljs-comment">//127.0.0.1:9080/healthz | jq</span><br></code></pre></div></td></tr></table></figure><p>能看该运行的demo已经被apisix给封装起来了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>apisix介绍以及食用方法</title>
    <link href="/2020/11/30/apisix%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E9%A3%9F%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2020/11/30/apisix%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E9%A3%9F%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="Apache-APISIX-是什么？"><a href="#Apache-APISIX-是什么？" class="headerlink" title="Apache APISIX 是什么？"></a>Apache APISIX 是什么？</h2><p>Apache APISIX 是一个动态、实时、高性能的 API 网关，基于 Nginx 网络库和 etcd 实现，<br>提供负载均衡、动态上游、灰度发布、服务熔断、身份认证、可观测性等丰富的流量管理功能。</p><p>你可以使用 Apache APISIX 来处理传统的南北向流量，以及服务间的东西向流量，<br>也可以当做 k8s ingress controller 来使用。</p><p>Apache APISIX 的技术架构如下图所示：</p><p><img src="/img/newimg/0081Kckwgy1gl85xhdvnoj30th0fmju8.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#特性">特性</a></li><li><a href="#立刻开始">立刻开始</a></li><li><a href="#控制台">控制台</a></li><li><a href="#性能测试">性能测试</a></li><li><a href="#apache-apisix-和-kong-的比较">Apache APISIX 和 Kong 的比较</a></li><li><a href="#开放治理">开放治理</a></li><li><a href="#社区">社区</a></li><li><a href="#视频和文章">视频和文章</a></li></ul><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>你可以把 Apache APISIX 当做流量入口，来处理所有的业务数据，包括动态路由、动态上游、动态证书、<br>A/B 测试、金丝雀发布(灰度发布)、蓝绿部署、限流限速、抵御恶意攻击、监控报警、服务可观测性、服务治理等。</p><ul><li><p><strong>全平台</strong></p><ul><li>云原生: 平台无关，没有供应商锁定，无论裸机还是 Kubernetes，APISIX 都可以运行。</li><li>运行环境: OpenResty 和 Tengine 都支持。</li><li>支持 ARM64: 不用担心底层技术的锁定。</li></ul></li><li><p><strong>多协议</strong></p><ul><li><a href="doc/zh-cn/stream-proxy.md">TCP/UDP 代理</a>: 动态 TCP/UDP 代理。</li><li><a href="doc/zh-cn/plugins/mqtt-proxy.md">动态 MQTT 代理</a>: 支持用 <code>client_id</code> 对 MQTT 进行负载均衡，同时支持 MQTT <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html" target="_blank" rel="noopener">3.1.*</a> 和 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.html" target="_blank" rel="noopener">5.0</a> 两个协议标准。</li><li><a href="doc/zh-cn/grpc-proxy.md">gRPC 代理</a>：通过 APISIX 代理 gRPC 连接，并使用 APISIX 的大部分特性管理你的 gRPC 服务。</li><li><a href="doc/zh-cn/plugins/grpc-transcode.md">gRPC 协议转换</a>：支持协议的转换，这样客户端可以通过 HTTP/JSON 来访问你的 gRPC API。</li><li>Websocket 代理</li><li>Proxy Protocol</li><li>Dubbo 代理：基于 Tengine，可以实现 Dubbo 请求的代理。</li><li>HTTP(S) 反向代理</li><li><a href="doc/zh-cn/https.md">SSL</a>：动态加载 SSL 证书。</li></ul></li><li><p><strong>全动态能力</strong></p><ul><li><a href="doc/zh-cn/plugins.md">热更新和热插件</a>: 无需重启服务，就可以持续更新配置和插件。</li><li><a href="doc/zh-cn/plugins/proxy-rewrite.md">代理请求重写</a>: 支持重写请求上游的<code>host</code>、<code>uri</code>、<code>schema</code>、<code>enable_websocket</code>、<code>headers</code>信息。</li><li><a href="doc/zh-cn/plugins/response-rewrite.md">输出内容重写</a>: 支持自定义修改返回内容的 <code>status code</code>、<code>body</code>、<code>headers</code>。</li><li><a href="doc/zh-cn/plugins/serverless.md">Serverless</a>: 在 APISIX 的每一个阶段，你都可以添加并调用自己编写的函数。</li><li>动态负载均衡：动态支持有权重的 round-robin 负载平衡。</li><li>支持一致性 hash 的负载均衡：动态支持一致性 hash 的负载均衡。</li><li><a href="doc/zh-cn/health-check.md">健康检查</a>：启用上游节点的健康检查，将在负载均衡期间自动过滤不健康的节点，以确保系统稳定性。</li><li>熔断器: 智能跟踪不健康上游服务。</li><li><a href="doc/zh-cn/plugins/proxy-mirror.md">代理镜像</a>: 提供镜像客户端请求的能力。</li></ul></li><li><p><strong>精细化路由</strong></p><ul><li><a href="doc/router-radixtree.md#how-to-use-libradixtree-in-apisix">支持全路径匹配和前缀匹配</a></li><li><a href="/doc/router-radixtree.md#how-to-filter-route-by-nginx-builtin-variable">支持使用 Nginx 所有内置变量做为路由的条件</a>，所以你可以使用 <code>cookie</code>, <code>args</code> 等做为路由的条件，来实现灰度发布、A/B 测试等功能</li><li>支持<a href="https://github.com/iresty/lua-resty-radixtree#operator-list" target="_blank" rel="noopener">各类操作符做为路由的判断条件</a>，比如 <code>{&quot;arg_age&quot;, &quot;&gt;&quot;, 24}</code></li><li>支持<a href="https://github.com/iresty/lua-resty-radixtree/blob/master/t/filter-fun.t#L10" target="_blank" rel="noopener">自定义路由匹配函数</a></li><li>IPv6：支持使用 IPv6 格式匹配路由</li><li>支持路由的<a href="doc/zh-cn/admin-api.md#route">自动过期(TTL)</a></li><li><a href="doc/router-radixtree.md#3-match-priority">支持路由的优先级</a></li><li><a href="doc/zh-cn/plugins/batch-requests.md">支持批量 Http 请求</a></li></ul></li><li><p><strong>安全防护</strong></p><ul><li>多种身份认证方式: <a href="doc/zh-cn/plugins/key-auth.md">key-auth</a>, <a href="doc/zh-cn/plugins/jwt-auth.md">JWT</a>, <a href="doc/zh-cn/plugins/basic-auth.md">basic-auth</a>, <a href="doc/zh-cn/plugins/wolf-rbac.md">wolf-rbac</a>。</li><li><a href="doc/zh-cn/plugins/ip-restriction.md">IP 黑白名单</a></li><li><a href="doc/zh-cn/plugins/referer-restriction.md">Referer 白名单</a></li><li><a href="doc/plugins/openid-connect.md">IdP 支持</a>: 支持外部的身份认证服务，比如 Auth0，Okta，Authing 等，用户可以借此来对接 Oauth2.0 等认证方式。</li><li><a href="doc/zh-cn/plugins/limit-req.md">限制速率</a></li><li><a href="doc/zh-cn/plugins/limit-count.md">限制请求数</a></li><li><a href="doc/zh-cn/plugins/limit-conn.md">限制并发</a></li><li>防御 ReDoS(正则表达式拒绝服务)：内置策略，无需配置即可抵御 ReDoS。</li><li><a href="doc/zh-cn/plugins/cors.md">CORS</a>：为你的 API 启用 CORS。</li><li><a href="doc/zh-cn/plugins/uri-blocker.md">URI 拦截器</a>：根据 URI 拦截用户请求。</li><li><a href="doc/zh-cn/plugins/request-validation.md">请求验证器</a>。</li></ul></li><li><p><strong>运维友好</strong></p><ul><li>OpenTracing 可观测性: 支持 <a href="doc/zh-cn/plugins/skywalking.md">Apache Skywalking</a> 和 <a href="doc/zh-cn/plugins/zipkin.md">Zipkin</a>。</li><li>对接外部服务发现：除了内置的 etcd 外，还支持 <code>Consul</code> 和 <code>Nacos</code> 的 <a href="https://github.com/apache/apisix/issues/1731#issuecomment-646392129" target="_blank" rel="noopener">DNS 发现模式</a>，以及 <a href="doc/zh-cn/discovery.md">Eureka</a>。</li><li>监控和指标: <a href="doc/zh-cn/plugins/prometheus.md">Prometheus</a></li><li>集群：APISIX 节点是无状态的，创建配置中心集群请参考 <a href="https://github.com/etcd-io/etcd/blob/master/Documentation/op-guide/clustering.md" target="_blank" rel="noopener">etcd Clustering Guide</a>。</li><li>高可用：支持配置同一个集群内的多个 etcd 地址。</li><li>控制台: 内置控制台来操作 APISIX 集群。</li><li>版本控制：支持操作的多次回滚。</li><li>CLI: 使用命令行来启动、关闭和重启 APISIX。</li><li><a href="doc/zh-cn/stand-alone.md">单机模式</a>: 支持从本地配置文件中加载路由规则，在 kubernetes(k8s) 等环境下更友好。</li><li><a href="doc/zh-cn/architecture-design.md#Global-Rule">全局规则</a>：允许对所有请求执行插件，比如黑白名单、限流限速等。</li><li>高性能：在单核上 QPS 可以达到 18k，同时延迟只有 0.2 毫秒。</li><li><a href="doc/zh-cn/plugins/fault-injection.md">故障注入</a></li><li><a href="doc/zh-cn/admin-api.md">REST Admin API</a>: 使用 REST Admin API 来控制 Apache APISIX，默认只允许 127.0.0.1 访问，你可以修改 <code>conf/config.yaml</code> 中的 <code>allow_admin</code> 字段，指定允许调用 Admin API 的 IP 列表。同时需要注意的是，Admin API 使用 key auth 来校验调用者身份，<strong>在部署前需要修改 <code>conf/config.yaml</code> 中的 <code>admin_key</code> 字段，来保证安全。</strong></li><li>外部日志记录器：将访问日志导出到外部日志管理工具。(<a href="doc/plugins/http-logger.md">HTTP Logger</a>, <a href="doc/plugins/tcp-logger.md">TCP Logger</a>, <a href="doc/plugins/kafka-logger.md">Kafka Logger</a>, <a href="doc/plugins/udp-logger.md">UDP Logger</a>)</li></ul></li><li><p><strong>高度可扩展</strong></p><ul><li><a href="doc/zh-cn/plugin-develop.md">自定义插件</a>: 允许挂载常见阶段，例如<code>init</code>, <code>rewrite</code>，<code>access</code>，<code>balancer</code>,<code>header filer</code>，<code>body filter</code> 和 <code>log</code> 阶段。</li><li>自定义负载均衡算法：可以在 <code>balancer</code> 阶段使用自定义负载均衡算法。</li><li>自定义路由: 支持用户自己实现路由算法。</li></ul></li></ul><h2 id="Apache-APISIX-和-Kong-的比较"><a href="#Apache-APISIX-和-Kong-的比较" class="headerlink" title="Apache APISIX 和 Kong 的比较"></a>Apache APISIX 和 Kong 的比较</h2><h4 id="API-网关核心功能点，两者均已覆盖"><a href="#API-网关核心功能点，两者均已覆盖" class="headerlink" title="API 网关核心功能点，两者均已覆盖"></a>API 网关核心功能点，两者均已覆盖</h4><table><thead><tr><th align="left"><strong>功能</strong></th><th align="left"><strong>Apache APISIX</strong></th><th align="left"><strong>KONG</strong></th></tr></thead><tbody><tr><td align="left"><strong>动态上游</strong></td><td align="left">支持</td><td align="left">支持</td></tr><tr><td align="left"><strong>动态路由</strong></td><td align="left">支持</td><td align="left">支持</td></tr><tr><td align="left"><strong>健康检查和熔断器</strong></td><td align="left">支持</td><td align="left">支持</td></tr><tr><td align="left"><strong>动态 SSL 证书</strong></td><td align="left">支持</td><td align="left">支持</td></tr><tr><td align="left"><strong>七层和四层代理</strong></td><td align="left">支持</td><td align="left">支持</td></tr><tr><td align="left"><strong>分布式追踪</strong></td><td align="left">支持</td><td align="left">支持</td></tr><tr><td align="left"><strong>自定义插件</strong></td><td align="left">支持</td><td align="left">支持</td></tr><tr><td align="left"><strong>REST API</strong></td><td align="left">支持</td><td align="left">支持</td></tr><tr><td align="left"><strong>CLI</strong></td><td align="left">支持</td><td align="left">支持</td></tr></tbody></table><h4 id="Apache-APISIX-的优势"><a href="#Apache-APISIX-的优势" class="headerlink" title="Apache APISIX 的优势"></a>Apache APISIX 的优势</h4><table><thead><tr><th align="left"><strong>功能</strong></th><th align="left"><strong>Apache APISIX</strong></th><th align="left"><strong>KONG</strong></th></tr></thead><tbody><tr><td align="left">项目归属</td><td align="left">Apache 软件基金会</td><td align="left">Kong Inc.</td></tr><tr><td align="left">技术架构</td><td align="left">Nginx + etcd</td><td align="left">Nginx + postgres</td></tr><tr><td align="left">交流渠道</td><td align="left">微信群、QQ 群、邮件列表、Github、meetup</td><td align="left">Github、论坛、freenode</td></tr><tr><td align="left">单核 QPS (开启限流和 prometheus 插件)</td><td align="left">18000</td><td align="left">1700</td></tr><tr><td align="left">平均延迟</td><td align="left">0.2 毫秒</td><td align="left">2 毫秒</td></tr><tr><td align="left">支持 Dubbo 代理</td><td align="left">是</td><td align="left">否</td></tr><tr><td align="left">配置回滚</td><td align="left">是</td><td align="left">否</td></tr><tr><td align="left">支持生命周期的路由</td><td align="left">是</td><td align="left">否</td></tr><tr><td align="left">插件热更新</td><td align="left">是</td><td align="left">否</td></tr><tr><td align="left">用户自定义：负载均衡算法、路由</td><td align="left">是</td><td align="left">否</td></tr><tr><td align="left">resty &lt;–&gt; gRPC 转码</td><td align="left">是</td><td align="left">否</td></tr><tr><td align="left">支持 Tengine 作为运行时</td><td align="left">是</td><td align="left">否</td></tr><tr><td align="left">MQTT 协议支持</td><td align="left">是</td><td align="left">否</td></tr><tr><td align="left">配置生效时间</td><td align="left">事件通知，低于 1 毫秒更新</td><td align="left">定期轮询，5 秒</td></tr><tr><td align="left">自带控制台</td><td align="left">是</td><td align="left">否</td></tr><tr><td align="left">对接外部身份认证服务</td><td align="left">是</td><td align="left">否</td></tr><tr><td align="left">配置中心高可用(HA)</td><td align="left">是</td><td align="left">否</td></tr><tr><td align="left">指定时间窗口的限速</td><td align="left">是</td><td align="left">否</td></tr><tr><td align="left">支持任何 Nginx 变量做路由条件</td><td align="left">是</td><td align="left">否</td></tr></tbody></table><p>性能对比测试<a href="https://gist.github.com/membphis/137db97a4bf64d3653aa42f3e016bd01" target="_blank" rel="noopener">详细内容如下</a>。</p><h2 id="视频和文章"><a href="#视频和文章" class="headerlink" title="视频和文章"></a>视频和文章</h2><ul><li>2020.10.16 <a href="https://www.youtube.com/watch?v=iEegNXOtEhQ" target="_blank" rel="noopener">Apache APISIX: How to implement plugin orchestration in API Gateway</a></li><li>2020.10.16 <a href="https://www.youtube.com/watch?v=DleVJwPs4i4" target="_blank" rel="noopener">Improve Apache APISIX observability with Apache Skywalking</a></li><li>2020.1.17 <a href="https://mp.weixin.qq.com/s/c51apneVj0O9yxiZAHF34Q" target="_blank" rel="noopener">API 网关 Apache APISIX 和 Kong 的选型对比</a></li><li>2019.12.14 <a href="https://zhuanlan.zhihu.com/p/99620158" target="_blank" rel="noopener">从 0 到 1：Apache APISIX 的 Apache 之路</a></li><li>2019.12.14 <a href="https://www.upyun.com/opentalk/445.html" target="_blank" rel="noopener">基于 Apache APISIX 的下一代微服务架构</a></li><li>2019.10.30 <a href="https://www.upyun.com/opentalk/440.html" target="_blank" rel="noopener">Apache APISIX 微服务架构极致性能架构解析</a></li><li>2019.9.27 <a href="https://zhuanlan.zhihu.com/p/84467919" target="_blank" rel="noopener">想把 APISIX 运行在 ARM64 平台上？只要三步</a></li><li>2019.8.31 <a href="https://www.upyun.com/opentalk/433.html" target="_blank" rel="noopener">APISIX 技术选型、测试和持续集成</a></li><li>2019.8.31 <a href="https://www.upyun.com/opentalk/437.html" target="_blank" rel="noopener">APISIX 高性能实战 2</a></li><li>2019.7.6 <a href="https://www.upyun.com/opentalk/429.html" target="_blank" rel="noopener">APISIX 高性能实战</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说 apisix作为云原生网关,比其他的性能好的同时，稳定性可扩展性 都有质的提升。作为新一代网关的考虑范围内。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>安装docker</title>
    <link href="/2020/10/26/%E5%AE%89%E8%A3%85docker/"/>
    <url>/2020/10/26/%E5%AE%89%E8%A3%85docker/</url>
    
    <content type="html"><![CDATA[<p>在物联网以及arm板子安装docker比较麻烦。直接用官方的安装脚本然后用阿里的源安装会比较方便<br>hin简单</p><p>curl -fsSL <a href="https://get.docker.com" target="_blank" rel="noopener">https://get.docker.com</a> | bash -s docker –mirror Aliyun</p><p>配置阿里源镜像<br>sudo mkdir -p /etc/docker<br>sudo tee /etc/docker/daemon.json &lt;&lt;-‘EOF’<br>{<br>    “registry-mirrors”: [“<a href="https://55bqr8pu.mirror.aliyuncs.com&quot;]">https://55bqr8pu.mirror.aliyuncs.com&quot;]</a><br>}<br>EOF sudo systemctl daemon-reload sudo systemctl restart docker</p><p>完事。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>pi4B  kubelet  Following Cgroup subsystem not mounted </title>
    <link href="/2020/10/22/pi4B-kubelet-Following-Cgroup-subsystem-not-mounted/"/>
    <url>/2020/10/22/pi4B-kubelet-Following-Cgroup-subsystem-not-mounted/</url>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">在树莓派<span class="hljs-number">4</span>B中安装了ubuntu <span class="hljs-number">20.04</span><span class="hljs-number">.1</span> LTS 然后接入k8s(kubeedge)集群。<br></code></pre></div></td></tr></table></figure><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p><img src="https://i.loli.net/2020/10/22/GhPvMuNeEfdtKF4.png" srcset="/img/loading.gif" alt="pi4.png"></p><p>发现kubelet一直启动不起来,报错为 <code>Following Cgroup subsystem not mounted: [memory]</code><br>大概意思是主机没有挂载内存的Cgroup，但是kubelet是需要控制cpu以及内存的Cgroup。所以启动不起来</p><h3 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h3><p>知道问题了,但是百度了半天大家都说是需要在<code>/boot/cmdline.txt</code> 中加入<code>cgroup_enable=memory cgroup_memory=1</code>然后重启即可。<br>但是重启问题依旧，然后查看引导</p><figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata"><span class="hljs-keyword">cat</span> /<span class="hljs-keyword">boot</span>/firmware/config.txt<br></code></pre></div></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/22/kXeqVdLz6iRJQgO.png" srcset="/img/loading.gif" alt="image.png"></p><p>发现还是这个名字,最后实在没办法就吧<code>cmdline.txt</code>放到了<code>/boot/firmware/</code>下。然后就成功了 </p><h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>只是记录一下坑，毫无卵用。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>gin源码解读</title>
    <link href="/2020/09/03/gin%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <url>/2020/09/03/gin%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Proxmox介绍以及安装使用</title>
    <link href="/2020/07/22/Proxmox%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/07/22/Proxmox%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 skopeo 操作容器镜像</title>
    <link href="/2020/07/15/%E4%BD%BF%E7%94%A8-skopeo-%E6%93%8D%E4%BD%9C%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/"/>
    <url>/2020/07/15/%E4%BD%BF%E7%94%A8-skopeo-%E6%93%8D%E4%BD%9C%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>今天项目组突然提出一个需求,跟其他应用放对接的时候提供一个镜像仓库。对接放把应用上传完以后。我们需要将这些镜像都打成tar包存到oss中。</p><figure class="highlight gauss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gauss">问题如下:<br>  镜像仓库每个都很大(内部是数据模型以及算法)怎么能保证完整下下来不影响业务网络<br>  镜像都得打tar包，但是本地存储限制 没那么大  并且耗时<br>  后续扩展跟其他库同步麻烦。需要一个个<span class="hljs-keyword">load</span>进去然后倒入<br></code></pre></div></td></tr></table></figure><p>根据以上的需求进行分析,目的很明确 </p><blockquote><p>1.需要找到一个能直接下载docker镜像并且最好是直接打tar包的工具<br>2.最好能镜像库与库之间的同步<br>3.这个工具最好不依赖docker</p></blockquote><p>为啥说最好不依赖docker呢，这里并不是对docker有啥歧视的地方,见下图<br><img src="/img/newimg/007S8ZIlgy1ggrlwuw4j9j317g04g0va.jpg" srcset="/img/loading.gif" alt=""><br>我明明只需要个命令行工具来进行镜像的下载上传，并不需要真正的run起来。但是docker傻乎乎的需要程序进行守护启动才能进行镜像下载  增大维护度</p><h3 id="skopeo的使用"><a href="#skopeo的使用" class="headerlink" title="skopeo的使用"></a>skopeo的使用</h3><p>到github找了找,发现官方已经有这样的工具了 并且完美支持我的需求 <a href="https://github.com/containers/skopeo" target="_blank" rel="noopener">项目地址</a></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake"><span class="hljs-comment"># centos</span><br>yum <span class="hljs-keyword">install</span> skopeo<br></code></pre></div></td></tr></table></figure><p>其他系统安装见<a href="https://github.com/containers/skopeo/blob/master/install.md" target="_blank" rel="noopener">安装文档</a></p><h5 id="不借助-docker-下载镜像"><a href="#不借助-docker-下载镜像" class="headerlink" title="不借助 docker 下载镜像"></a>不借助 docker 下载镜像</h5><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">skopeo <span class="hljs-params">--insecure-policy</span> copy docker:<span class="hljs-string">//nginx</span><span class="hljs-function">:1.17.6</span> docker-archive:<span class="hljs-string">/tmp/nginx.tar</span><br></code></pre></div></td></tr></table></figure><p><code>--insecure-policy</code> 选项用于忽略安全策略配置文件，该命令将会直接通过 http 下载目标镜像并存储为 <code>/tmp/nginx.tar</code>，此文件可以直接通过 <code>docker load</code> 命令导入</p><h5 id="从-docker-daemon-导出镜像"><a href="#从-docker-daemon-导出镜像" class="headerlink" title="从 docker daemon 导出镜像"></a>从 docker daemon 导出镜像</h5><figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy">skopeo --insecure-policy copy docker-<span class="hljs-string">daemon:</span><span class="hljs-string">nginx:</span><span class="hljs-number">1.17</span><span class="hljs-number">.6</span> docker-<span class="hljs-string">archive:</span><span class="hljs-regexp">/tmp/</span>nginx.tar<br></code></pre></div></td></tr></table></figure><p>该命令将会从 docker daemon 导出镜像到 <code>/tmp/nginx.tar</code>；为什么不用 docker save？因为我是偷懒 dest 也是 docker-archive，实际上 skopeo 可以导出为其他格式比如 <code>oci</code>、<code>oci-archive</code>、<code>ostree</code> 等</p><h5 id="远程获取镜像的信息"><a href="#远程获取镜像的信息" class="headerlink" title="远程获取镜像的信息"></a>远程获取镜像的信息</h5><p>skopeo 可以在不用下载镜像的情况下，获取镜像信息</p><figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c"><br><span class="hljs-meta"># skopeo inspect docker:<span class="hljs-comment">//docker.io/centos</span></span><br>&#123;<br>    <span class="hljs-string">"Name"</span>: <span class="hljs-string">"docker.io/library/centos"</span>,<br>    <span class="hljs-string">"Digest"</span>: <span class="hljs-string">"sha256:fe8d824220415eed5477b63addf40fb06c3b049404242b31982106ac204f6700"</span>,<br>    <span class="hljs-string">"RepoTags"</span>: [<br>        <span class="hljs-string">"5.11"</span>,<br>        <span class="hljs-string">"5"</span>,<br>        <span class="hljs-string">"6.10"</span>,<br>        <span class="hljs-string">"6.6"</span>,<br>        <span class="hljs-string">"6.7"</span>,<br>        <span class="hljs-string">"6.8"</span>,<br>        <span class="hljs-string">"6.9"</span>,<br>        <span class="hljs-string">"6"</span>,<br>        <span class="hljs-string">"7.0.1406"</span>,<br>        <span class="hljs-string">"7.1.1503"</span>,<br>        <span class="hljs-string">"7.2.1511"</span>,<br>        <span class="hljs-string">"7.3.1611"</span>,<br>        <span class="hljs-string">"7.4.1708"</span>,<br>        <span class="hljs-string">"7.5.1804"</span>,<br>        <span class="hljs-string">"7.6.1810"</span>,<br>        <span class="hljs-string">"7.7.1908"</span>,<br>        <span class="hljs-string">"7"</span>,<br>        <span class="hljs-string">"8.1.1911"</span>,<br>        <span class="hljs-string">"8"</span>,<br>        <span class="hljs-string">"centos5.11"</span>,<br>        <span class="hljs-string">"centos5"</span>,<br>        <span class="hljs-string">"centos6.10"</span>,<br>        <span class="hljs-string">"centos6.6"</span>,<br>        <span class="hljs-string">"centos6.7"</span>,<br>        <span class="hljs-string">"centos6.8"</span>,<br>        <span class="hljs-string">"centos6.9"</span>,<br>        <span class="hljs-string">"centos6"</span>,<br>        <span class="hljs-string">"centos7.0.1406"</span>,<br>        <span class="hljs-string">"centos7.1.1503"</span>,<br>        <span class="hljs-string">"centos7.2.1511"</span>,<br>        <span class="hljs-string">"centos7.3.1611"</span>,<br>        <span class="hljs-string">"centos7.4.1708"</span>,<br>        <span class="hljs-string">"centos7.5.1804"</span>,<br>        <span class="hljs-string">"centos7.6.1810"</span>,<br>        <span class="hljs-string">"centos7.7.1908"</span>,<br>        <span class="hljs-string">"centos7"</span>,<br>        <span class="hljs-string">"centos8.1.1911"</span>,<br>        <span class="hljs-string">"centos8"</span>,<br>        <span class="hljs-string">"latest"</span><br>    ],<br>    <span class="hljs-string">"Created"</span>: <span class="hljs-string">"2020-01-18T00:26:46.850750902Z"</span>,<br>    <span class="hljs-string">"DockerVersion"</span>: <span class="hljs-string">"18.06.1-ce"</span>,<br>    <span class="hljs-string">"Labels"</span>: &#123;<br>        <span class="hljs-string">"org.label-schema.build-date"</span>: <span class="hljs-string">"20200114"</span>,<br>        <span class="hljs-string">"org.label-schema.license"</span>: <span class="hljs-string">"GPLv2"</span>,<br>        <span class="hljs-string">"org.label-schema.name"</span>: <span class="hljs-string">"CentOS Base Image"</span>,<br>        <span class="hljs-string">"org.label-schema.schema-version"</span>: <span class="hljs-string">"1.0"</span>,<br>        <span class="hljs-string">"org.label-schema.vendor"</span>: <span class="hljs-string">"CentOS"</span>,<br>        <span class="hljs-string">"org.opencontainers.image.created"</span>: <span class="hljs-string">"2020-01-14 00:00:00-08:00"</span>,<br>        <span class="hljs-string">"org.opencontainers.image.licenses"</span>: <span class="hljs-string">"GPL-2.0-only"</span>,<br>        <span class="hljs-string">"org.opencontainers.image.title"</span>: <span class="hljs-string">"CentOS Base Image"</span>,<br>        <span class="hljs-string">"org.opencontainers.image.vendor"</span>: <span class="hljs-string">"CentOS"</span><br>    &#125;,<br>    <span class="hljs-string">"Architecture"</span>: <span class="hljs-string">"amd64"</span>,<br>    <span class="hljs-string">"Os"</span>: <span class="hljs-string">"linux"</span>,<br>    <span class="hljs-string">"Layers"</span>: [<br>        <span class="hljs-string">"sha256:8a29a15cefaeccf6545f7ecf11298f9672d2f0cdaf9e357a95133ac3ad3e1f07"</span><br>    ]<br>&#125;<br></code></pre></div></td></tr></table></figure><p>docker://: 是使用 Docker Registry HTTP API V2 进行连接远端<br>docker.io: 远程仓库<br>centos: 镜像名称</p><h5 id="镜像仓的认证文件"><a href="#镜像仓的认证文件" class="headerlink" title="镜像仓的认证文件"></a>镜像仓的认证文件</h5><p>认证文件默认存放在 $HOME/.docker/config.json<br>文件内容</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">"auths"</span>: &#123;<br><span class="hljs-attr">"myregistrydomain.com:5000"</span>: &#123;<br><span class="hljs-attr">"auth"</span>: <span class="hljs-string">"dGVzdHVzZXI6dGVzdHBhc3N3b3Jk"</span>,<br><span class="hljs-attr">"email"</span>: <span class="hljs-string">"stuf@ex.cm"</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h5><p>skopeo 还有一些其他的实用命令，比如 sync 可以在两个位置之间同步镜像.</p><h3 id="源码赏析"><a href="#源码赏析" class="headerlink" title="源码赏析"></a>源码赏析</h3><p>暂时先埋个坑 以后再写</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JWT的原理和用法</title>
    <link href="/2020/07/14/JWT%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E7%94%A8%E6%B3%95/"/>
    <url>/2020/07/14/JWT%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="啥是JWT"><a href="#啥是JWT" class="headerlink" title="啥是JWT"></a>啥是JWT</h3><p>JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案。</p><h3 id="为啥会有JWT"><a href="#为啥会有JWT" class="headerlink" title="为啥会有JWT"></a>为啥会有JWT</h3><p>互联网服务离不开用户认证。一般流程是下面这样。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">1</span>、用户向服务器发送用户名和密码。<br><br><span class="hljs-number">2</span>、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。<br><br><span class="hljs-number">3</span>、服务器向用户返回一个 session_id，写入用户的 Cookie。<br><br><span class="hljs-number">4</span>、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。<br><br><span class="hljs-number">5</span>、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。<br></code></pre></div></td></tr></table></figure><p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p><p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p><p>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p><p>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p><h3 id="JWT-的原理"><a href="#JWT-的原理" class="headerlink" title="JWT 的原理"></a>JWT 的原理</h3><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">"姓名"</span>: <span class="hljs-string">"dashabi"</span>,<br>  <span class="hljs-attr">"角色"</span>: <span class="hljs-string">"管理员"</span>,<br>  <span class="hljs-attr">"到期时间"</span>: <span class="hljs-string">"2020年7月15日0点0分"</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。</p><p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p><h3 id="JWT-的数据结构"><a href="#JWT-的数据结构" class="headerlink" title="JWT 的数据结构"></a>JWT 的数据结构</h3><p>实际的 JWT 大概就像下面这样。<br><img src="/img/newimg/007S8ZIlgy1ggrmz6bwctj315e096n7h.jpg" srcset="/img/loading.gif" alt=""></p><p>它是一个很长的字符串，中间用点<code>（.）</code>分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。</p><p>JWT 的三个部分依次如下。</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute"><span class="hljs-nomarkup">Header</span></span>（头部）<br><span class="hljs-attribute">Payload</span>（负载）<br><span class="hljs-attribute">Signature</span>（签名）<br></code></pre></div></td></tr></table></figure><p>写成一行，就是下面的样子。</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">Header</span><span class="hljs-selector-class">.Payload</span><span class="hljs-selector-class">.Signature</span><br></code></pre></div></td></tr></table></figure><h3 id="具体讲解JWT三部分"><a href="#具体讲解JWT三部分" class="headerlink" title="具体讲解JWT三部分"></a>具体讲解JWT三部分</h3><h4 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h4><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">"alg"</span>: <span class="hljs-string">"HS256"</span>,<br>  <span class="hljs-attr">"typ"</span>: <span class="hljs-string">"JWT"</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面代码中，alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。</p><p>最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。</p><h4 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h4><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。</p><figure class="highlight erlang"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">iss</span> <span class="hljs-params">(issuer)</span>：签发人</span><br><span class="hljs-function"><span class="hljs-title">exp</span> <span class="hljs-params">(expiration time)</span>：过期时间</span><br><span class="hljs-function"><span class="hljs-title">sub</span> <span class="hljs-params">(subject)</span>：主题</span><br><span class="hljs-function"><span class="hljs-title">aud</span> <span class="hljs-params">(audience)</span>：受众</span><br><span class="hljs-function"><span class="hljs-title">nbf</span> <span class="hljs-params">(Not Before)</span>：生效时间</span><br><span class="hljs-function"><span class="hljs-title">iat</span> <span class="hljs-params">(Issued At)</span>：签发时间</span><br><span class="hljs-function"><span class="hljs-title">jti</span> <span class="hljs-params">(JWT ID)</span>：编号</span><br></code></pre></div></td></tr></table></figure><p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">"sub"</span>: <span class="hljs-string">"1234567890"</span>,<br>  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"John Doe"</span>,<br>  <span class="hljs-attr">"admin"</span>: <span class="hljs-literal">true</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p><p>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p><h4 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h4><p>Signature 部分是对前两部分的签名，防止数据篡改。</p><p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">HMACSHA256(<br>  base64UrlEncode(<span class="hljs-name">header</span>) + <span class="hljs-string">"."</span> +<br>  base64UrlEncode(<span class="hljs-name">payload</span>),<br>  secret)<br></code></pre></div></td></tr></table></figure><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。</p><h3 id="Base64URL"><a href="#Base64URL" class="headerlink" title="Base64URL"></a>Base64URL</h3><p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。</p><p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符+、/和=，在 URL 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 Base64URL 算法。</p><h3 id="JWT-的使用方式"><a href="#JWT-的使用方式" class="headerlink" title="JWT 的使用方式"></a>JWT 的使用方式</h3><p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</p><p>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-symbol">Authorization:</span> Bearer <span class="hljs-params">&lt;token&gt;</span><br></code></pre></div></td></tr></table></figure><p>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p><h3 id="JWT-的几个特点"><a href="#JWT-的几个特点" class="headerlink" title="JWT 的几个特点"></a>JWT 的几个特点</h3><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">（<span class="hljs-number">1</span>）<span class="hljs-keyword">JWT </span>默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。<br><br>（<span class="hljs-number">2</span>）<span class="hljs-keyword">JWT </span>不加密的情况下，不能将秘密数据写入 <span class="hljs-keyword">JWT。</span><br><span class="hljs-keyword"></span><br><span class="hljs-keyword">（3）JWT </span>不仅可以用于认证，也可以用于交换信息。有效使用 <span class="hljs-keyword">JWT，可以降低服务器查询数据库的次数。</span><br><span class="hljs-keyword"></span><br><span class="hljs-keyword">（4）JWT </span>的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 <span class="hljs-keyword">JWT </span>签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。<br><br>（<span class="hljs-number">5</span>）<span class="hljs-keyword">JWT </span>本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，<span class="hljs-keyword">JWT </span>的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。<br><br>（<span class="hljs-number">6</span>）为了减少盗用，<span class="hljs-keyword">JWT </span>不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用Air实现gin框架实时重新加载</title>
    <link href="/2020/07/14/%E4%BD%BF%E7%94%A8Air%E5%AE%9E%E7%8E%B0gin%E6%A1%86%E6%9E%B6%E5%AE%9E%E6%97%B6%E9%87%8D%E6%96%B0%E5%8A%A0%E8%BD%BD/"/>
    <url>/2020/07/14/%E4%BD%BF%E7%94%A8Air%E5%AE%9E%E7%8E%B0gin%E6%A1%86%E6%9E%B6%E5%AE%9E%E6%97%B6%E9%87%8D%E6%96%B0%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h3 id="为什么需要实时加载？"><a href="#为什么需要实时加载？" class="headerlink" title="为什么需要实时加载？"></a>为什么需要实时加载？</h3><p>之前使用Python编写Web项目的时候，常见的Flask或Django框架都是支持实时加载的，你修改了项目代码之后，程序能够自动重新加载并执行（live-reload），这在日常的开发阶段是十分方便的。</p><p>在使用Go语言的gin框架在本地做开发调试的时候，经常需要在变更代码之后频繁的按下Ctrl+C停止程序并重新编译再执行，这样就不是很方便。</p><h3 id="Air介绍"><a href="#Air介绍" class="headerlink" title="Air介绍"></a>Air介绍</h3><p>怎样才能在基于gin框架开发时实现实时加载功能呢？像这种烦恼肯定不会只是你一个人的烦恼，所以我报着肯定有现成轮子的心态开始了全网大搜索。果不其然就在Github上找到了一个工具：<a href="https://github.com/cosmtrek/air" target="_blank" rel="noopener">Air</a>。它支持以下特性：</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">彩色日志输出<br>自定义构建或二进制命令<br>支持忽略子目录<br>启动后支持监听新目录<br>更好的构建过程<br></code></pre></div></td></tr></table></figure><h3 id="安装air"><a href="#安装air" class="headerlink" title="安装air"></a>安装air</h3><p>Go</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> -<span class="hljs-keyword">u</span> github.<span class="hljs-keyword">com</span>/cosmtrek/air<br></code></pre></div></td></tr></table></figure><p>MacOS</p><figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy">curl -fLo air <span class="hljs-string">https:</span><span class="hljs-comment">//git.io/darwin_air</span><br></code></pre></div></td></tr></table></figure><p>Linux</p><figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy">curl -fLo air <span class="hljs-string">https:</span><span class="hljs-comment">//git.io/linux_air</span><br></code></pre></div></td></tr></table></figure><p>Windows</p><figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy">curl -fLo air.exe <span class="hljs-string">https:</span><span class="hljs-comment">//git.io/windows_air</span><br></code></pre></div></td></tr></table></figure><h3 id="使用Air"><a href="#使用Air" class="headerlink" title="使用Air"></a>使用Air</h3><p>为了敲命令时更简单更方便，你应该把alias air=’~/.air’加到你的.bashrc或.zshrc中。</p><p>首先进入你的项目目录：</p><figure class="highlight dos"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dos"><span class="hljs-built_in">cd</span> /<span class="hljs-built_in">path</span>/to/your_project<br></code></pre></div></td></tr></table></figure><p>最简单的用法就是直接执行下面的命令：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"># 首先在当前目录下查找 `<span class="hljs-selector-class">.air</span><span class="hljs-selector-class">.conf</span>`配置文件，如果找不到就使用默认的<br><span class="hljs-selector-tag">air</span> <span class="hljs-selector-tag">-c</span> <span class="hljs-selector-class">.air</span><span class="hljs-selector-class">.conf</span><br></code></pre></div></td></tr></table></figure><p>推荐的使用方法是：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"># 1. 在当前目录创建一个新的配置文件<span class="hljs-selector-class">.air</span><span class="hljs-selector-class">.conf</span><br><span class="hljs-selector-tag">touch</span> <span class="hljs-selector-class">.air</span><span class="hljs-selector-class">.conf</span><br><br># 2. 复制 `<span class="hljs-selector-tag">air</span><span class="hljs-selector-class">.conf</span><span class="hljs-selector-class">.example</span>` 中的内容到这个文件，然后根据你的需要去修改它<br><br># 3. 使用你的配置运行 <span class="hljs-selector-tag">air</span>, 如果文件名是 `<span class="hljs-selector-class">.air</span><span class="hljs-selector-class">.conf</span>`，只需要执行 `<span class="hljs-selector-tag">air</span>`。<br><span class="hljs-selector-tag">air</span><br></code></pre></div></td></tr></table></figure><h4 id="air-example-conf示例"><a href="#air-example-conf示例" class="headerlink" title="air_example.conf示例"></a>air_example.conf示例</h4><p>完整的<code>air_example.conf</code>示例配置如下，可以根据自己的需要修改。</p><figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-comment"># [Air](https://github.com/cosmtrek/air) TOML 格式的配置文件</span><br><br><span class="hljs-comment"># 工作目录</span><br><span class="hljs-comment"># 使用 . 或绝对路径，请注意 `tmp_dir` 目录必须在 `root` 目录下</span><br><span class="hljs-attr">root</span> = <span class="hljs-string">"."</span><br><span class="hljs-attr">tmp_dir</span> = <span class="hljs-string">"tmp"</span><br><br><span class="hljs-section">[build]</span><br><span class="hljs-comment"># 只需要写你平常编译使用的shell命令。你也可以使用 `make`</span><br><span class="hljs-attr">cmd</span> = <span class="hljs-string">"go build -o ./tmp/main ."</span><br><span class="hljs-comment"># 由`cmd`命令得到的二进制文件名</span><br><span class="hljs-attr">bin</span> = <span class="hljs-string">"tmp/main"</span><br><span class="hljs-comment"># 自定义的二进制，可以添加额外的编译标识例如添加 GIN_MODE=release</span><br><span class="hljs-attr">full_bin</span> = <span class="hljs-string">"APP_ENV=dev APP_USER=air ./tmp/main"</span><br><span class="hljs-comment"># 监听以下文件扩展名的文件.</span><br><span class="hljs-attr">include_ext</span> = [<span class="hljs-string">"go"</span>, <span class="hljs-string">"tpl"</span>, <span class="hljs-string">"tmpl"</span>, <span class="hljs-string">"html"</span>]<br><span class="hljs-comment"># 忽略这些文件扩展名或目录</span><br><span class="hljs-attr">exclude_dir</span> = [<span class="hljs-string">"assets"</span>, <span class="hljs-string">"tmp"</span>, <span class="hljs-string">"vendor"</span>, <span class="hljs-string">"frontend/node_modules"</span>]<br><span class="hljs-comment"># 监听以下指定目录的文件</span><br><span class="hljs-attr">include_dir</span> = []<br><span class="hljs-comment"># 排除以下文件</span><br><span class="hljs-attr">exclude_file</span> = []<br><span class="hljs-comment"># 如果文件更改过于频繁，则没有必要在每次更改时都触发构建。可以设置触发构建的延迟时间</span><br><span class="hljs-attr">delay</span> = <span class="hljs-number">1000</span> <span class="hljs-comment"># ms</span><br><span class="hljs-comment"># 发生构建错误时，停止运行旧的二进制文件。</span><br><span class="hljs-attr">stop_on_error</span> = <span class="hljs-literal">true</span><br><span class="hljs-comment"># air的日志文件名，该日志文件放置在你的`tmp_dir`中</span><br><span class="hljs-attr">log</span> = <span class="hljs-string">"air_errors.log"</span><br><br><span class="hljs-section">[log]</span><br><span class="hljs-comment"># 显示日志时间</span><br><span class="hljs-attr">time</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-section">[color]</span><br><span class="hljs-comment"># 自定义每个部分显示的颜色。如果找不到颜色，使用原始的应用程序日志。</span><br><span class="hljs-attr">main</span> = <span class="hljs-string">"magenta"</span><br><span class="hljs-attr">watcher</span> = <span class="hljs-string">"cyan"</span><br><span class="hljs-attr">build</span> = <span class="hljs-string">"yellow"</span><br><span class="hljs-attr">runner</span> = <span class="hljs-string">"green"</span><br><br><span class="hljs-section">[misc]</span><br><span class="hljs-comment"># 退出时删除tmp目录</span><br><span class="hljs-attr">clean_on_exit</span> = <span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="/img/newimg/007S8ZIlgy1ggrnaui0m5g30xc0k042d.gif" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>go闭包中局部变量逃逸的简单分析</title>
    <link href="/2020/06/25/go%E9%97%AD%E5%8C%85%E4%B8%AD%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E9%80%83%E9%80%B8%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"/>
    <url>/2020/06/25/go%E9%97%AD%E5%8C%85%E4%B8%AD%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E9%80%83%E9%80%B8%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用prometheus-operator来监控istio数据</title>
    <link href="/2020/06/18/%E4%BD%BF%E7%94%A8prometheus-operator%E6%9D%A5%E7%9B%91%E6%8E%A7istio%E6%95%B0%E6%8D%AE/"/>
    <url>/2020/06/18/%E4%BD%BF%E7%94%A8prometheus-operator%E6%9D%A5%E7%9B%91%E6%8E%A7istio%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<p>其实默认安装完istio是会带一个promethes的。但是如果都用那个prometheus局限性比较大  还是用先进的prometheus-operator来监控istio。</p><h3 id="安装prometheus-operator"><a href="#安装prometheus-operator" class="headerlink" title="安装prometheus-operator"></a>安装prometheus-operator</h3><figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> clone https://github.com/coreos/kube-prometheus.git ; <span class="hljs-attribute">cd</span> kube-prometheus<br>kubectl create -f manifests/setup<br>until kubectl get servicemonitors --all-namespaces ; do date; sleep 1; echo ""; done<br><span class="hljs-attribute">kubectl</span> create -f manifests/<br></code></pre></div></td></tr></table></figure><h3 id="查看安装结果"><a href="#查看安装结果" class="headerlink" title="查看安装结果"></a>查看安装结果</h3><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">[<span class="hljs-symbol">root@</span>master ~]# kubectl  <span class="hljs-keyword">get</span> pod -n monitoring<br>NAME                                   READY   STATUS    RESTARTS   AGE<br>alertmanager-main<span class="hljs-number">-0</span>                    <span class="hljs-number">2</span>/<span class="hljs-number">2</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">14</span>d<br>alertmanager-main<span class="hljs-number">-1</span>                    <span class="hljs-number">2</span>/<span class="hljs-number">2</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">22</span>d<br>alertmanager-main<span class="hljs-number">-2</span>                    <span class="hljs-number">2</span>/<span class="hljs-number">2</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">22</span>d<br>grafana<span class="hljs-number">-5</span>c55845445<span class="hljs-number">-8</span>jvbz               <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">22</span>d<br>kube-state-metrics<span class="hljs-number">-957f</span>d6c75-vxp4k     <span class="hljs-number">3</span>/<span class="hljs-number">3</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">22</span>d<br>node-exporter<span class="hljs-number">-9</span>hc9q                    <span class="hljs-number">2</span>/<span class="hljs-number">2</span>     Running   <span class="hljs-number">2</span>          <span class="hljs-number">22</span>d<br>node-exporter-d85q9                    <span class="hljs-number">2</span>/<span class="hljs-number">2</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">22</span>d<br>node-exporter-fzfhl                    <span class="hljs-number">2</span>/<span class="hljs-number">2</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">22</span>d<br>node-exporter-gcm86                    <span class="hljs-number">2</span>/<span class="hljs-number">2</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">22</span>d<br>node-exporter-w7xtg                    <span class="hljs-number">2</span>/<span class="hljs-number">2</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">9</span>d<br>node-exporter-wvq7b                    <span class="hljs-number">2</span>/<span class="hljs-number">2</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">22</span>d<br>prometheus-adapter<span class="hljs-number">-5</span>cdcdf9c8d<span class="hljs-number">-6</span>c5vq    <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">14</span>d<br>prometheus-k8s<span class="hljs-number">-0</span>                       <span class="hljs-number">3</span>/<span class="hljs-number">3</span>     Running   <span class="hljs-number">1</span>          <span class="hljs-number">14</span>d<br>prometheus-k8s<span class="hljs-number">-1</span>                       <span class="hljs-number">3</span>/<span class="hljs-number">3</span>     Running   <span class="hljs-number">1</span>          <span class="hljs-number">22</span>d<br>prometheus-operator<span class="hljs-number">-6f</span>98f66b89<span class="hljs-number">-4</span>jjff   <span class="hljs-number">2</span>/<span class="hljs-number">2</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">22</span>d<br></code></pre></div></td></tr></table></figure><h3 id="给promehteus增加权限监控istio"><a href="#给promehteus增加权限监控istio" class="headerlink" title="给promehteus增加权限监控istio"></a>给promehteus增加权限监控istio</h3><figure class="highlight haml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haml">kubectl -n monitoring edit clusterrole prometheus-k8s<br><br>rules:<br>-<span class="ruby"> <span class="hljs-symbol">apiGroups:</span></span><br><span class="ruby">  - <span class="hljs-string">""</span></span><br><span class="ruby">  <span class="hljs-symbol">resources:</span></span><br><span class="ruby">  - nodes/metrics</span><br><span class="ruby">  - services</span><br><span class="ruby">  - endpoints</span><br><span class="ruby">  - pods</span><br><span class="ruby">  <span class="hljs-symbol">verbs:</span></span><br><span class="ruby">  - get</span><br><span class="ruby">  - list</span><br><span class="ruby">  - watch</span><br><span class="ruby">- <span class="hljs-symbol">nonResourceURLs:</span></span><br><span class="ruby">  - <span class="hljs-regexp">/metrics</span></span><br><span class="ruby">  <span class="hljs-symbol">verbs:</span></span><br><span class="ruby">  - get</span><br></code></pre></div></td></tr></table></figure><h3 id="安装监控项ServiceMonitor"><a href="#安装监控项ServiceMonitor" class="headerlink" title="安装监控项ServiceMonitor"></a>安装监控项ServiceMonitor</h3><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts">[root@master data]<span class="hljs-meta"># cat ServiceMonitor.yaml</span><br><span class="hljs-symbol">apiVersion:</span> monitoring.coreos.com/v1<br><span class="hljs-symbol">kind:</span> ServiceMonitor<br><span class="hljs-symbol">metadata:</span><br><span class="hljs-symbol">  name:</span> istio-monitor<br><span class="hljs-symbol">  namespace:</span> monitoring<br><span class="hljs-symbol">  labels:</span><br><span class="hljs-symbol">    app:</span> prometheus-istio<br><span class="hljs-symbol">spec:</span><br><span class="hljs-symbol">  selector:</span><br><span class="hljs-symbol">    matchLabels:</span><br><span class="hljs-symbol">      app:</span> mixer <br><span class="hljs-symbol">      istio:</span> mixer<br><span class="hljs-symbol">  endpoints:</span><br>  - port: prometheus <br><span class="hljs-symbol">    interval:</span> <span class="hljs-number">10</span>s    <br><span class="hljs-symbol">  namespaceSelector:</span><br><span class="hljs-symbol">    matchNames:</span><br>    - istio-system   <br><br><br>[root@master data]<span class="hljs-meta"># kubectl apply -f ServiceMonitor.yaml</span><br></code></pre></div></td></tr></table></figure><h3 id="从promehtues的监控数据中可查看"><a href="#从promehtues的监控数据中可查看" class="headerlink" title="从promehtues的监控数据中可查看"></a>从promehtues的监控数据中可查看</h3><p><img src="/img/newimg/007S8ZIlgy1gfwxbhgdr3j31ot0u0do8.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    
    <tags>
      
      <tag>prometheus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vim复制粘贴导致多行出现#号解决办法</title>
    <link href="/2020/06/16/vim%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E5%AF%BC%E8%87%B4%E5%A4%9A%E8%A1%8C%E5%87%BA%E7%8E%B0-%E5%8F%B7%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <url>/2020/06/16/vim%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E5%AF%BC%E8%87%B4%E5%A4%9A%E8%A1%8C%E5%87%BA%E7%8E%B0-%E5%8F%B7%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>在vim内复制多行假如复制的行带有#号会导致其他不带#号的行自动加#</p><p>解决办法，输入一下命令再粘贴即可</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">:<span class="hljs-builtin-name">set</span> paste<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>python3使用sqlit3文档记录</title>
    <link href="/2020/06/12/python3%E4%BD%BF%E7%94%A8sqlit3%E6%96%87%E6%A1%A3%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/06/12/python3%E4%BD%BF%E7%94%A8sqlit3%E6%96%87%E6%A1%A3%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>使用python3内置的sqlite3库，首先连接到数据库，创建并使用游标Cursor，再执行SQL语句，最后提交事务以实现sqlite3数据库中的CRUD新增数据，查询数据，更新数据和删除数据的常用操作。</p><p>SQLite是一种嵌入式数据库，它的数据库就是一个文件，SQLite能保存可以保存空值、整数、浮点数、字符串和blob 。sqlite相关教程动手学sqlite。</p><h3 id="连接数据库-如果不存在则创建"><a href="#连接数据库-如果不存在则创建" class="headerlink" title="连接数据库(如果不存在则创建)"></a>连接数据库(如果不存在则创建)</h3><figure class="highlight vala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vala">import sqlite3<br> <br><span class="hljs-meta"># 连接数据库(如果不存在则创建)</span><br>conn = sqlite3.connect(<span class="hljs-string">'test.db'</span>)<br>print(<span class="hljs-string">"Opened database successfully"</span>)<br> <br><span class="hljs-meta"># 创建游标</span><br>cursor = conn.cursor()<br><span class="hljs-meta"># 关闭游标</span><br>cursor.close()<br><span class="hljs-meta"># 提交事物</span><br>conn.commit()<br><br><span class="hljs-meta">#关闭游标</span><br>cursor.close()<br><br><span class="hljs-meta">#关闭连接</span><br>conn.close()<br></code></pre></div></td></tr></table></figure><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> sqlite3<br> <br># 连接数据库(如果不存在则创建)<br>conn = sqlite3.<span class="hljs-keyword">connect</span>(<span class="hljs-string">'test.db'</span>)<br><br># 创建游标<br><span class="hljs-keyword">cursor</span> = conn.<span class="hljs-keyword">cursor</span>()<br> <br># 创建表<br><span class="hljs-keyword">sql</span> = <span class="hljs-string">'CREATE TABLE Student(id integer PRIMARY KEY autoincrement, Name  varchar(30), Age integer)'</span><br><span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">execute</span>(<span class="hljs-keyword">sql</span>)<br> <br># 提交事物<br>conn.<span class="hljs-keyword">commit</span>()<br><br>#关闭游标<br><span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">close</span>()<br><br>#关闭连接<br>conn.<span class="hljs-keyword">close</span>()<br></code></pre></div></td></tr></table></figure><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> sqlite3<br> <br># 连接数据库(如果不存在则创建)<br>conn = sqlite3.<span class="hljs-keyword">connect</span>(<span class="hljs-string">'test.db'</span>)<br><br># 创建游标<br><span class="hljs-keyword">cursor</span> = conn.<span class="hljs-keyword">cursor</span>()<br> <br># 插入数据<span class="hljs-number">1</span><br><span class="hljs-keyword">sql</span> = "INSERT INTO Student(Name, Age) VALUES('lucy', 22)"<br><span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">execute</span>(<span class="hljs-keyword">sql</span>)<br> <br># 插入数据 <span class="hljs-number">2</span><br>data = (<span class="hljs-string">'jack'</span>, <span class="hljs-number">21</span>) <br><span class="hljs-keyword">sql</span> = "INSERT INTO Student(Name, Age) VALUES(?, ?)"<br><span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">execute</span>(<span class="hljs-keyword">sql</span>, data)<br> <br># 提交事物<br>conn.<span class="hljs-keyword">commit</span>()<br><br>#关闭游标<br><span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">close</span>()<br><br>#关闭连接<br>conn.<span class="hljs-keyword">close</span>()<br></code></pre></div></td></tr></table></figure><h3 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h3><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> sqlite3<br> <br># 连接数据库(如果不存在则创建)<br>conn = sqlite3.<span class="hljs-keyword">connect</span>(<span class="hljs-string">'test.db'</span>)<br><br># 创建游标<br><span class="hljs-keyword">cursor</span> = conn.<span class="hljs-keyword">cursor</span>()<br> <br><span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">execute</span>("UPDATE Student SET name = ? where id = ?",("lily","3"))<br><br># 提交事物<br>conn.<span class="hljs-keyword">commit</span>()<br><br>#关闭游标<br><span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">close</span>()<br><br>#关闭连接<br>conn.<span class="hljs-keyword">close</span>()<br></code></pre></div></td></tr></table></figure><h3 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h3><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> sqlite3<br> <br># 连接数据库(如果不存在则创建)<br>conn = sqlite3.<span class="hljs-keyword">connect</span>(<span class="hljs-string">'test.db'</span>)<br><br># 创建游标<br><span class="hljs-keyword">cursor</span> = conn.<span class="hljs-keyword">cursor</span>()<br> <br><span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">execute</span>("delete from Student where id=?",("1",)) #逗号不能省，元组元素只有一个的时候一定要加逗号,将删除lucy<br><br># 提交事物<br>conn.<span class="hljs-keyword">commit</span>()<br><br>#关闭游标<br><span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">close</span>()<br><br>#关闭连接<br>conn.<span class="hljs-keyword">close</span>()<br></code></pre></div></td></tr></table></figure><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">import sqlite3<br> <br># 连接数据库(如果不存在则创建)<br>conn = sqlite3.connect(<span class="hljs-string">'test.db'</span>)<br><br># 创建游标<br><span class="hljs-built_in">cursor</span> = conn.<span class="hljs-built_in">cursor</span>()<br> <br># 查询数据<span class="hljs-number">1</span><br>sql = <span class="hljs-string">"select * from Student"</span><br><span class="hljs-built_in">values</span> = <span class="hljs-built_in">cursor</span>.<span class="hljs-keyword">execute</span>(sql)<br><span class="hljs-keyword">for</span> i in value<span class="hljs-variable">s:</span><br>    <span class="hljs-keyword">print</span>(i)<br> <br># 查询数据 <span class="hljs-number">2</span><br>sql = <span class="hljs-string">"select * from Student where id=?"</span><br><span class="hljs-built_in">values</span> = <span class="hljs-built_in">cursor</span>.<span class="hljs-keyword">execute</span>(sql, (<span class="hljs-number">1</span>,))<br><span class="hljs-keyword">for</span> i in value<span class="hljs-variable">s:</span><br>    <span class="hljs-keyword">print</span>(<span class="hljs-string">'id:'</span>, i[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">print</span>(<span class="hljs-string">'name:'</span>, i[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">print</span>(<span class="hljs-string">'age:'</span>, i[<span class="hljs-number">2</span>])<br> <br># 提交事物<br>conn.commit()<br><br>#关闭游标<br><span class="hljs-built_in">cursor</span>.<span class="hljs-keyword">close</span>()<br><br>#关闭连接<br>conn.<span class="hljs-keyword">close</span>()<br></code></pre></div></td></tr></table></figure><h3 id="删除表格"><a href="#删除表格" class="headerlink" title="删除表格"></a>删除表格</h3><figure class="highlight vala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vala">import sqlite3<br><br><span class="hljs-meta"># 连接数据库(如果不存在则创建)</span><br>conn = sqlite3.connect(<span class="hljs-string">'test.db'</span>)<br><br><span class="hljs-meta"># 创建游标</span><br>cursor = conn.cursor()<br><br><span class="hljs-meta">#删除表格Student</span><br>cursor.execute(<span class="hljs-string">"DROP TABLE Student"</span>)<br><br><span class="hljs-meta"># 提交事物</span><br>conn.commit()<br><br><span class="hljs-meta">#关闭游标</span><br>cursor.close()<br><br><span class="hljs-meta">#关闭连接</span><br>conn.close()<br></code></pre></div></td></tr></table></figure><p>通过以上的demo可以精炼出函数来执行增删改查。demo如下</p><h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一次简单的pod Evicted排查</title>
    <link href="/2020/06/03/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84pod-Evicted%E6%8E%92%E6%9F%A5/"/>
    <url>/2020/06/03/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84pod-Evicted%E6%8E%92%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<p>早上开发人员反馈一个测试集群经常有后端或者其他的程序无故挂掉。由于是开发自测环境 常年没人维护，上去一看发现很多pod都是<code>evicted</code>状态居然s达到了2000多个。。<br>不过也没大事儿，<code>evicted</code>都是驱逐 要么是标签驱逐 要么是资源驱逐。都很好解决<br><img src="/img/newimg/007S8ZIlgy1gfewxmle3gj311o0ds7o3.jpg" srcset="/img/loading.gif" alt=""></p><p>具体查看某个pod的日志可知.</p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">kubectl describe pod  xxxxxx</span><br></code></pre></div></td></tr></table></figure><p><img src="/img/newimg/007S8ZIlgy1gfewxyocsbj312x09fdrk.jpg" srcset="/img/loading.gif" alt=""></p><p>日志显示的是节点的磁盘不足导致。加相关目录磁盘即可解决。<br>lvm扩容磁盘步骤</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">[<span class="hljs-symbol">root@</span>node2 ~]# vgextend centos /dev/sdb<br>[<span class="hljs-symbol">root@</span>node2 ~]# lvextend -L +<span class="hljs-number">190</span>G  /dev/centos/root<br>[<span class="hljs-symbol">root@</span>node2 ~]#  xfs_growfs /dev/centos/root<br><br>[<span class="hljs-symbol">root@</span>node2 ~]# lsblk<br>NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT<br>sda               <span class="hljs-number">8</span>:<span class="hljs-number">0</span>    <span class="hljs-number">0</span>   <span class="hljs-number">50</span>G  <span class="hljs-number">0</span> disk<br>├─sda1            <span class="hljs-number">8</span>:<span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">2</span>G  <span class="hljs-number">0</span> part /boot<br>└─sda2            <span class="hljs-number">8</span>:<span class="hljs-number">2</span>    <span class="hljs-number">0</span>   <span class="hljs-number">48</span>G  <span class="hljs-number">0</span> part<br>  ├─centos-root <span class="hljs-number">253</span>:<span class="hljs-number">0</span>    <span class="hljs-number">0</span>  <span class="hljs-number">230</span>G  <span class="hljs-number">0</span> lvm  /<br>  └─centos-swap <span class="hljs-number">253</span>:<span class="hljs-number">1</span>    <span class="hljs-number">0</span>    <span class="hljs-number">8</span>G  <span class="hljs-number">0</span> lvm<br>sdb               <span class="hljs-number">8</span>:<span class="hljs-number">16</span>   <span class="hljs-number">0</span>  <span class="hljs-number">200</span>G  <span class="hljs-number">0</span> disk<br>└─centos-root   <span class="hljs-number">253</span>:<span class="hljs-number">0</span>    <span class="hljs-number">0</span>  <span class="hljs-number">230</span>G  <span class="hljs-number">0</span> lvm  /<br>sr0              <span class="hljs-number">11</span>:<span class="hljs-number">0</span>    <span class="hljs-number">1</span> <span class="hljs-number">1024</span>M  <span class="hljs-number">0</span> rom<br></code></pre></div></td></tr></table></figure><p>完事了。</p><hr><p>现有的<code>evicted</code>pod可以用命令一起删除</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">kubectl <span class="hljs-built_in">get</span> pods   | <span class="hljs-keyword">grep</span> Evicted | awk <span class="hljs-string">'&#123;print $1&#125;'</span> | xargs kubectl <span class="hljs-keyword">delete</span> pod<br></code></pre></div></td></tr></table></figure><p>默认由于资源的驱逐规则</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">memory.available&lt;<span class="hljs-number">100</span>Mi<br>nodefs.available&lt;<span class="hljs-number">10</span>%<br>nodefs.inodesFree&lt;<span class="hljs-number">5</span>%<br>imagefs.available&lt;<span class="hljs-number">15</span>%<br></code></pre></div></td></tr></table></figure><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><p><a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/out-of-resource/" target="_blank" rel="noopener">官网解读kubernetes配置资源不足处理</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Csharp使用redis</title>
    <link href="/2020/06/02/Csharp%E4%BD%BF%E7%94%A8redis/"/>
    <url>/2020/06/02/Csharp%E4%BD%BF%E7%94%A8redis/</url>
    
    <content type="html"><![CDATA[<p>在redis中常用<code>StackExchange.Redis</code>库<br>使用<code>NuGet</code>安装<code>StackExchange.Redis</code><br>简单使用方法</p><figure class="highlight cs"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cs"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span>  StackExchange.Redis;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">redistest</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] args</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-comment">//配置连接</span><br>            <span class="hljs-keyword">var</span> conn = ConnectionMultiplexer.Connect(<span class="hljs-string">"ss.jxhs.me:6379"</span>);<br>            <br>            <span class="hljs-comment">//获取连接</span><br>            IDatabase idb = conn.GetDatabase(<span class="hljs-number">1</span>); <span class="hljs-comment">// 默认db0</span><br><br>            <span class="hljs-comment">//获取字符串</span><br>            <span class="hljs-keyword">string</span> city =  idb.StringGet(<span class="hljs-string">"hello"</span>);<br>            <br>            <span class="hljs-comment">//塞数据进redis</span><br>            <span class="hljs-keyword">string</span> <span class="hljs-keyword">value</span> = <span class="hljs-string">"abcdefg"</span>;<br>            idb.StringSet(<span class="hljs-string">"mykey"</span>, <span class="hljs-keyword">value</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="推荐一个redis的客户端。贼好用"><a href="#推荐一个redis的客户端。贼好用" class="headerlink" title="推荐一个redis的客户端。贼好用"></a>推荐一个redis的客户端。贼好用</h3><p><img src="/img/newimg/007S8ZIlgy1gfez9d29hhj30uk0k8ac6.jpg" srcset="/img/loading.gif" alt=""><br><a href="https://github.com/qishibo/AnotherRedisDesktopManager" target="_blank" rel="noopener">redis工具github项目地址</a></p><h3 id="StackExchange-Redis具体使用文档"><a href="#StackExchange-Redis具体使用文档" class="headerlink" title="StackExchange.Redis具体使用文档"></a>StackExchange.Redis具体使用文档</h3><p><a href="https://www.jxhs.me/db/redis-csharp.pdf">StackExchange.Redis库中文文档</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>内存碎片化</title>
    <link href="/2020/06/02/%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E5%8C%96/"/>
    <url>/2020/06/02/%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="判断是否内存碎片化严重"><a href="#判断是否内存碎片化严重" class="headerlink" title="判断是否内存碎片化严重"></a>判断是否内存碎片化严重</h2><p>内存页分配失败，内核日志报类似下面的错：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">mysqld:<span class="hljs-built_in"> page </span>allocation failure. order:4, mode:0x10c0d0<br></code></pre></div></td></tr></table></figure><blockquote><p><code>mysqld</code> 是被分配的内存的程序<br><code>order</code> 表示需要分配连续页的数量(2^order)，这里 4 表示 2^4=16 个连续的页<br><code>mode</code> 是内存分配模式的标识，定义在内核源码文件 <code>include/linux/gfp.h</code> 中，通常是多个标识相与运算的结果，不同版本内核可能不一样，比如在新版内核中 <code>GFP_KERNEL</code> 是 <code>__GFP_RECLAIM | __GFP_IO | __GFP_FS</code> 的运算结果，而 <code>__GFP_RECLAIM</code> 又是 <code>___GFP_DIRECT_RECLAIM|___GFP_KSWAPD_RECLAIM</code> 的运算结果</p></blockquote><p>当 order 为 0 时，说明系统以及完全没有可用内存了，order 值比较大时，才说明内存碎片化了，无法分配连续的大页内存。</p><h2 id="内存碎片化造成的问题"><a href="#内存碎片化造成的问题" class="headerlink" title="内存碎片化造成的问题"></a>内存碎片化造成的问题</h2><h3 id="容器启动失败"><a href="#容器启动失败" class="headerlink" title="容器启动失败"></a>容器启动失败</h3><p>K8S 会为每个 pod 创建 netns 来隔离 network namespace，内核初始化 netns 时会为其创建 nf_conntrack 表的 cache，需要申请大页内存，如果此时系统内存已经碎片化，无法分配到足够的大页内存内核就会报错(v2.6.33 - v4.6):</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">runc:[1:CHILD]:<span class="hljs-built_in"> page </span>allocation failure: order:6, mode:0x10c0d0<br></code></pre></div></td></tr></table></figure><p>Pod 状态将会一直在 ContainerCreating，dockerd 启动容器失败，日志报错:</p><figure class="highlight taggerscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs taggerscript">Jan 23 14:15:31 dc05 dockerd: time="2019-01-23T14:15:31.288446233+08:00" level=error msg="containerd: start container" error="oci runtime error: container_linux.go:247: starting container process caused <span class="hljs-symbol">\"</span>process_linux.go:245: running exec setns process for init caused <span class="hljs-symbol">\\</span><span class="hljs-symbol">\"</span>exit status 6<span class="hljs-symbol">\\</span><span class="hljs-symbol">\"</span><span class="hljs-symbol">\"</span><span class="hljs-symbol">\n</span>" id=5b9be8c5bb121264899fac8d9d36b02150269d41ce96ba6ad36d70b8640cb01c<br>Jan 23 14:15:31 dc05 dockerd: time="2019-01-23T14:15:31.317965799+08:00" level=error msg="Create container failed with error: invalid header field value <span class="hljs-symbol">\"</span>oci runtime error: container_linux.go:247: starting container process caused <span class="hljs-symbol">\\</span><span class="hljs-symbol">\"</span>process_linux.go:245: running exec setns process for init caused <span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\"</span>exit status 6<span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\"</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\"</span><span class="hljs-symbol">\\</span>n<span class="hljs-symbol">\"</span>"<br></code></pre></div></td></tr></table></figure><p>kubelet 日志报错:</p><figure class="highlight taggerscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs taggerscript">Jan 23 14:15:31 dc05 kubelet: E0123 14:15:31.352386   26037 remote_runtime.go:91] RunPodSandbox from runtime service failed: rpc error: code = 2 desc = failed to start sandbox container for pod "matchdataserver-1255064836-t4b2w": Error response from daemon: &#123;"message":"invalid header field value <span class="hljs-symbol">\"</span>oci runtime error: container_linux.go:247: starting container process caused <span class="hljs-symbol">\\</span><span class="hljs-symbol">\"</span>process_linux.go:245: running exec setns process for init caused <span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\"</span>exit status 6<span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\"</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\"</span><span class="hljs-symbol">\\</span>n<span class="hljs-symbol">\"</span>"&#125;<br>Jan 23 14:15:31 dc05 kubelet: E0123 14:15:31.352496   26037 kuberuntime_sandbox.go:54] CreatePodSandbox for pod "matchdataserver-1255064836-t4b2w_basic(485fd485-1ed6-11e9-8661-0a587f8021ea)" failed: rpc error: code = 2 desc = failed to start sandbox container for pod "matchdataserver-1255064836-t4b2w": Error response from daemon: &#123;"message":"invalid header field value <span class="hljs-symbol">\"</span>oci runtime error: container_linux.go:247: starting container process caused <span class="hljs-symbol">\\</span><span class="hljs-symbol">\"</span>process_linux.go:245: running exec setns process for init caused <span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\"</span>exit status 6<span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\"</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\"</span><span class="hljs-symbol">\\</span>n<span class="hljs-symbol">\"</span>"&#125;<br>Jan 23 14:15:31 dc05 kubelet: E0123 14:15:31.352518   26037 kuberuntime_manager.go:618] createPodSandbox for pod "matchdataserver-1255064836-t4b2w_basic(485fd485-1ed6-11e9-8661-0a587f8021ea)" failed: rpc error: code = 2 desc = failed to start sandbox container for pod "matchdataserver-1255064836-t4b2w": Error response from daemon: &#123;"message":"invalid header field value <span class="hljs-symbol">\"</span>oci runtime error: container_linux.go:247: starting container process caused <span class="hljs-symbol">\\</span><span class="hljs-symbol">\"</span>process_linux.go:245: running exec setns process for init caused <span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\"</span>exit status 6<span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\"</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\"</span><span class="hljs-symbol">\\</span>n<span class="hljs-symbol">\"</span>"&#125;<br>Jan 23 14:15:31 dc05 kubelet: E0123 14:15:31.352580   26037 pod_workers.go:182] Error syncing pod 485fd485-1ed6-11e9-8661-0a587f8021ea ("matchdataserver-1255064836-t4b2w_basic(485fd485-1ed6-11e9-8661-0a587f8021ea)"), skipping: failed to "CreatePodSandbox" for "matchdataserver-1255064836-t4b2w_basic(485fd485-1ed6-11e9-8661-0a587f8021ea)" with CreatePodSandboxError: "CreatePodSandbox for pod <span class="hljs-symbol">\"</span>matchdataserver-1255064836-t4b2w_basic(485fd485-1ed6-11e9-8661-0a587f8021ea)<span class="hljs-symbol">\"</span> failed: rpc error: code = 2 desc = failed to start sandbox container for pod <span class="hljs-symbol">\"</span>matchdataserver-1255064836-t4b2w<span class="hljs-symbol">\"</span>: Error response from daemon: &#123;<span class="hljs-symbol">\"</span>message<span class="hljs-symbol">\"</span>:<span class="hljs-symbol">\"</span>invalid header field value <span class="hljs-symbol">\\</span><span class="hljs-symbol">\"</span>oci runtime error: container_linux.go:247: starting container process caused <span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\"</span>process_linux.go:245: running exec setns process for init caused <span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\"</span>exit status 6<span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\"</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\"</span><span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span>n<span class="hljs-symbol">\\</span><span class="hljs-symbol">\"</span><span class="hljs-symbol">\"</span>&#125;"<br>Jan 23 14:15:31 dc05 kubelet: I0123 14:15:31.372181   26037 kubelet.go:1916] SyncLoop (PLEG): "matchdataserver-1255064836-t4b2w_basic(485fd485-1ed6-11e9-8661-0a587f8021ea)", event: &amp;pleg.PodLifecycleEvent&#123;ID:"485fd485-1ed6-11e9-8661-0a587f8021ea", Type:"ContainerDied", Data:"5b9be8c5bb121264899fac8d9d36b02150269d41ce96ba6ad36d70b8640cb01c"&#125;<br>Jan 23 14:15:31 dc05 kubelet: W0123 14:15:31.372225   26037 pod_container_deletor.go:77] Container "5b9be8c5bb121264899fac8d9d36b02150269d41ce96ba6ad36d70b8640cb01c" not found in pod's containers<br>Jan 23 14:15:31 dc05 kubelet: I0123 14:15:31.678211   26037 kuberuntime_manager.go:383] No ready sandbox for pod "matchdataserver-1255064836-t4b2w_basic(485fd485-1ed6-11e9-8661-0a587f8021ea)" can be found. Need to start a new one<br></code></pre></div></td></tr></table></figure><p>查看slab (后面的0多表示伙伴系统没有大块内存了)：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">$ cat /proc/buddyinfo<br>Node <span class="hljs-number">0</span>, zone      DMA      <span class="hljs-number">1</span>      <span class="hljs-number">0</span>      <span class="hljs-number">1</span>      <span class="hljs-number">0</span>      <span class="hljs-number">2</span>      <span class="hljs-number">1</span>      <span class="hljs-number">1</span>      <span class="hljs-number">0</span>      <span class="hljs-number">1</span>      <span class="hljs-number">1</span>      <span class="hljs-number">3</span><br>Node <span class="hljs-number">0</span>, zone    DMA32   <span class="hljs-number">2725</span>    <span class="hljs-number">624</span>    <span class="hljs-number">489</span>    <span class="hljs-number">178</span>      <span class="hljs-number">0</span>      <span class="hljs-number">0</span>      <span class="hljs-number">0</span>      <span class="hljs-number">0</span>      <span class="hljs-number">0</span>      <span class="hljs-number">0</span>      <span class="hljs-number">0</span><br>Node <span class="hljs-number">0</span>, zone   Normal   <span class="hljs-number">1163</span>   <span class="hljs-number">1101</span>    <span class="hljs-number">932</span>    <span class="hljs-number">222</span>      <span class="hljs-number">0</span>      <span class="hljs-number">0</span>      <span class="hljs-number">0</span>      <span class="hljs-number">0</span>      <span class="hljs-number">0</span>      <span class="hljs-number">0</span>      <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><h2 id="系统-OOM"><a href="#系统-OOM" class="headerlink" title="系统 OOM"></a>系统 OOM</h2><p>内存碎片化会导致即使当前系统总内存比较多，但由于无法分配足够的大页内存导致给进程分配内存失败，就认为系统内存不够用，需要杀掉一些进程来释放内存，从而导致系统 OOM</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><blockquote><p>周期性地或者在发现大块内存不足时，先进行drop_cache操作:</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">echo <span class="hljs-number">3</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/vm/</span>drop_caches<br></code></pre></div></td></tr></table></figure><blockquote><p>必要时候进行内存整理，开销会比较大，会造成业务卡住一段时间(慎用):</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">echo <span class="hljs-number">1</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/vm/</span>compact_memory<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器内抓包定位网络问题</title>
    <link href="/2020/06/02/%E5%AE%B9%E5%99%A8%E5%86%85%E6%8A%93%E5%8C%85%E5%AE%9A%E4%BD%8D%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/"/>
    <url>/2020/06/02/%E5%AE%B9%E5%99%A8%E5%86%85%E6%8A%93%E5%8C%85%E5%AE%9A%E4%BD%8D%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>在使用 kubernetes 跑应用的时候，可能会遇到一些网络问题，比较常见的是服务端无响应(超时)或回包内容不正常，如果没找出各种配置上有问题，这时我们需要确认数据包到底有没有最终被路由到容器里，或者报文到达容器的内容和出容器的内容符不符合预期，通过分析报文可以进一步缩小问题范围。那么如何在容器内抓包呢？本文提供实用的脚本一键进入容器网络命名空间(netns)，使用宿主机上的tcpdump进行抓包。</p><h3 id="使用脚本一键进入-pod-netns-抓包"><a href="#使用脚本一键进入-pod-netns-抓包" class="headerlink" title="使用脚本一键进入 pod netns 抓包"></a>使用脚本一键进入 pod netns 抓包</h3><blockquote><p>发现某个服务不通，最好将其副本数调为1，并找到这个副本 pod 所在节点和 pod 名称</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">get</span> pod -o wide<br></code></pre></div></td></tr></table></figure><blockquote><p>登录 pod 所在节点，将如下脚本粘贴到 shell (注册函数到当前登录的 shell，我们后面用)</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">function e() &#123;<br>    <span class="hljs-builtin-name">set</span> -eu<br>    <span class="hljs-attribute">ns</span>=<span class="hljs-variable">$&#123;2-"default"&#125;</span><br>    <span class="hljs-attribute">pod</span>=`kubectl -n <span class="hljs-variable">$ns</span> describe pod <span class="hljs-variable">$1</span> | grep -A10 <span class="hljs-string">"^Containers:"</span> | grep -Eo <span class="hljs-string">'docker://.*$'</span> | head -n 1 | sed <span class="hljs-string">'s/docker:\/\/\(.*\)$/\1/'</span>`<br>    <span class="hljs-attribute">pid</span>=`docker inspect -f &#123;&#123;.State.Pid&#125;&#125; <span class="hljs-variable">$pod</span>`<br>    echo <span class="hljs-string">"entering pod netns for <span class="hljs-variable">$ns</span>/<span class="hljs-variable">$1</span>"</span><br>    <span class="hljs-attribute">cmd</span>=<span class="hljs-string">"nsenter -n --target <span class="hljs-variable">$pid</span>"</span><br>    echo <span class="hljs-variable">$cmd</span><br>    <span class="hljs-variable">$cmd</span><br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>一键进入 pod 所在的 netns，格式：<code>e POD_NAME NAMESPACE</code>，示例：</p></blockquote><figure class="highlight llvm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs llvm">e istio-galley<span class="hljs-number">-58</span><span class="hljs-keyword">c</span><span class="hljs-number">7</span><span class="hljs-keyword">c</span><span class="hljs-number">7</span><span class="hljs-keyword">c</span><span class="hljs-number">646</span>-m<span class="hljs-number">6568</span> istio-system<br>e proxy<span class="hljs-number">-5546768954</span><span class="hljs-number">-9</span>rxg<span class="hljs-number">6</span> # 省略 NAMESPACE 默认为 <span class="hljs-keyword">default</span><br></code></pre></div></td></tr></table></figure><blockquote><p>这时已经进入 pod 的 netns，可以执行宿主机上的 <code>ip a</code> 或 <code>ifconfig</code> 来查看容器的网卡，执行 <code>netstat -tunlp</code> 查看当前容器监听了哪些端口，再通过 tcpdump 抓包：</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">tcpdump -i eth0 -w test.pcap<span class="hljs-built_in"> port </span>80<br></code></pre></div></td></tr></table></figure><p><code>ctrl-c</code> 停止抓包，再用 <code>scp</code> 或 <code>sz</code> 将抓下来的包下载到本地使用 <code>wireshark</code> 分析，提供一些常用的 <code>wireshark</code> 过滤语法：</p><figure class="highlight vala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vala"><span class="hljs-meta"># 使用 telnet 连上并发送一些测试文本，比如 "lbtest"，</span><br><span class="hljs-meta"># 用下面语句可以看发送的测试报文有没有到容器</span><br>tcp contains <span class="hljs-string">"lbtest"</span><br><span class="hljs-meta"># 如果容器提供的是http服务，可以使用 curl 发送一些测试路径的请求，</span><br><span class="hljs-meta"># 通过下面语句过滤 uri 看报文有没有都容器</span><br>http.request.uri==<span class="hljs-string">"/mytest"</span><br></code></pre></div></td></tr></table></figure><h3 id="脚本原理"><a href="#脚本原理" class="headerlink" title="脚本原理"></a>脚本原理</h3><p>我们解释下步骤二中用到的脚本的原理</p><blockquote><p>查看指定 pod 运行的容器 ID</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">kubectl describe pod <span class="hljs-tag">&lt;<span class="hljs-name">pod</span>&gt;</span> -n mservice<br></code></pre></div></td></tr></table></figure><blockquote><p>获得容器进程的 pid</p></blockquote><figure class="highlight django"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs django"><span class="xml">docker inspect -f </span><span class="hljs-template-variable">&#123;&#123;.State.Pid&#125;&#125;</span><span class="xml"> <span class="hljs-tag">&lt;<span class="hljs-name">container</span>&gt;</span></span><br></code></pre></div></td></tr></table></figure><blockquote><p>进入该容器的 network namespace</p></blockquote><figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada">nsenter -n <span class="hljs-comment">--target &lt;PID&gt;</span><br></code></pre></div></td></tr></table></figure><p>依赖宿主机的命名：<code>kubectl</code>, <code>docker</code>, <code>nsenter</code>, <code>grep</code>, <code>head</code>, <code>sed</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>drone使用手册</title>
    <link href="/2020/05/29/drone%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    <url>/2020/05/29/drone%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CKAD练习</title>
    <link href="/2020/05/25/CKAD%E7%BB%83%E4%B9%A0/"/>
    <url>/2020/05/25/CKAD%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="Kubernetes-CKAD-练习"><a href="#Kubernetes-CKAD-练习" class="headerlink" title="Kubernetes CKAD 练习"></a>Kubernetes CKAD 练习</h2><h3 id="核心概念（13％）"><a href="#核心概念（13％）" class="headerlink" title="核心概念（13％）"></a>核心概念（13％）</h3><h3 id="多容器-Pod（10％）"><a href="#多容器-Pod（10％）" class="headerlink" title="多容器 Pod（10％）"></a>多容器 Pod（10％）</h3><h3 id="Pod-设计（20％）"><a href="#Pod-设计（20％）" class="headerlink" title="Pod 设计（20％）"></a>Pod 设计（20％）</h3><h3 id="状态持久性（8％）"><a href="#状态持久性（8％）" class="headerlink" title="状态持久性（8％）"></a>状态持久性（8％）</h3><h3 id="配置（18％）"><a href="#配置（18％）" class="headerlink" title="配置（18％）"></a>配置（18％）</h3><h3 id="可观察性（18％）"><a href="#可观察性（18％）" class="headerlink" title="可观察性（18％）"></a>可观察性（18％）</h3><h3 id="服务和网络（13％）"><a href="#服务和网络（13％）" class="headerlink" title="服务和网络（13％）"></a>服务和网络（13％）</h3><h3 id="了解-Kubernetes-API-原语，创建和配置基本-Pod"><a href="#了解-Kubernetes-API-原语，创建和配置基本-Pod" class="headerlink" title="了解 Kubernetes API 原语，创建和配置基本 Pod"></a>了解 Kubernetes API 原语，创建和配置基本 Pod</h3><ol><li><p>列出集群中的所有命名空间</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">get</span> namespaces<br>kubectl <span class="hljs-builtin-name">get</span> ns<br></code></pre></div></td></tr></table></figure></li><li><p>列出所有命名空间中的所有 Pod</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">kubectl <span class="hljs-built_in">get</span> <span class="hljs-keyword">po</span> --<span class="hljs-keyword">all</span>-namespaces<br></code></pre></div></td></tr></table></figure></li><li><p>列出特定命名空间中的所有 Pod</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">get</span> pod -n kube-system<br>kubectl <span class="hljs-builtin-name">get</span> pod -n 命名空间名称<br></code></pre></div></td></tr></table></figure></li><li><p>列出特定命名空间中的所有 Service</p><figure class="highlight armasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">kubectl</span> <span class="hljs-meta">get</span> <span class="hljs-keyword">svc </span>--all-namespaces<br><span class="hljs-symbol">kubectl</span> <span class="hljs-meta">get</span> <span class="hljs-keyword">svc </span>-n 命名空间名称<br><span class="hljs-symbol">kubectl</span> <span class="hljs-meta">get</span> <span class="hljs-keyword">svc </span>-n default<br></code></pre></div></td></tr></table></figure></li><li><p>用 json 路径表达式列出所有显示名称和命名空间的 Pod</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">kubectl get pods -o=jsonpath="&#123;. items[<span class="hljs-string">*</span>][<span class="hljs-symbol">'metadata. name','metadata. namespace'</span>]&#125;" --all-namespaces --sort-by=metadata. name<br><br>kubectl get pods -o=jsonpath="&#123;. items[<span class="hljs-string">*</span>][<span class="hljs-symbol">'metadata. name','metadata. namespace'</span>]&#125;" --all-namespaces<br></code></pre></div></td></tr></table></figure></li><li><p>在默认命名空间中创建一个 Nginx Pod，并验证 Pod 是否正在运行</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">run</span> nginx <span class="hljs-attribute">--image</span>=nginx<br>以上命令<br>kubectl <span class="hljs-builtin-name">run</span> <span class="hljs-attribute">--generator</span>=deployment/apps. v1 is DEPRECATED <span class="hljs-keyword">and</span> will be removed <span class="hljs-keyword">in</span> a future version.  Use kubectl <span class="hljs-builtin-name">run</span> <span class="hljs-attribute">--generator</span>=run-pod/v1 <span class="hljs-keyword">or</span> kubectl create instead<br><br>kubectl <span class="hljs-builtin-name">run</span> nginx <span class="hljs-attribute">--image</span>=nginx <span class="hljs-attribute">--restart</span>=Never<br>会直接产生 nginx  后面不会产生随机数<br></code></pre></div></td></tr></table></figure></li><li><p>使用 yaml 文件创建相同的 Nginx Pod</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">run</span> nginx <span class="hljs-attribute">--image</span>=nginx <span class="hljs-attribute">--restart</span>=Never --dry-<span class="hljs-builtin-name">run</span> -o yaml &gt; nginx. yaml<br><br>nginx. yaml 为<br></code></pre></div></td></tr></table></figure></li></ol><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">creationTimestamp:</span> <span class="hljs-literal">null</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">run:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">resources:</span> <span class="hljs-string">&#123;&#125;</span><br>  <span class="hljs-attr">dnsPolicy:</span> <span class="hljs-string">ClusterFirst</span><br>  <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span><br><span class="hljs-attr">status:</span> <span class="hljs-string">&#123;&#125;</span><br></code></pre></div></td></tr></table></figure><ol start="8"><li>输出刚创建的 Pod 的 yaml 文件<figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">get</span> po nginx -o yaml<br></code></pre></div></td></tr></table></figure></li></ol><ol start="9"><li>输出刚创建的 Pod 的 yaml 文件，并且其中不包含特定于集群的信息</li></ol><p>kubectl get po nginx -o yaml –export</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">Flag</span> <span class="hljs-string">--export</span> <span class="hljs-string">has</span> <span class="hljs-string">been</span> <span class="hljs-string">deprecated,</span> <span class="hljs-string">This</span> <span class="hljs-string">flag</span> <span class="hljs-string">is</span> <span class="hljs-string">deprecated</span> <span class="hljs-string">and</span> <span class="hljs-string">will</span> <span class="hljs-string">be</span> <span class="hljs-string">removed</span> <span class="hljs-string">in</span> <span class="hljs-string">future.</span> <br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-attr">cni. projectcalico. org/podIP:</span> <span class="hljs-number">10</span><span class="hljs-string">.</span> <span class="hljs-number">244</span><span class="hljs-string">.</span> <span class="hljs-number">1</span><span class="hljs-string">.</span> <span class="hljs-number">4</span><span class="hljs-string">/32</span><br>    <span class="hljs-attr">cni. projectcalico. org/podIPs:</span> <span class="hljs-number">10</span><span class="hljs-string">.</span> <span class="hljs-number">244</span><span class="hljs-string">.</span> <span class="hljs-number">1</span><span class="hljs-string">.</span> <span class="hljs-number">4</span><span class="hljs-string">/32</span><br>  <span class="hljs-attr">creationTimestamp:</span> <span class="hljs-literal">null</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">run:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">selfLink:</span> <span class="hljs-string">/api/v1/namespaces/default/pods/nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">Always</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">resources:</span> <span class="hljs-string">&#123;&#125;</span><br>    <span class="hljs-attr">terminationMessagePath:</span> <span class="hljs-string">/dev/termination-log</span><br>    <span class="hljs-attr">terminationMessagePolicy:</span> <span class="hljs-string">File</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/run/secrets/kubernetes.</span> <span class="hljs-string">io/serviceaccount</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">default-token-6t2vf</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">dnsPolicy:</span> <span class="hljs-string">ClusterFirst</span><br>  <span class="hljs-attr">enableServiceLinks:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">nodeName:</span> <span class="hljs-string">k8s-node01</span><br>  <span class="hljs-attr">priority:</span> <span class="hljs-number">0</span><br>  <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span><br>  <span class="hljs-attr">schedulerName:</span> <span class="hljs-string">default-scheduler</span><br>  <span class="hljs-attr">securityContext:</span> <span class="hljs-string">&#123;&#125;</span><br>  <span class="hljs-attr">serviceAccount:</span> <span class="hljs-string">default</span><br>  <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">default</span><br>  <span class="hljs-attr">terminationGracePeriodSeconds:</span> <span class="hljs-number">30</span><br>  <span class="hljs-attr">tolerations:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">effect:</span> <span class="hljs-string">NoExecute</span><br>    <span class="hljs-attr">key:</span> <span class="hljs-string">node.</span> <span class="hljs-string">kubernetes.</span> <span class="hljs-string">io/not-ready</span><br>    <span class="hljs-attr">operator:</span> <span class="hljs-string">Exists</span><br>    <span class="hljs-attr">tolerationSeconds:</span> <span class="hljs-number">300</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">effect:</span> <span class="hljs-string">NoExecute</span><br>    <span class="hljs-attr">key:</span> <span class="hljs-string">node.</span> <span class="hljs-string">kubernetes.</span> <span class="hljs-string">io/unreachable</span><br>    <span class="hljs-attr">operator:</span> <span class="hljs-string">Exists</span><br>    <span class="hljs-attr">tolerationSeconds:</span> <span class="hljs-number">300</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">default-token-6t2vf</span><br>    <span class="hljs-attr">secret:</span><br>      <span class="hljs-attr">defaultMode:</span> <span class="hljs-number">420</span><br>      <span class="hljs-attr">secretName:</span> <span class="hljs-string">default-token-6t2vf</span><br><span class="hljs-attr">status:</span><br>  <span class="hljs-attr">phase:</span> <span class="hljs-string">Pending</span><br>  <span class="hljs-attr">qosClass:</span> <span class="hljs-string">BestEffort</span><br></code></pre></div></td></tr></table></figure><ol start="10"><li>获取刚刚创建的 Pod 的完整详细信息</li></ol><p>kubectl describe pod nginx</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">Name:</span>         <span class="hljs-string">nginx</span><br><span class="hljs-attr">Namespace:</span>    <span class="hljs-string">default</span><br><span class="hljs-attr">Priority:</span>     <span class="hljs-number">0</span><br><span class="hljs-attr">Node:</span>         <span class="hljs-string">k8s-node01/192.</span> <span class="hljs-number">168</span><span class="hljs-string">.</span> <span class="hljs-number">17</span><span class="hljs-string">.</span> <span class="hljs-number">151</span><br><span class="hljs-attr">Start Time:</span>   <span class="hljs-string">Sun,</span> <span class="hljs-number">05</span> <span class="hljs-string">Jan</span> <span class="hljs-number">2020</span> <span class="hljs-number">18</span><span class="hljs-string">:57:52</span> <span class="hljs-number">-0800</span><br><span class="hljs-attr">Labels:</span>       <span class="hljs-string">run=nginx</span><br><span class="hljs-attr">Annotations:  cni. projectcalico. org/podIP:</span> <span class="hljs-number">10</span><span class="hljs-string">.</span> <span class="hljs-number">244</span><span class="hljs-string">.</span> <span class="hljs-number">1</span><span class="hljs-string">.</span> <span class="hljs-number">4</span><span class="hljs-string">/32</span><br>              <span class="hljs-attr">cni. projectcalico. org/podIPs:</span> <span class="hljs-number">10</span><span class="hljs-string">.</span> <span class="hljs-number">244</span><span class="hljs-string">.</span> <span class="hljs-number">1</span><span class="hljs-string">.</span> <span class="hljs-number">4</span><span class="hljs-string">/32</span><br><span class="hljs-attr">Status:</span>       <span class="hljs-string">Running</span><br><span class="hljs-attr">IP:</span>           <span class="hljs-number">10</span><span class="hljs-string">.</span> <span class="hljs-number">244</span><span class="hljs-string">.</span> <span class="hljs-number">1</span><span class="hljs-string">.</span> <span class="hljs-number">4</span><br><span class="hljs-attr">IPs:</span><br>  <span class="hljs-attr">IP:</span>  <span class="hljs-number">10</span><span class="hljs-string">.</span> <span class="hljs-number">244</span><span class="hljs-string">.</span> <span class="hljs-number">1</span><span class="hljs-string">.</span> <span class="hljs-number">4</span><br><span class="hljs-attr">Containers:</span><br>  <span class="hljs-attr">nginx:</span><br>    <span class="hljs-attr">Container ID:</span>   <span class="hljs-string">docker://3d9b8b7aba7c10b3f1fbdd470dee702bc5c0e70a46157674574b3b20bd629335</span><br>    <span class="hljs-attr">Image:</span>          <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">Image ID:</span>       <span class="hljs-string">docker-pullable://nginx@sha256:b2d89d0a210398b4d1120b3e3a7672c16a4ba09c2c4a0395f18b9f7999b768f2</span><br>    <span class="hljs-attr">Port:</span>           <span class="hljs-string">&lt;none&gt;</span><br>    <span class="hljs-attr">Host Port:</span>      <span class="hljs-string">&lt;none&gt;</span><br>    <span class="hljs-attr">State:</span>          <span class="hljs-string">Running</span><br>      <span class="hljs-attr">Started:</span>      <span class="hljs-string">Sun,</span> <span class="hljs-number">05</span> <span class="hljs-string">Jan</span> <span class="hljs-number">2020</span> <span class="hljs-number">18</span><span class="hljs-string">:57:57</span> <span class="hljs-number">-0800</span><br>    <span class="hljs-attr">Ready:</span>          <span class="hljs-literal">True</span><br>    <span class="hljs-attr">Restart Count:</span>  <span class="hljs-number">0</span><br>    <span class="hljs-attr">Environment:</span>    <span class="hljs-string">&lt;none&gt;</span><br>    <span class="hljs-attr">Mounts:</span><br>      <span class="hljs-string">/var/run/secrets/kubernetes.</span> <span class="hljs-string">io/serviceaccount</span> <span class="hljs-string">from</span> <span class="hljs-string">default-token-6t2vf</span> <span class="hljs-string">(ro)</span><br><span class="hljs-attr">Conditions:</span><br>  <span class="hljs-string">Type</span>              <span class="hljs-string">Status</span><br>  <span class="hljs-string">Initialized</span>       <span class="hljs-literal">True</span> <br>  <span class="hljs-string">Ready</span>             <span class="hljs-literal">True</span> <br>  <span class="hljs-string">ContainersReady</span>   <span class="hljs-literal">True</span> <br>  <span class="hljs-string">PodScheduled</span>      <span class="hljs-literal">True</span> <br><span class="hljs-attr">Volumes:</span><br>  <span class="hljs-attr">default-token-6t2vf:</span><br>    <span class="hljs-attr">Type:</span>        <span class="hljs-string">Secret</span> <span class="hljs-string">(a</span> <span class="hljs-string">volume</span> <span class="hljs-string">populated</span> <span class="hljs-string">by</span> <span class="hljs-string">a</span> <span class="hljs-string">Secret)</span><br>    <span class="hljs-attr">SecretName:</span>  <span class="hljs-string">default-token-6t2vf</span><br>    <span class="hljs-attr">Optional:</span>    <span class="hljs-literal">false</span><br><span class="hljs-attr">QoS Class:</span>       <span class="hljs-string">BestEffort</span><br><span class="hljs-attr">Node-Selectors:</span>  <span class="hljs-string">&lt;none&gt;</span><br><span class="hljs-attr">Tolerations:</span>     <span class="hljs-string">node.</span> <span class="hljs-string">kubernetes.</span> <span class="hljs-string">io/not-ready:NoExecute</span> <span class="hljs-string">for</span> <span class="hljs-string">300s</span><br>                 <span class="hljs-string">node.</span> <span class="hljs-string">kubernetes.</span> <span class="hljs-string">io/unreachable:NoExecute</span> <span class="hljs-string">for</span> <span class="hljs-string">300s</span><br><span class="hljs-attr">Events:</span><br>  <span class="hljs-string">Type</span>    <span class="hljs-string">Reason</span>     <span class="hljs-string">Age</span>   <span class="hljs-string">From</span>                 <span class="hljs-string">Message</span><br>  <span class="hljs-string">----</span>    <span class="hljs-string">------</span>     <span class="hljs-string">----</span>  <span class="hljs-string">----</span>                 <span class="hljs-string">-------</span><br>  <span class="hljs-string">Normal</span>  <span class="hljs-string">Scheduled</span>  <span class="hljs-string">14m</span>   <span class="hljs-string">default-scheduler</span>    <span class="hljs-string">Successfully</span> <span class="hljs-string">assigned</span> <span class="hljs-string">default/nginx</span> <span class="hljs-string">to</span> <span class="hljs-string">k8s-node01</span><br>  <span class="hljs-string">Normal</span>  <span class="hljs-string">Pulling</span>    <span class="hljs-string">14m</span>   <span class="hljs-string">kubelet,</span> <span class="hljs-string">k8s-node01</span>  <span class="hljs-string">Pulling</span> <span class="hljs-string">image</span> <span class="hljs-string">"nginx"</span><br>  <span class="hljs-string">Normal</span>  <span class="hljs-string">Pulled</span>     <span class="hljs-string">14m</span>   <span class="hljs-string">kubelet,</span> <span class="hljs-string">k8s-node01</span>  <span class="hljs-string">Successfully</span> <span class="hljs-string">pulled</span> <span class="hljs-string">image</span> <span class="hljs-string">"nginx"</span><br>  <span class="hljs-string">Normal</span>  <span class="hljs-string">Created</span>    <span class="hljs-string">14m</span>   <span class="hljs-string">kubelet,</span> <span class="hljs-string">k8s-node01</span>  <span class="hljs-string">Created</span> <span class="hljs-string">container</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-string">Normal</span>  <span class="hljs-string">Started</span>    <span class="hljs-string">14m</span>   <span class="hljs-string">kubelet,</span> <span class="hljs-string">k8s-node01</span>  <span class="hljs-string">Started</span> <span class="hljs-string">container</span> <span class="hljs-string">nginx</span><br></code></pre></div></td></tr></table></figure><ol start="11"><li>删除刚创建的 Pod</li></ol><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript">kubectl <span class="hljs-keyword">delete</span> pod nginx<br>kubectl <span class="hljs-keyword">delete</span> -f yaml 文件<br></code></pre></div></td></tr></table></figure><ol start="12"><li>强制删除刚创建的 Pod</li></ol><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl delete po nginx <span class="hljs-attribute">--grace-period</span>=0 --force<br><br>warning: Immediate deletion does <span class="hljs-keyword">not</span> wait <span class="hljs-keyword">for</span> confirmation that the running<span class="hljs-built_in"> resource </span>has been terminated.  The<span class="hljs-built_in"> resource </span>may continue <span class="hljs-keyword">to</span> <span class="hljs-builtin-name">run</span> on the cluster indefinitely. <br>pod <span class="hljs-string">"nginx"</span> force deleted<br></code></pre></div></td></tr></table></figure><ol start="13"><li>创建版本为 1. 17. 4 的 Nginx Pod，并将其暴露在端口 80 上</li></ol><p>kubectl run nginx –image=nginx:1. 17. 4 –restart=Never –port=80</p><p>kubectl run nginx –image=nginx:1. 17. 4 –restart=Never –port=80 –dry-run -o yaml</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">creationTimestamp:</span> <span class="hljs-literal">null</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">run:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.</span> <span class="hljs-number">17</span><span class="hljs-string">.</span> <span class="hljs-number">4</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">resources:</span> <span class="hljs-string">&#123;&#125;</span><br>  <span class="hljs-attr">dnsPolicy:</span> <span class="hljs-string">ClusterFirst</span><br>  <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span><br><span class="hljs-attr">status:</span> <span class="hljs-string">&#123;&#125;</span><br></code></pre></div></td></tr></table></figure><ol start="14"><li><p>将刚创建的容器的镜像更改为 1. 15-alpine，并验证该镜像是否已更新</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros"><br>kubectl <span class="hljs-builtin-name">set</span> image pod/nginx <span class="hljs-attribute">nginx</span>=nginx:1. 15-alpine<br><br>kubectl <span class="hljs-builtin-name">edit</span> po nginx<br><br>kubectl <span class="hljs-builtin-name">get</span> po nginx -w<br></code></pre></div></td></tr></table></figure></li><li><p>对于刚刚更新的 Pod，将镜像版本改回 1. 17. 1，并观察变化</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros"><br>kubectl <span class="hljs-builtin-name">set</span> image pod/nginx <span class="hljs-attribute">nginx</span>=nginx:1. 17. 1<br><br>kubectl <span class="hljs-builtin-name">edit</span> po nginx<br><br>kubectl <span class="hljs-builtin-name">get</span> po nginx -w<br></code></pre></div></td></tr></table></figure></li><li><p>在不用 describe 命令的情况下检查镜像版本</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros"><br>kubectl <span class="hljs-builtin-name">get</span> po nginx <span class="hljs-attribute">-o</span>=jsonpath='&#123;. spec. containers[]. image&#125;&#123;<span class="hljs-string">"\n"</span>&#125;<span class="hljs-string">'</span><br></code></pre></div></td></tr></table></figure></li><li><p>创建 Nginx Pod 并在 Pod 上执行简单的 shell</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">run</span> nginx <span class="hljs-attribute">--image</span>=nginx <span class="hljs-attribute">--restart</span>=Never<br>kubectl exec -it nginx /bin/bash<br></code></pre></div></td></tr></table></figure></li><li><p>获取刚刚创建的 Pod 的 IP 地址</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">get</span> po nginx -o wide<br></code></pre></div></td></tr></table></figure></li><li><p>创建一个 busybox Pod，在创建它时运行命令 ls 并检查日志</p></li></ol><p>kubectl run busybox –image=busybox –restart=Never – ls</p><p>kubectl logs busybox</p><figure class="highlight tcl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tcl">bin<br>dev<br>etc<br>home<br><span class="hljs-keyword">proc</span><br>root<br>sys<br>tmp<br>usr<br>var<br></code></pre></div></td></tr></table></figure><ol start="20"><li>如果 Pod 崩溃了，请检查 Pod 的先前日志<figure class="highlight armasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">kubectl</span> logs <span class="hljs-keyword">busybox </span>-p<br></code></pre></div></td></tr></table></figure></li></ol><ol start="21"><li><p>用命令 sleep 3600 创建一个 busybox Pod</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">run</span> busybox <span class="hljs-attribute">--image</span>=busybox <span class="hljs-attribute">--restart</span>=Never -- /bin/sh -c <span class="hljs-string">"sleep 3600"</span><br></code></pre></div></td></tr></table></figure></li><li><p>检查 busybox Pod 中 Nginx Pod 的连接</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">get</span> pod nginx -o wide<br><br>kubectl exec -it busybox -- wget -o- 上述命令列出的<span class="hljs-built_in"> ip </span>地址<br></code></pre></div></td></tr></table></figure></li></ol><ol start="23"><li>创建一个能回显消息“How are you”的 busybox Pod，并手动将其删除<figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">run</span> busybox <span class="hljs-attribute">--image</span>=busybox <span class="hljs-attribute">--restart</span>=Never -it -- echo <span class="hljs-string">"How are you"</span><br>kubectl delete po busybox<br></code></pre></div></td></tr></table></figure></li></ol><ol start="24"><li>创建一个 Nginx Pod 并列出具有不同复杂度（verbosity）的 Pod</li></ol><p>kubectl run nginx –image=nginx –restart=Never –port=80<br>kubectl get po nginx –v=7</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">I0105 <span class="hljs-number">20</span>:<span class="hljs-number">54</span>:<span class="hljs-number">25.780863</span>  <span class="hljs-number">118442</span> loader.go:<span class="hljs-number">375</span>] Config loaded <span class="hljs-keyword">from</span> file:  /home/k8s-master/.kube/config<br>I0105 <span class="hljs-number">20</span>:<span class="hljs-number">54</span>:<span class="hljs-number">25.790538</span>  <span class="hljs-number">118442</span> round_trippers.go:<span class="hljs-number">420</span>] GET https:<span class="hljs-comment">//192.168.17.150:6443/api/v1/namespaces/default/pods/nginx</span><br>I0105 <span class="hljs-number">20</span>:<span class="hljs-number">54</span>:<span class="hljs-number">25.790575</span>  <span class="hljs-number">118442</span> round_trippers.go:<span class="hljs-number">427</span>] Request Headers:<br>I0105 <span class="hljs-number">20</span>:<span class="hljs-number">54</span>:<span class="hljs-number">25.790584</span>  <span class="hljs-number">118442</span> round_trippers.go:<span class="hljs-number">431</span>]     Accept: application/json;as=Table;v=v1beta1;g=meta.k8s.io, application/json<br>I0105 <span class="hljs-number">20</span>:<span class="hljs-number">54</span>:<span class="hljs-number">25.790591</span>  <span class="hljs-number">118442</span> round_trippers.go:<span class="hljs-number">431</span>]     User-Agent: kubectl/v1<span class="hljs-number">.16</span><span class="hljs-number">.3</span> (linux/amd64) kubernetes/b3cbbae<br>I0105 <span class="hljs-number">20</span>:<span class="hljs-number">54</span>:<span class="hljs-number">25.797321</span>  <span class="hljs-number">118442</span> round_trippers.go:<span class="hljs-number">446</span>] Response Status: <span class="hljs-number">200</span> OK <span class="hljs-keyword">in</span> <span class="hljs-number">6</span> milliseconds<br>NAME    READY   STATUS    RESTARTS   AGE<br>nginx   <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">3</span>          <span class="hljs-number">91</span>m<br></code></pre></div></td></tr></table></figure><ol start="25"><li>使用自定义列 PODNAME 和 PODSTATUS 列出 Nginx Pod</li></ol><p>kubectl get po nginx -o=custom-columns=”POD_NAME:.metadata.name,POD_STATUS:.status.containerStatuses”</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">nginx      [<span class="hljs-keyword">map</span>[containerID:docker://<span class="hljs-number">9</span>ff65fc8e8771aa9bc069735a7d9bffa915737cdc8da2f491e330c9c11082ebb image:nginx:latest imageID:docker-pullable://nginx@sha256:b2d89d0a210398b4d1120b3e3a7672c16a4ba09c2c4a0395f18b9f7999b768f2 lastState:<span class="hljs-keyword">map</span>[terminated:<span class="hljs-keyword">map</span>[containerID:docker://ade08d0814b2073079bbad9ebf51b3a3fa2af2df4a411f99b255a78d3b669eeb exitCode:<span class="hljs-number">0</span> finishedA<span class="hljs-variable">t:2020</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span>T03:<span class="hljs-number">34</span>:<span class="hljs-number">31</span>Z reason:Completed startedA<span class="hljs-variable">t:2020</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span>T03:<span class="hljs-number">31</span>:<span class="hljs-number">59</span>Z]] name:nginx ready:true restartCoun<span class="hljs-variable">t:3</span> started:true state:<span class="hljs-keyword">map</span>[runnin<span class="hljs-variable">g:map</span>[startedA<span class="hljs-variable">t:2020</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span>T03:<span class="hljs-number">34</span>:<span class="hljs-number">31</span>Z]]]]<br></code></pre></div></td></tr></table></figure><ol start="26"><li><p>列出所有按名称排序的 Pod</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">get</span> po <span class="hljs-attribute">--sort-by</span>=.metadata.name<br></code></pre></div></td></tr></table></figure></li><li><p>列出所有按创建时间排序的 Pod</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">get</span> po <span class="hljs-attribute">--sort-by</span>=.metadata.creationTimestamp<br></code></pre></div></td></tr></table></figure></li></ol><ol start="28"><li>用“ls; sleep 3600;”“echo Hello World; sleep 3600;”及“echo this is the third container; sleep 3600”三个命令创建一个包含三个 busybox 容器的 Pod，并观察其状态</li></ol><p>sudo vim multi-containers.yaml</p><p>apiVersion: v1<br>kind: Pod<br>metadata:<br>  creationTimestamp: null<br>  labels:<br>    run: busybox<br>  name: busybox<br>spec:<br>  containers:</p><ul><li>args:<ul><li>bin/sh</li><li>-c</li><li>ls; sleep 3600<br>image: busybox<br>name: busybox1<br>resources: {}</li></ul></li><li>args:<ul><li>bin/sh</li><li>-c</li><li>echo Hello World;sleep 3600<br>image: busybox<br>name: busybox2<br>resources: {}</li></ul></li><li>args:<ul><li>bin/sh</li><li>-c</li><li>echo this is third containers;sleep 3600<br>image: busybox<br>name: busybox3<br>resources: {}<br>dnsPolicy: ClusterFirst<br>restartPolicy: Never<br>status: {}</li></ul></li></ul><ol start="29"><li>检查刚创建的每个容器的日志<figure class="highlight armasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">kubectl</span> <span class="hljs-meta">get</span> po<br><br><span class="hljs-symbol">kubectl</span> logs <span class="hljs-keyword">busybox </span>-c <span class="hljs-keyword">busybox1</span><br><span class="hljs-keyword">kubectl </span>logs <span class="hljs-keyword">busybox </span>-c <span class="hljs-keyword">busybox2</span><br><span class="hljs-keyword">kubectl </span>logs <span class="hljs-keyword">busybox </span>-c <span class="hljs-keyword">busybox3</span><br></code></pre></div></td></tr></table></figure></li></ol><ol start="30"><li><p>检查第二个容器 busybox2 的先前日志（如果有）</p><figure class="highlight armasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">kubectl</span> logs <span class="hljs-keyword">busybox </span>-c <span class="hljs-keyword">busybox2 </span>--previous<br></code></pre></div></td></tr></table></figure></li><li><p>在上述容器的第三个容器 busybox3 中运行命令 ls</p><figure class="highlight armasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">kubectl</span> exec <span class="hljs-keyword">busybox </span>-c <span class="hljs-keyword">busybox3 </span>-- ls<br></code></pre></div></td></tr></table></figure></li><li><p>显示以上容器的 metrics，将其放入 file.log 中并进行验证</p><figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata">kubectl top pod busybox --containers &gt; <span class="hljs-keyword">file</span>.<span class="hljs-keyword">log</span> &amp;&amp; <span class="hljs-keyword">cat</span> <span class="hljs-keyword">file</span>.<span class="hljs-keyword">log</span><br></code></pre></div></td></tr></table></figure></li><li><p>用主容器 busybox 创建一个 Pod，并执行“while true; do echo ‘Hi I am from Main container’ &gt;&gt; /var/log/index.html; sleep 5; done”，并带有暴露在端口 80 上的 Nginx 镜像的 sidecar 容器。用 emptyDir Volume 将该卷安装在 /var/log 路径（用于 busybox）和 /usr/share/nginx/html 路径（用于nginx容器）。验证两个容器都在运行。</p></li></ol><p>kubectl run muilti-containers-pod –image=busybox –restart=Never –dry-run -o yaml &gt; nulti-containers-pod.yaml</p><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-attribute">apiVersion</span>: v1<br><span class="hljs-attribute">kind</span>: Pod<br><span class="hljs-attribute">metadata</span>:<br>  <span class="hljs-attribute">creationTimestamp</span>: null<br>  <span class="hljs-attribute">labels</span>:<br>    <span class="hljs-attribute">run</span>: muilti-containers-pod<br>  <span class="hljs-attribute">name</span>: muilti-containers-pod<br><span class="hljs-attribute">spec</span>:<br>  <span class="hljs-attribute">volumes</span>: <br>  - <span class="hljs-attribute">name</span>: var-logs<br>    <span class="hljs-attribute">emptyDir</span>: &#123;&#125;<br>  <span class="hljs-attribute">containers</span>:<br>  - <span class="hljs-attribute">image</span>: busybox<br>    <span class="hljs-attribute">command</span>: [<span class="hljs-string">"/bin/sh"</span>]<br>    <span class="hljs-attribute">args</span>: [<span class="hljs-string">"-c"</span>, <span class="hljs-string">"while true; do echo 'Hi I am from Main container' &gt;&gt; /var/log/index.html; sleep 5; done"</span>]<br>    <span class="hljs-attribute">name</span>: main-containers<br>    <span class="hljs-attribute">resources</span>: &#123;&#125;<br>    <span class="hljs-attribute">volumeMounts</span>: <br>    - <span class="hljs-attribute">name</span>: var-logs<br>      <span class="hljs-attribute">mountPath</span>: /var/log<br>  - <span class="hljs-attribute">image</span>: nginx<br>    <span class="hljs-attribute">name</span>: sidercar-container<br>    <span class="hljs-attribute">resources</span>: &#123;&#125;<br>    <span class="hljs-attribute">ports</span>: <br>      - <span class="hljs-attribute">containerPort</span>: <span class="hljs-number">80</span><br>    <span class="hljs-attribute">volumeMounts</span>: <br>    - <span class="hljs-attribute">name</span>: var-logs<br>      <span class="hljs-attribute">mountPath</span>: /usr/share/nginx/html<br>  <span class="hljs-attribute">dnsPolicy</span>: ClusterFirst<br>  <span class="hljs-attribute">restartPolicy</span>: Never<br><span class="hljs-attribute">status</span>: &#123;&#125;<br></code></pre></div></td></tr></table></figure><p>kubectl create -f multi-containers-pod.yaml</p><ol start="34"><li><p>进入两个容器并验证 main.txt 是否存在，并用 curl localhost 从 sidecar 容器中查询 main. txt</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">kubectl exec -it muilti-containers-pod -<span class="hljs-keyword">c</span> main-container -- <span class="hljs-keyword">sh</span><br><span class="hljs-keyword">cat</span> var/<span class="hljs-built_in">log</span>/<span class="hljs-built_in">index</span>.html<br>kubectl exec -it muilti-containers-pod -<span class="hljs-keyword">c</span> sidercar-container -- <span class="hljs-keyword">sh</span><br><span class="hljs-keyword">cat</span> /usr/share/nginx/html/<span class="hljs-built_in">index</span>.html<br></code></pre></div></td></tr></table></figure></li><li><p>获取带有标签信息的 Pod</p><figure class="highlight maxima"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs maxima">kubectl <span class="hljs-built_in">get</span> po --<span class="hljs-built_in">show</span>-<span class="hljs-built_in">labels</span><br></code></pre></div></td></tr></table></figure></li></ol><ol start="36"><li>创建 5 个 Nginx Pod，其中两个标签为 env = prod，另外三个标签为 env = dev<figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">run</span> nginx-dev1 <span class="hljs-attribute">--image</span>=nginx <span class="hljs-attribute">--restart</span>=Never <span class="hljs-attribute">--labels</span>=env=dev<br>kubectl <span class="hljs-builtin-name">run</span> nginx-dev2 <span class="hljs-attribute">--image</span>=nginx <span class="hljs-attribute">--restart</span>=Never <span class="hljs-attribute">--labels</span>=env=dev<br>kubectl <span class="hljs-builtin-name">run</span> nginx-dev3 <span class="hljs-attribute">--image</span>=nginx <span class="hljs-attribute">--restart</span>=Never <span class="hljs-attribute">--labels</span>=env=dev<br>kubectl <span class="hljs-builtin-name">run</span> nginx-pro1 <span class="hljs-attribute">--image</span>=nginx <span class="hljs-attribute">--restart</span>=Never <span class="hljs-attribute">--labels</span>=env=pro<br>kubectl <span class="hljs-builtin-name">run</span> nginx-pro2 <span class="hljs-attribute">--image</span>=nginx <span class="hljs-attribute">--restart</span>=Never <span class="hljs-attribute">--labels</span>=env=pro<br></code></pre></div></td></tr></table></figure></li><li>确认所有 Pod 都使用正确的标签创建</li></ol><p>kubectl get po –show-labels</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">nginx-dev1                  <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">2</span>m2s    env=dev<br>nginx-dev2                  <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">63</span>s     env=dev<br>nginx-dev3                  <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">57</span>s     env=dev<br>nginx-pro1                  <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">52</span>s     env=pro<br>nginx-pro2                  <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">46</span>s     env=pro<br></code></pre></div></td></tr></table></figure><ol start="38"><li>获得带有标签 env=dev 的 Pod</li></ol><p>kubectl get pods -l env=dev</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">nginx-dev1   <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">4</span>m55s<br>nginx-dev2   <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">3</span>m56s<br>nginx-dev3   <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">3</span>m50s<br></code></pre></div></td></tr></table></figure><ol start="39"><li>获得带标签 env=dev 的 Pod 并输出标签<figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">get</span> pods -l <span class="hljs-attribute">env</span>=dev --show-labels<br></code></pre></div></td></tr></table></figure></li><li>获得带有标签 env=pro 的 Pod</li></ol><p>kubectl get pods -l env=pro</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">NAME         READY   STATUS    RESTARTS   AGE<br>nginx-pro1   <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">8</span>m25s<br>nginx-pro2   <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">8</span>m19s<br></code></pre></div></td></tr></table></figure><ol start="41"><li><p>获得带标签 env=prod 的 Pod 并输出标签</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">get</span> pods -l <span class="hljs-attribute">env</span>=pro --show-labels<br></code></pre></div></td></tr></table></figure></li><li><p>获取带有标签 env 的 Pod</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">get</span> po -L env<br></code></pre></div></td></tr></table></figure></li><li><p>获得带标签 env=dev、env=pro 的 Pod</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">get</span> po -l <span class="hljs-string">'env in (dev,pro)'</span><br></code></pre></div></td></tr></table></figure></li><li><p>获取带有标签 env=dev 和 env=pro 的 Pod 并输出标签</p><figure class="highlight dart"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dart">kubectl <span class="hljs-keyword">get</span> po -l <span class="hljs-string">'env in (dev,pro)'</span> --<span class="hljs-keyword">show</span>-labels<br></code></pre></div></td></tr></table></figure></li><li><p>将其中一个容器的标签更改为 env=uat 并列出所有要验证的容器</p><figure class="highlight maxima"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs maxima">kubectl <span class="hljs-built_in">label</span> pod/nginx-pro1 env=aa --overwrite<br>kubectl <span class="hljs-built_in">get</span> pods --<span class="hljs-built_in">show</span>-<span class="hljs-built_in">labels</span><br></code></pre></div></td></tr></table></figure></li><li><p>删除刚才创建的 Pod 标签，并确认所有标签均已删除</p><figure class="highlight maxima"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs maxima">kubectl <span class="hljs-built_in">label</span> pod nginx-dev&#123;<span class="hljs-number">1</span>..<span class="hljs-number">3</span>&#125; env-<br>kubectl <span class="hljs-built_in">label</span> pod nginx-pro&#123;<span class="hljs-number">1</span>..<span class="hljs-number">2</span>&#125; env-<br>kubectl <span class="hljs-built_in">get</span> pods --<span class="hljs-built_in">show</span>-<span class="hljs-built_in">labels</span><br></code></pre></div></td></tr></table></figure></li><li><p>为所有 Pod 添加标签 app = nginx 并验证</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl label pod nginx-dev&#123;1<span class="hljs-built_in">..</span>3&#125; <span class="hljs-attribute">app</span>=nginx<br>kubectl label pod nginx-pro&#123;1<span class="hljs-built_in">..</span>2&#125; <span class="hljs-attribute">app</span>=nginx<br>kubectl <span class="hljs-builtin-name">get</span> pods --show-labels<br></code></pre></div></td></tr></table></figure></li><li><p>获取所有带有标签的节点（如果使用 minikube，则只会获得主节点）</p></li></ol><p>kubectl get nodes –show-labels</p><figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua">NAME         STATUS   ROLES    AGE   VERSION   LABELS<br>k8s-master   Ready    master   <span class="hljs-number">13</span>d   v1<span class="hljs-number">.16</span><span class="hljs-number">.3</span>   beta.kubernetes.<span class="hljs-built_in">io</span>/arch=amd64,beta.kubernetes.<span class="hljs-built_in">io</span>/<span class="hljs-built_in">os</span>=linux,kubernetes.<span class="hljs-built_in">io</span>/arch=amd64,kubernetes.<span class="hljs-built_in">io</span>/hostname=k8s-master,kubernetes.<span class="hljs-built_in">io</span>/<span class="hljs-built_in">os</span>=linux,node-role.kubernetes.<span class="hljs-built_in">io</span>/master=<br>k8s-node01   Ready    &lt;none&gt;   <span class="hljs-number">13</span>d   v1<span class="hljs-number">.16</span><span class="hljs-number">.3</span>   beta.kubernetes.<span class="hljs-built_in">io</span>/arch=amd64,beta.kubernetes.<span class="hljs-built_in">io</span>/<span class="hljs-built_in">os</span>=linux,kubernetes.<span class="hljs-built_in">io</span>/arch=amd64,kubernetes.<span class="hljs-built_in">io</span>/hostname=k8s-node01,kubernetes.<span class="hljs-built_in">io</span>/<span class="hljs-built_in">os</span>=linux<br>k8s-node02   Ready    &lt;none&gt;   <span class="hljs-number">13</span>d   v1<span class="hljs-number">.16</span><span class="hljs-number">.3</span>   beta.kubernetes.<span class="hljs-built_in">io</span>/arch=amd64,beta.kubernetes.<span class="hljs-built_in">io</span>/<span class="hljs-built_in">os</span>=linux,kubernetes.<span class="hljs-built_in">io</span>/arch=amd64,kubernetes.<span class="hljs-built_in">io</span>/hostname=k8s-node02,kubernetes.<span class="hljs-built_in">io</span>/<span class="hljs-built_in">os</span>=linux<br></code></pre></div></td></tr></table></figure><ol start="49"><li>标记节点（如果正在使用，则为 minikube）nodeName = nginxnode<figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">kubectl label <span class="hljs-keyword">node</span> <span class="hljs-title">minikube</span> <span class="hljs-attr">nodeName=</span>nginxnode<br></code></pre></div></td></tr></table></figure></li></ol><ol start="50"><li>建一个标签为 nginx=dev 的 Pod 并将其部署在此节点上<figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">kubectl label <span class="hljs-keyword">node</span> <span class="hljs-title">k8s-node01</span>  <span class="hljs-attr">nginx=</span>dev<br>kubectl label <span class="hljs-keyword">node</span> <span class="hljs-title">k8s-node02</span>  <span class="hljs-attr">nginx=</span>pro<br></code></pre></div></td></tr></table></figure></li></ol><p>参考文献<br>medium.com/bb-tutorials-and-thoughts/practice-enough-with-these-questions-for-the-ckad-exam</p><h1 id="Pod-设计、状态持久性"><a href="#Pod-设计、状态持久性" class="headerlink" title="Pod 设计、状态持久性"></a>Pod 设计、状态持久性</h1><ol start="52"><li>使用节点选择器验证已调度的 Pod</li></ol><p>pod.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">creationTimestamp:</span> <span class="hljs-literal">null</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">run:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">resources:</span> <span class="hljs-string">&#123;&#125;</span><br>  <span class="hljs-attr">dnsPolicy:</span> <span class="hljs-string">ClusterFirst</span><br>  <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span><br>  <span class="hljs-attr">nodeSelector:</span> <br>  <span class="hljs-attr">nginx:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">status:</span> <span class="hljs-string">&#123;&#125;</span><br></code></pre></div></td></tr></table></figure><p>在 50 基础上</p><p>kubectl describe po nginx | grep Node-Selectors</p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh"><span class="hljs-keyword">Node</span>-Selectors:<span class="hljs-title">  nginx</span>=dev<br></code></pre></div></td></tr></table></figure><ol start="53"><li><p>验证我们刚刚创建的 Pod Nginx 是否具有 nginx=dev 这个标签</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">kubectl describe <span class="hljs-keyword">po</span> nginx | <span class="hljs-keyword">grep</span> Labels<br><br><br>Label<span class="hljs-variable">s:</span>       run=nginx<br></code></pre></div></td></tr></table></figure></li><li><p>用 name=webapp 注释 Pod nginx-dev.<em>、nginx-pro.</em></p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl annotate po nginx-dev&#123;1<span class="hljs-built_in">..</span>3&#125; <span class="hljs-attribute">name</span>=webapp<br>kubectl annotate po nginx-pro&#123;1<span class="hljs-built_in">..</span>2&#125; <span class="hljs-attribute">name</span>=webapp<br></code></pre></div></td></tr></table></figure></li></ol><ol start="55"><li>验证已正确注释的 Pod<figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">kubectl describe <span class="hljs-keyword">po</span> nginx-dev&#123;<span class="hljs-number">1</span>..<span class="hljs-number">3</span>&#125; | <span class="hljs-keyword">grep</span> -i annotations<br>kubectl describe <span class="hljs-keyword">po</span> nginx-<span class="hljs-keyword">pro</span>&#123;<span class="hljs-number">1</span>..<span class="hljs-number">2</span>&#125; | <span class="hljs-keyword">grep</span> -i annotations<br></code></pre></div></td></tr></table></figure></li></ol><ol start="56"><li><p>删除 Pod 上的注释并验证</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">kubectl annotate po nginx-dev&#123;<span class="hljs-number">1.</span><span class="hljs-number">.3</span>&#125; name-<br>kubectl annotate po nginx-pro&#123;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>&#125; name-<br>kubectl describe po nginx-dev&#123;<span class="hljs-number">1.</span><span class="hljs-number">.3</span>&#125; | grep -i annotations<br>kubectl describe po nginx-pro&#123;<span class="hljs-number">1.</span><span class="hljs-number">.2</span>&#125; | grep -i annotations<br></code></pre></div></td></tr></table></figure></li><li><p>删除到目前为止我们创建的所有 Pod</p><figure class="highlight livecodeserver"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver">kubectl <span class="hljs-built_in">delete</span> pod <span class="hljs-comment">--all</span><br></code></pre></div></td></tr></table></figure></li><li><p>创建一个名为 webapp 的 Deployment，它带有 5 个副本的镜像 Nginx</p></li></ol><p>kubectl create deployment  webapp –image=nginx –dry-run -o yaml &gt; webapp-deployment.yaml<br>更改 webapp-deployment 的 replicas 为 5</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">creationTimestamp:</span> <span class="hljs-literal">null</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">webapp</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">webapp</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">5</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">webapp</span><br>  <span class="hljs-attr">strategy:</span> <span class="hljs-string">&#123;&#125;</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">creationTimestamp:</span> <span class="hljs-literal">null</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">webapp</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">resources:</span> <span class="hljs-string">&#123;&#125;</span><br><span class="hljs-attr">status:</span> <span class="hljs-string">&#123;&#125;</span><br></code></pre></div></td></tr></table></figure><ol start="59"><li>用标签获取我们刚刚创建的 Deployment</li></ol><p>kubectl get deploy webapp –show-labels</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">NAME     READY   UP-TO-DATE   AVAILABLE   AGE     LABELS<br>webapp   <span class="hljs-number">5</span>/<span class="hljs-number">5</span>     <span class="hljs-number">5</span>            <span class="hljs-number">5</span>           <span class="hljs-number">3</span>m59s   app=webapp<br></code></pre></div></td></tr></table></figure><ol start="60"><li>导出该 Deployment 的 yaml 文件</li></ol><p>kubectl get deploy webapp -o yaml</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-symbol">apiVersion:</span> apps/v1<br><span class="hljs-symbol">kind:</span> Deployment<br><span class="hljs-symbol">metadata:</span><br><span class="hljs-symbol">  annotations:</span><br>    deployment.kubernetes.io/revision: <span class="hljs-string">"1"</span><br>    kubectl.kubernetes.io/last-applied-configuration: |<br>      &#123;<span class="hljs-string">"apiVersion"</span>:<span class="hljs-string">"apps/v1"</span>,<span class="hljs-string">"kind"</span>:<span class="hljs-string">"Deployment"</span>,<span class="hljs-string">"metadata"</span>:&#123;<span class="hljs-string">"annotations"</span>:&#123;&#125;,<span class="hljs-string">"creationTimestamp"</span>:null,<span class="hljs-string">"labels"</span>:&#123;<span class="hljs-string">"app"</span>:<span class="hljs-string">"webapp"</span>&#125;,<span class="hljs-string">"name"</span>:<span class="hljs-string">"webapp"</span>,<span class="hljs-string">"namespace"</span>:<span class="hljs-string">"default"</span>&#125;,<span class="hljs-string">"spec"</span>:&#123;<span class="hljs-string">"replicas"</span>:<span class="hljs-number">5</span>,<span class="hljs-string">"selector"</span>:&#123;<span class="hljs-string">"matchLabels"</span>:&#123;<span class="hljs-string">"app"</span>:<span class="hljs-string">"webapp"</span>&#125;&#125;,<span class="hljs-string">"strategy"</span>:&#123;&#125;,<span class="hljs-string">"template"</span>:&#123;<span class="hljs-string">"metadata"</span>:&#123;<span class="hljs-string">"creationTimestamp"</span>:null,<span class="hljs-string">"labels"</span>:&#123;<span class="hljs-string">"app"</span>:<span class="hljs-string">"webapp"</span>&#125;&#125;,<span class="hljs-string">"spec"</span>:&#123;<span class="hljs-string">"containers"</span>:[&#123;<span class="hljs-string">"image"</span>:<span class="hljs-string">"nginx"</span>,<span class="hljs-string">"name"</span>:<span class="hljs-string">"nginx"</span>,<span class="hljs-string">"resources"</span>:&#123;&#125;&#125;]&#125;&#125;&#125;,<span class="hljs-string">"status"</span>:&#123;&#125;&#125;<br><span class="hljs-symbol">  creationTimestamp:</span> <span class="hljs-string">"2020-01-08T05:52:11Z"</span><br><span class="hljs-symbol">  generation:</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">  labels:</span><br><span class="hljs-symbol">    app:</span> webapp<br><span class="hljs-symbol">  name:</span> webapp<br><span class="hljs-symbol">  namespace:</span> default<br><span class="hljs-symbol">  resourceVersion:</span> <span class="hljs-string">"30357"</span><br><span class="hljs-symbol">  selfLink:</span> <span class="hljs-meta-keyword">/apis/</span>apps<span class="hljs-meta-keyword">/v1/</span>namespaces<span class="hljs-meta-keyword">/default/</span>deployments/webapp<br><span class="hljs-symbol">  uid:</span> defb62c1<span class="hljs-number">-1</span>b1d<span class="hljs-number">-43</span>db-ab43<span class="hljs-number">-5</span>cfe90f67d68<br><span class="hljs-symbol">spec:</span><br><span class="hljs-symbol">  progressDeadlineSeconds:</span> <span class="hljs-number">600</span><br><span class="hljs-symbol">  replicas:</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">  revisionHistoryLimit:</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">  selector:</span><br><span class="hljs-symbol">    matchLabels:</span><br><span class="hljs-symbol">      app:</span> webapp<br><span class="hljs-symbol">  strategy:</span><br><span class="hljs-symbol">    rollingUpdate:</span><br><span class="hljs-symbol">      maxSurge:</span> <span class="hljs-number">25</span>%<br><span class="hljs-symbol">      maxUnavailable:</span> <span class="hljs-number">25</span>%<br><span class="hljs-symbol">    type:</span> RollingUpdate<br><span class="hljs-symbol">  template:</span><br><span class="hljs-symbol">    metadata:</span><br><span class="hljs-symbol">      creationTimestamp:</span> null<br><span class="hljs-symbol">      labels:</span><br><span class="hljs-symbol">        app:</span> webapp<br><span class="hljs-symbol">    spec:</span><br><span class="hljs-symbol">      containers:</span><br>      - image: nginx<br><span class="hljs-symbol">        imagePullPolicy:</span> Always<br><span class="hljs-symbol">        name:</span> nginx<br><span class="hljs-symbol">        resources:</span> &#123;&#125;<br><span class="hljs-symbol">        terminationMessagePath:</span> <span class="hljs-meta-keyword">/dev/</span>termination-log<br><span class="hljs-symbol">        terminationMessagePolicy:</span> File<br><span class="hljs-symbol">      dnsPolicy:</span> ClusterFirst<br><span class="hljs-symbol">      restartPolicy:</span> Always<br><span class="hljs-symbol">      schedulerName:</span> default-scheduler<br><span class="hljs-symbol">      securityContext:</span> &#123;&#125;<br><span class="hljs-symbol">      terminationGracePeriodSeconds:</span> <span class="hljs-number">30</span><br><span class="hljs-symbol">status:</span><br><span class="hljs-symbol">  availableReplicas:</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">  conditions:</span><br>  - lastTransitionTime: <span class="hljs-string">"2020-01-08T05:52:26Z"</span><br><span class="hljs-symbol">    lastUpdateTime:</span> <span class="hljs-string">"2020-01-08T05:52:26Z"</span><br><span class="hljs-symbol">    message:</span> Deployment has minimum availability.<br><span class="hljs-symbol">    reason:</span> MinimumReplicasAvailable<br><span class="hljs-symbol">    status:</span> <span class="hljs-string">"True"</span><br><span class="hljs-symbol">    type:</span> Available<br>  - lastTransitionTime: <span class="hljs-string">"2020-01-08T05:52:11Z"</span><br><span class="hljs-symbol">    lastUpdateTime:</span> <span class="hljs-string">"2020-01-08T05:52:29Z"</span><br><span class="hljs-symbol">    message:</span> ReplicaSet <span class="hljs-string">"webapp-58867d7bbb"</span> has successfully progressed.<br><span class="hljs-symbol">    reason:</span> NewReplicaSetAvailable<br><span class="hljs-symbol">    status:</span> <span class="hljs-string">"True"</span><br><span class="hljs-symbol">    type:</span> Progressing<br><span class="hljs-symbol">  observedGeneration:</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">  readyReplicas:</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">  replicas:</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">  updatedReplicas:</span> <span class="hljs-number">5</span><br></code></pre></div></td></tr></table></figure><ol start="61"><li>获取该 Deployment 的 Pod</li></ol><p>kubectl get deploy –show-labels</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">NAME               READY   UP-TO-DATE   AVAILABLE   AGE    LABELS<br>nginx-deployment   <span class="hljs-number">3</span>/<span class="hljs-number">3</span>     <span class="hljs-number">3</span>            <span class="hljs-number">3</span>           <span class="hljs-number">19</span>h    app=nginx<br>webapp             <span class="hljs-number">5</span>/<span class="hljs-number">5</span>     <span class="hljs-number">5</span>            <span class="hljs-number">5</span>           <span class="hljs-number">7</span>m1s   app=webapp<br></code></pre></div></td></tr></table></figure><p>kubectl get po -l app=webapp</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">NAME                      READY   STATUS    RESTARTS   AGE<br>webapp<span class="hljs-number">-58867</span>d7bbb<span class="hljs-number">-4</span>q5nn   <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">7</span>m29s<br>webapp<span class="hljs-number">-58867</span>d7bbb<span class="hljs-number">-9</span>jxc7   <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">7</span>m29s<br>webapp<span class="hljs-number">-58867</span>d7bbb-hxfv6   <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">7</span>m29s<br>webapp<span class="hljs-number">-58867</span>d7bbb-qj2nk   <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">7</span>m29s<br>webapp<span class="hljs-number">-58867</span>d7bbb-wmms4   <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">7</span>m29s<br></code></pre></div></td></tr></table></figure><ol start="62"><li><p>将该 Deployment 从 5 个副本扩展到 20 个副本并验证</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl scale deploy webapp <span class="hljs-attribute">--replicas</span>=20<br><br>尝试 <span class="hljs-attribute">--replicas</span>=1000 机器配置过低 会发生问题<br><br>kubectl <span class="hljs-builtin-name">get</span> po -l <span class="hljs-attribute">app</span>=webapp<br></code></pre></div></td></tr></table></figure></li><li><p>获取该 Deployment 的 rollout 状态</p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">kubectl rollout status deploy webapp</span><br></code></pre></div></td></tr></table></figure></li></ol><ol start="64"><li><p>获取使用该 Deployment 创建的副本集</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">get</span> rs -l <span class="hljs-attribute">app</span>=webapp<br></code></pre></div></td></tr></table></figure></li><li><p>获取该 Deployment 的副本集和 Pod 的 yaml</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">get</span> rs -l <span class="hljs-attribute">app</span>=webapp -o yaml<br>kubectl <span class="hljs-builtin-name">get</span> po -l <span class="hljs-attribute">app</span>=webapp -o yaml<br></code></pre></div></td></tr></table></figure></li><li><p>删除刚创建的 Deployment，并查看所有 Pod 是否已被删除</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl delete deploy webapp<br>kubectl <span class="hljs-builtin-name">get</span> po -l <span class="hljs-attribute">app</span>=webapp -w<br></code></pre></div></td></tr></table></figure></li><li><p>使用镜像 nginx：1.17.1 和容器端口 80 创建 webapp Deployment，并验证镜像版本</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl create deploy webapp <span class="hljs-attribute">--image</span>=nginx:1.17.1 --dry-<span class="hljs-builtin-name">run</span> -o yaml &gt; webapp.yaml<br></code></pre></div></td></tr></table></figure><p>apiVersion: apps/v1<br>kind: Deployment<br>metadata:<br>creationTimestamp: null<br>labels:<br>app: webapp<br>name: webapp<br>spec:<br>replicas: 1<br>selector:<br>matchLabels:<br>  app: webapp<br>strategy: {}<br>template:<br>metadata:<br>  creationTimestamp: null<br>  labels:</p><div class="hljs code-wrapper"><pre><code>app: webapp</code></pre></div><p>spec:<br>  containers:</p><ul><li>image: nginx:1.17.1<br>name: nginx<br>ports: <ul><li>containerPort: 80<br>resources: {}<br>status: {}<figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros"><br>68. 使用镜像版本 1.17.4 更新 Deployment 并验证<br><br>kubectl <span class="hljs-builtin-name">set</span> image deploy/webapp <span class="hljs-attribute">nginx</span>=nginx:1.17.4<br>kubectl <span class="hljs-builtin-name">get</span> deploy  -o wide<br></code></pre></div></td></tr></table></figure>NAME               READY   UP-TO-DATE   AVAILABLE   AGE    CONTAINERS   IMAGES         SELECTOR<br>nginx-deployment   3/3     3            3           20h    nginx        nginx:1.7.9    app=nginx<br>webapp             1/1     1            1           5m7s   nginx        nginx:1.17.4   app=webapp<figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c"><br>kubectl describe deploy webapp <span class="hljs-string">| grep Image</span><br></code></pre></div></td></tr></table></figure>Image:        nginx:1.17.4<figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli"><br>69. 检查 rollout 历史记录，并确保更新后一切正常<br><br>kubectl rollout <span class="hljs-keyword">history</span> <span class="hljs-keyword">deploy</span> webapp<br></code></pre></div></td></tr></table></figure>deployment.apps/webapp<br>REVISION  CHANGE-CAUSE<br>1         <none><br>2         <none><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">get</span> deploy webapp --show-labels<br>kubectl <span class="hljs-builtin-name">get</span> rs -l <span class="hljs-attribute">app</span>=webapp<br>kubectl <span class="hljs-builtin-name">get</span> po -l <span class="hljs-attribute">app</span>=webapp<br><br>70. 撤消之前使用版本 1.17.1 的 Deployment，并验证镜像是否还有老版本<br><br>kubectl rollout undo deploy webapp<br>kubectl rollout history deploy webapp<br></code></pre></div></td></tr></table></figure>deployment.apps/webapp<br>REVISION  CHANGE-CAUSE<br>2         <none><br>3         <none><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">kubectl describe deploy webapp | grep Image<br><br><span class="hljs-number">71.</span> 使用镜像版本 <span class="hljs-number">1.16</span><span class="hljs-number">.1</span> 更新 Deployment，并验证镜像、检查 rollout 历史记录<br><br>kubectl <span class="hljs-keyword">set</span> image deploy/webapp nginx=nginx:<span class="hljs-number">1.16</span><span class="hljs-number">.1</span><br>kubectl rollout status deploy webapp<br></code></pre></div></td></tr></table></figure>Waiting for deployment “webapp” rollout to finish: 1 old replicas are pending termination…<br>Waiting for deployment “webapp” rollout to finish: 1 old replicas are pending termination…<br>deployment “webapp” successfully rolled out<figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">kubectl rollout <span class="hljs-keyword">history</span> <span class="hljs-keyword">deploy</span> webapp<br></code></pre></div></td></tr></table></figure>deployment.apps/webapp<br>REVISION  CHANGE-CAUSE<br>2         <none><br>3         <none><br>4         <none></li></ul></li></ul></li></ol><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">kubectl describe deploy webapp | grep Image<br>  Image:        nginx:<span class="hljs-number">1.16</span><span class="hljs-number">.1</span><br></code></pre></div></td></tr></table></figure><ol start="72"><li>将 Deployment 更新到镜像 1.17.1 并确认一切正常<figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">kubectl rollout undo <span class="hljs-keyword">deploy</span> webapp <span class="hljs-params">--to-revision=3</span><br>kubectl rollout <span class="hljs-keyword">history</span> <span class="hljs-keyword">deploy</span> webapp<br>kubectl describe <span class="hljs-keyword">deploy</span> webapp | grep Image<br></code></pre></div></td></tr></table></figure></li></ol><ol start="73"><li><p>使用错误的镜像版本 1.100 更新 Deployment，并验证有问题</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">set</span> image deploy/webapp <span class="hljs-attribute">nginx</span>=nginx:1.10000<br>kubectl rollout history deploy webapp<br>kubectl <span class="hljs-builtin-name">get</span> pods<br>kubectl describe po pod名称<br><span class="hljs-builtin-name">Warning</span>  Failed     2s (x2 over 52s)   kubelet, k8s-node01  Error: ImagePullBackOff<br></code></pre></div></td></tr></table></figure></li><li><p>撤消使用先前版本的 Deployment，并确认一切正常</p><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">kubectl</span> <span class="hljs-string">rollout undo deploy webapp</span><br><span class="hljs-attr">kubectl</span> <span class="hljs-string">rollout status deploy webapp</span><br><span class="hljs-attr">kubectl</span> <span class="hljs-string">get pods</span><br></code></pre></div></td></tr></table></figure></li><li><p>检查该 Deployment 的特定修订版本的历史记录</p><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">kubectl rollout <span class="hljs-keyword">history</span> <span class="hljs-keyword">deploy</span> webapp <span class="hljs-params">--revision=</span>特定版本记录号<br></code></pre></div></td></tr></table></figure></li></ol><ol start="76"><li><p>暂停 Deployment rollout</p><figure class="highlight autohotkey"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs autohotkey">kubectl rollout <span class="hljs-keyword">pause</span> deploy  webapp<br></code></pre></div></td></tr></table></figure></li><li><p>用最新版本的镜像更新 Deployment，并检查历史记录</p><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">kubectl <span class="hljs-keyword">set</span> image <span class="hljs-keyword">deploy</span>/webapp nginx=nginx<span class="hljs-function">:lastest</span><br>kubectl rollout <span class="hljs-keyword">history</span> <span class="hljs-keyword">deploy</span> webapp<br></code></pre></div></td></tr></table></figure></li><li><p>恢复 Deployment rollout</p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">kubectl rollout resume deploy  webapp</span><br></code></pre></div></td></tr></table></figure></li><li><p>检查 rollout 历史记录，确保是最新版本</p><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">kubectl rollout <span class="hljs-keyword">history</span> <span class="hljs-keyword">deploy</span> webapp<br>kubectl rollout <span class="hljs-keyword">history</span> <span class="hljs-keyword">deploy</span> webapp <span class="hljs-params">--revision=9</span><br></code></pre></div></td></tr></table></figure></li><li><p>将自动伸缩应用到该 Deployment 中，最少副本数为 10，最大副本数为 20，<br>目标 CPU 利用率 85%，并验证 hpa 已创建，将副本数从 1 个增加到 10 个</p></li></ol><p>kubectl autoscale deploy webapp –min=10 –max=20 –cpu-percent=85</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">kubectl <span class="hljs-keyword">get</span> hpa<br>NAME     REFERENCE           TARGETS         MINPODS   MAXPODS   REPLICAS   AGE<br>webapp   Deployment/webapp   &lt;unknown&gt;/<span class="hljs-number">85</span>%   <span class="hljs-number">10</span>        <span class="hljs-number">20</span>        <span class="hljs-number">0</span>          <span class="hljs-number">9</span>s<br></code></pre></div></td></tr></table></figure><p>kubectl get po -l app=webapp</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">NAME                      READY   STATUS    RESTARTS   AGE<br>webapp<span class="hljs-number">-7668577</span>c8f<span class="hljs-number">-98</span>ltc   <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">29</span>s<br>webapp<span class="hljs-number">-7668577</span>c8f-bjmhz   <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">29</span>s<br>webapp<span class="hljs-number">-7668577</span>c8f-cbl2k   <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">29</span>s<br>webapp<span class="hljs-number">-7668577</span>c8f-dnb5z   <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">2</span>m54s<br>webapp<span class="hljs-number">-7668577</span>c8f-dvfrt   <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">29</span>s<br>webapp<span class="hljs-number">-7668577</span>c8f-gcqgt   <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">29</span>s<br>webapp<span class="hljs-number">-7668577</span>c8f-ht8pg   <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">29</span>s<br>webapp<span class="hljs-number">-7668577</span>c8f-nhjzs   <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">29</span>s<br>webapp<span class="hljs-number">-7668577</span>c8f-nsmqd   <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">29</span>s<br>webapp<span class="hljs-number">-7668577</span>c8f-rjg58   <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">29</span>s<br></code></pre></div></td></tr></table></figure><ol start="81"><li><p>通过删除刚刚创建的 Deployment 和 hpa 来清理集群</p><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript">kubectl <span class="hljs-keyword">delete</span> deploy webapp<br>kubectl <span class="hljs-keyword">delete</span> hpa webapp<br></code></pre></div></td></tr></table></figure></li><li><p>用镜像 node 创建一个 Job，并验证是否有对应的 Pod 创建</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl create job nodeversion <span class="hljs-attribute">--image</span>=node -- node v<br>kubectl <span class="hljs-builtin-name">get</span> job -w<br>kubectl <span class="hljs-builtin-name">get</span> pod<br></code></pre></div></td></tr></table></figure></li><li><p>获取刚刚创建的 Job 的日志</p><figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">kubectl</span> logs pod 名称<br></code></pre></div></td></tr></table></figure></li><li><p>用镜像 busybox 输出 Job 的 yaml 文件，并回显“Hello I am from job”</p></li></ol><p>kubectl create job hello-job –image=busybox –dry-run -o yaml – echo “Hello I am from job”</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">creationTimestamp:</span> <span class="hljs-literal">null</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hello-job</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">creationTimestamp:</span> <span class="hljs-literal">null</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">command:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">echo</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Hello</span> <span class="hljs-string">I</span> <span class="hljs-string">am</span> <span class="hljs-string">from</span> <span class="hljs-string">job</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">hello-job</span><br>        <span class="hljs-attr">resources:</span> <span class="hljs-string">&#123;&#125;</span><br>      <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span><br><span class="hljs-attr">status:</span> <span class="hljs-string">&#123;&#125;</span><br></code></pre></div></td></tr></table></figure><ol start="85"><li><p>将上面的 yaml 文件复制到 hello-job.yaml 文件并创建 Job</p><figure class="highlight cos"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cos">kubectl create <span class="hljs-keyword">job</span> hello-<span class="hljs-keyword">job</span> --image=busybox --dry-run -o yaml -- echo <span class="hljs-string">"Hello I am from job"</span> &gt; hello-<span class="hljs-keyword">job</span>.yaml<br><br>kubectl apply -f hello-<span class="hljs-keyword">job</span>.yaml<br></code></pre></div></td></tr></table></figure></li><li><p>验证 Job 并创建关联的容器，检查日志</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">get</span> pod<br>kubectl <span class="hljs-builtin-name">get</span> po<br>kubectl logs po 名称<br></code></pre></div></td></tr></table></figure></li><li><p>删除我们刚刚创建的 Job</p><figure class="highlight cos"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cos">kubectl delete <span class="hljs-keyword">job</span> hello-<span class="hljs-keyword">job</span><br></code></pre></div></td></tr></table></figure></li><li><p>创建一个相同的 Job，并使它一个接一个地运行 10 次</p></li></ol><p>kubectl create job hello-job –image=busybox –dry-run -o yaml – echo “Hello I am from job” &gt; 10-job.yaml</p><p>在 10-job.yaml 添加 completions: 10</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">creationTimestamp:</span> <span class="hljs-literal">null</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hello-job</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">completions:</span> <span class="hljs-number">10</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">creationTimestamp:</span> <span class="hljs-literal">null</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">command:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">echo</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Hello</span> <span class="hljs-string">I</span> <span class="hljs-string">am</span> <span class="hljs-string">from</span> <span class="hljs-string">Job</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">hello-job</span><br>        <span class="hljs-attr">resources:</span> <span class="hljs-string">&#123;&#125;</span><br>      <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span><br><span class="hljs-attr">status:</span> <span class="hljs-string">&#123;&#125;</span><br></code></pre></div></td></tr></table></figure><p>kubectl get job -w<br>kubectl get po</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">NAME          COMPLETIONS   DURATION   AGE<br>hello-job     <span class="hljs-number">9</span>/<span class="hljs-number">10</span>          <span class="hljs-number">53</span>s        <span class="hljs-number">53</span>s<br>nodeversion   <span class="hljs-number">1</span>/<span class="hljs-number">1</span>           <span class="hljs-number">3</span>m14s      <span class="hljs-number">18</span>m<br>hello-job     <span class="hljs-number">10</span>/<span class="hljs-number">10</span>         <span class="hljs-number">59</span>s        <span class="hljs-number">59</span>s<br></code></pre></div></td></tr></table></figure><ol start="89"><li><p>运行 10 次，确认已创建 10 个 Pod，并在完成后删除它们</p><figure class="highlight cos"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cos">kubectl delete <span class="hljs-keyword">job</span> hello-<span class="hljs-keyword">job</span><br></code></pre></div></td></tr></table></figure></li><li><p>创建相同的 Job 并使它并行运行 10 次</p></li></ol><p>kubectl create job hello-job –image=busybox –dry-run -o yaml – echo “Hello I am from job” &gt; 10-parallelism-job.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">creationTimestamp:</span> <span class="hljs-literal">null</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hello-job</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">parallelism:</span> <span class="hljs-number">10</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">creationTimestamp:</span> <span class="hljs-literal">null</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">command:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">echo</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Hello</span> <span class="hljs-string">I</span> <span class="hljs-string">am</span> <span class="hljs-string">from</span> <span class="hljs-string">Job</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">hello-job</span><br>        <span class="hljs-attr">resources:</span> <span class="hljs-string">&#123;&#125;</span><br>      <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span><br><span class="hljs-attr">status:</span> <span class="hljs-string">&#123;&#125;</span><br></code></pre></div></td></tr></table></figure><ol start="91"><li>并行运行 10 次，确认已创建 10 个 Pod，并在完成后将其删除</li></ol><p>kubectl get job -w<br>kubectl get po</p><ol start="92"><li>创建一个带有 busybox 镜像的 Cronjob，每分钟打印一次来自 Kubernetes 集群消息的日期和 hello</li></ol><p>kubectl create cronjob date-job –image=busybox –schedule=”*/1 * * * *” – bin/sh -c “date; echo Hello from kubernetes cluster”</p><p>kubectl get cronjob</p><p>kubectl get po</p><p>kubectl logs pod 名称</p><ol start="93"><li>输出上述 cronjob 的 yaml 文件</li></ol><p>kubectl get cj date-job -o yaml</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">CronJob</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">creationTimestamp:</span> <span class="hljs-string">"2020-01-08T08:50:52Z"</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">date-job</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br>  <span class="hljs-attr">resourceVersion:</span> <span class="hljs-string">"50543"</span><br>  <span class="hljs-attr">selfLink:</span> <span class="hljs-string">/apis/batch/v1beta1/namespaces/default/cronjobs/date-job</span><br>  <span class="hljs-attr">uid:</span> <span class="hljs-string">22d49b8d-58ec-468a-b589-d5f60f0030c0</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">concurrencyPolicy:</span> <span class="hljs-string">Allow</span><br>  <span class="hljs-attr">failedJobsHistoryLimit:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">jobTemplate:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">creationTimestamp:</span> <span class="hljs-literal">null</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">date-job</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">template:</span><br>        <span class="hljs-attr">metadata:</span><br>          <span class="hljs-attr">creationTimestamp:</span> <span class="hljs-literal">null</span><br>        <span class="hljs-attr">spec:</span><br>          <span class="hljs-attr">containers:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">command:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">bin/sh</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">-c</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">date;</span> <span class="hljs-string">echo</span> <span class="hljs-string">Hello</span> <span class="hljs-string">from</span> <span class="hljs-string">kubernetes</span> <span class="hljs-string">cluster</span><br>            <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>            <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">Always</span><br>            <span class="hljs-attr">name:</span> <span class="hljs-string">date-job</span><br>            <span class="hljs-attr">resources:</span> <span class="hljs-string">&#123;&#125;</span><br>            <span class="hljs-attr">terminationMessagePath:</span> <span class="hljs-string">/dev/termination-log</span><br>            <span class="hljs-attr">terminationMessagePolicy:</span> <span class="hljs-string">File</span><br>          <span class="hljs-attr">dnsPolicy:</span> <span class="hljs-string">ClusterFirst</span><br>          <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">OnFailure</span><br>          <span class="hljs-attr">schedulerName:</span> <span class="hljs-string">default-scheduler</span><br>          <span class="hljs-attr">securityContext:</span> <span class="hljs-string">&#123;&#125;</span><br>          <span class="hljs-attr">terminationGracePeriodSeconds:</span> <span class="hljs-number">30</span><br>  <span class="hljs-attr">schedule:</span> <span class="hljs-string">'*/1 * * * *'</span><br>  <span class="hljs-attr">successfulJobsHistoryLimit:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">suspend:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">status:</span><br>  <span class="hljs-attr">lastScheduleTime:</span> <span class="hljs-string">"2020-01-08T08:51:00Z"</span><br></code></pre></div></td></tr></table></figure><ol start="94"><li><p>验证 cronJob 为每分钟运行创建一个单独的 Job 和 Pod，并验证 Pod 的日志</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">kubectl <span class="hljs-built_in">get</span> job<br>kubectl <span class="hljs-built_in">get</span> <span class="hljs-keyword">po</span><br>kubectl logs date-job-<span class="hljs-symbol">&lt;jobid&gt;</span>-<span class="hljs-symbol">&lt;pod&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>删除 cronJob，并验证所有关联的 Job 和 Pod 也都被删除</p><figure class="highlight livecodeserver"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver">kubectl <span class="hljs-built_in">delete</span> cj <span class="hljs-built_in">date</span>-job<br>// verify pods <span class="hljs-keyword">and</span> jobs<br>kubectl <span class="hljs-built_in">get</span> po<br>kubectl <span class="hljs-built_in">get</span> job<br></code></pre></div></td></tr></table></figure></li><li><p>列出集群中的持久卷</p><figure class="highlight maxima"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs maxima">kubectl <span class="hljs-built_in">get</span> <span class="hljs-built_in">pv</span><br></code></pre></div></td></tr></table></figure></li><li><p>创建一个名为 task-pv-volume 的 PersistentVolume，其 storgeClassName 为 manual，storage 为 10Gi，accessModes 为 ReadWriteOnce，hostPath 为 /mnt/data</p></li></ol><p>task-pv-volume.yaml</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-symbol">apiVersion:</span> v1<br><span class="hljs-symbol">kind:</span> PersistentVolume<br><span class="hljs-symbol">metadata:</span><br><span class="hljs-symbol">  name:</span> task-pv-volume<br><span class="hljs-symbol">  labels:</span> <br><span class="hljs-symbol">    type:</span> local<br><span class="hljs-symbol">spec:</span><br><span class="hljs-symbol">  capacity:</span><br><span class="hljs-symbol">    storage:</span> <span class="hljs-number">10</span>Gi<br><span class="hljs-symbol">  accessModes:</span><br>    - ReadWriteOnce<br><span class="hljs-symbol">  storageClassName:</span> manual<br><span class="hljs-symbol">  hostPath:</span> <br><span class="hljs-symbol">    path:</span> <span class="hljs-string">"/mnt/data"</span><br></code></pre></div></td></tr></table></figure><p>kubectl get pv</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">NAME             CAPACITY   ACCESS MODES   RECLAIM<span class="hljs-built_in"> POLICY </span>  STATUS      CLAIM   STORAGECLASS   REASON   AGE<br>task-pv-volume   10Gi       RWO            Retain           Available          <span class="hljs-built_in"> manual </span>                 88s<br></code></pre></div></td></tr></table></figure><ol start="98"><li>创建一个存储至少 3Gi、访问模式为 ReadWriteOnce 的 PersistentVolumeClaim，并确认它的状态是否是绑定的</li></ol><p>kubectl create -f task-pv-claim.yaml<br>kubectl get pvc</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-symbol">apiVersion:</span> v1<br><span class="hljs-symbol">kind:</span> PersistentVolumeClaim<br><span class="hljs-symbol">metadata:</span><br><span class="hljs-symbol">  name:</span> task-pv-claim<br><span class="hljs-symbol">spec:</span><br><span class="hljs-symbol">  accessModes:</span><br>    - ReadWriteOnce<br><span class="hljs-symbol">  resources:</span><br><span class="hljs-symbol">    requests:</span><br><span class="hljs-symbol">      storage:</span> <span class="hljs-number">3</span>Gi<br><span class="hljs-symbol">  storageClassName:</span> manual<br></code></pre></div></td></tr></table></figure><ol start="99"><li><p>删除我们刚刚创建的持久卷和 PersistentVolumeClaim</p><figure class="highlight maxima"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs maxima">kubectl <span class="hljs-built_in">delete</span> pvc task-<span class="hljs-built_in">pv</span>-claim<br>kubectl <span class="hljs-built_in">delete</span> <span class="hljs-built_in">pv</span> task-<span class="hljs-built_in">pv</span>-volume<br></code></pre></div></td></tr></table></figure></li><li><p>使用镜像 Redis 创建 Pod，并配置一个在 Pod 生命周期内可持续使用的卷</p></li></ol><p>redis-storage.yaml</p><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-attribute">apiVersion</span>: v1<br><span class="hljs-attribute">kind</span>: Pod<br><span class="hljs-attribute">metadata</span>:<br>  <span class="hljs-attribute">name</span>: redis<br><span class="hljs-attribute">spec</span>:<br>  <span class="hljs-attribute">containers</span>:<br>  - <span class="hljs-attribute">name</span>: redis<br>    <span class="hljs-attribute">image</span>: redis<br>    <span class="hljs-attribute">volumeMounts</span>:<br>    - <span class="hljs-attribute">name</span>: redis-storage<br>      <span class="hljs-attribute">mountPath</span>: /data/redis<br>  <span class="hljs-attribute">volumes</span>:<br>  - <span class="hljs-attribute">name</span>: redis-storage<br>    <span class="hljs-attribute">emptyDir</span>: &#123;&#125;<br></code></pre></div></td></tr></table></figure><ol start="101"><li>在上面的 Pod 中执行操作，并在 /data/redis 路径中创建一个名为 file.txt 的文件，其文本为“This is the file”，然后打开另一个选项卡，再次使用同一 Pod 执行，并验证文件是否在同一路径中<figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">kubectl exec -it redis <span class="hljs-string">/bin/sh</span><br><br><span class="hljs-keyword">cd</span> <span class="hljs-string">/data/redis</span><br><br><span class="hljs-keyword">echo</span> <span class="hljs-string">"This is the file"</span> &gt; file.txt<br></code></pre></div></td></tr></table></figure></li></ol><ol start="102"><li>删除上面的 Pod，然后从相同的 yaml 文件再次创建，并验证路径 /data/redis 中是否没有 file.txt<figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">kubectl <span class="hljs-keyword">delete</span> <span class="hljs-keyword">po</span> redis<br><br>kubectl apply -<span class="hljs-keyword">f</span> redis-storage.yaml<br><br>kubectl exec -it redis /bin/<span class="hljs-keyword">sh</span><br><br><span class="hljs-keyword">cat</span> /data/redis/<span class="hljs-keyword">file</span>.txt<br><span class="hljs-keyword">ca</span><span class="hljs-variable">t:</span> /data/redis/<span class="hljs-keyword">file</span>.tx<span class="hljs-variable">t:</span> No such <span class="hljs-keyword">file</span> <span class="hljs-built_in">or</span> directory<br></code></pre></div></td></tr></table></figure></li></ol><ol start="103"><li>创建一个名为 task-pv-volume 的 PersistentVolume，其 storgeClassName 为 manual，storage 为 10Gi，accessModes 为 ReadWriteOnce，hostPath 为 /mnt/data；并创建一个存储至少 3Gi、访问模式为 ReadWriteOnce 的 PersistentVolumeClaim，并确认它的状态是否是绑定的</li></ol><p>kubectl create -f task-pv-volume.yaml<br>kubectl create -f task-pv-claim.yaml<br>kubectl get pv<br>kubectl get pvc</p><p>配置如下所述：<br>task-pv-volume.yaml</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-symbol">apiVersion:</span> v1<br><span class="hljs-symbol">kind:</span> PersistentVolume<br><span class="hljs-symbol">metadata:</span><br><span class="hljs-symbol">  name:</span> task-pv-volume<br><span class="hljs-symbol">  labels:</span> <br><span class="hljs-symbol">    type:</span> local<br><span class="hljs-symbol">spec:</span><br><span class="hljs-symbol">  capacity:</span><br><span class="hljs-symbol">    storage:</span> <span class="hljs-number">10</span>Gi<br><span class="hljs-symbol">  accessModes:</span><br>    - ReadWriteOnce<br><span class="hljs-symbol">  storageClassName:</span> manual<br><span class="hljs-symbol">  hostPath:</span> <br><span class="hljs-symbol">    path:</span> <span class="hljs-string">"/mnt/data"</span><br></code></pre></div></td></tr></table></figure><p>task-pv-claim.yaml</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-symbol">apiVersion:</span> v1<br><span class="hljs-symbol">kind:</span> PersistentVolumeClaim<br><span class="hljs-symbol">metadata:</span><br><span class="hljs-symbol">  name:</span> task-pv-claim<br><span class="hljs-symbol">spec:</span><br><span class="hljs-symbol">  accessModes:</span><br>    - ReadWriteOnce<br><span class="hljs-symbol">  resources:</span><br><span class="hljs-symbol">    requests:</span><br><span class="hljs-symbol">      storage:</span> <span class="hljs-number">3</span>Gi<br><span class="hljs-symbol">  storageClassName:</span> manual<br></code></pre></div></td></tr></table></figure><ol start="104"><li>用容器端口 80 和 PersistentVolumeClaim task-pv-claim 创建一个 Nginx 容器，且具有路径“/usr/share/nginx/html”</li></ol><p>task-pv-pod.yaml</p><p>apiVersion: v1<br>kind: Pod<br>metadata:<br>  name: task-pv-pod<br>spec:<br>  containers:<br>    - name: task-pv-container<br>      image: nginx<br>      ports:<br>        - containerPort: 80<br>          name: “http-server”<br>      volumeMounts:<br>      - mountPath: “/usr/share/nginx/html”<br>        name: task-pv-storage<br>  volumes:<br>    - name: task-pv-storage<br>      persistentVolumeClaim:<br>        claimName: task-pv-claim</p><p>kubectl get pv<br>NAME             CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                   STORAGECLASS   REASON   AGE<br>task-pv-volume   10Gi       RWO            Retain           Bound    default/task-pv-claim   manual                  85m</p><p>kubectl get pvc<br>NAME            STATUS   VOLUME           CAPACITY   ACCESS MODES   STORAGECLASS   AGE<br>task-pv-claim   Bound    task-pv-volume   10Gi       RWO            manual         10m</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MTU是什么</title>
    <link href="/2020/05/23/MTU%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2020/05/23/MTU%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是MTU"><a href="#什么是MTU" class="headerlink" title="什么是MTU"></a>什么是MTU</h3><p>Maximum Transmission Unit，缩写MTU，中文名是：最大传输单元。</p><h3 id="这是哪一层网络的概念？"><a href="#这是哪一层网络的概念？" class="headerlink" title="这是哪一层网络的概念？"></a>这是哪一层网络的概念？</h3><p>从下面这个表格中可以看到，在7层网络协议中，MTU是数据链路层的概念。MTU限制的是数据链路层的payload，也就是上层协议的大小，例如IP，ICMP等。</p><h3 id="MTU有什么用？"><a href="#MTU有什么用？" class="headerlink" title="MTU有什么用？"></a>MTU有什么用？</h3><p>举一个最简单的场景，你在家用自己的笔记本上网，用的是路由器，路由器连接电信网络，然后访问了<a href="http://www.baidu.com，从你的笔记本出发的一个以太网数据帧总共经过了以下路径：">www.baidu.com，从你的笔记本出发的一个以太网数据帧总共经过了以下路径：</a></p><figure class="highlight clean"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs clean">笔记本 -&gt; 路由器 -&gt; 电信机房 -&gt; 服务器<br></code></pre></div></td></tr></table></figure><p>其中，每个节点都有一个MTU值，如下：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">1500</span>     <span class="hljs-number">1500</span>                 <span class="hljs-number">1500</span><br>笔记本 -&gt; 路由器 -&gt; 电信机房  -&gt; 服务器<br></code></pre></div></td></tr></table></figure><p>假设现在我把笔记本的MTU最大值设置成了1700，然后发送了一个超大的ip数据包（2000），这时候在以外网传输的时候会被拆成2个包，一个1700，一个300，然后加上头信息进行传输。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">1700</span>     <span class="hljs-number">1500</span>                <span class="hljs-number">1500</span><br>笔记本 -&gt; 路由器 -&gt; 电信机房 -&gt; 服务器<br></code></pre></div></td></tr></table></figure><p>路由器接收到了一个1700的帧，发现大于自己设置的最大值：1500，如果IP包DF标志位为1，也就是不允许分包，那么路由器直接就把这个包丢弃了，根本就不会到达电信机房，也就到不了服务器了，所以，到这里我们就会发现，MTU其实就是在每一个节点的管控值，只要是大于这个值的数据帧，要么选择分片，要么直接丢弃。</p><h3 id="MTU遇到calico"><a href="#MTU遇到calico" class="headerlink" title="MTU遇到calico"></a>MTU遇到calico</h3><p>这里分享一个前不久的k8s集群排障过程。<br>一天新搭建的集群各个节点看起来都是ok的但是只有同主机的pod才能访问的通,跨主机的通讯都有问题。当时的calico用的ipip模式，也就是每一台机器相当于一个路由器。互相通讯的时候通过主机的路由去寻路。<br><img src="https://i.loli.net/2020/05/24/PMKpLNv7Q6C1y9Z.png" srcset="/img/loading.gif" alt="DeepinScreenshot_select-area_20200524123309.png"></p><p><code>IPIP</code> 是linux内核的驱动程序，可以对数据包进行隧道，上图可以看到两个不同的网络 vlan1 和 vlan2。基于现有的以太网将原始包中的原始IP进行一次封装，通过tunl0解包，这个tunl0类似于ipip模块，和Flannel vxlan的veth很类似。</p><p>Pod1 访问 Pod2 流程如下：<br>1、数据包从 Pod1 出到达Veth Pair另一端（宿主机上，以cali前缀开头）。</p><p>2、进入IP隧道设备（tunl0），由Linux内核IPIP驱动封装，把源容器ip换成源宿主机ip，目的容器ip换成目的主机ip，这样就封装成 Node1 到 Node2 的数据包。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">此时包的类型：<br>  原始IP包：<br>  源IP：<span class="hljs-number">10.244</span><span class="hljs-number">.1</span><span class="hljs-number">.10</span><br>  目的IP：<span class="hljs-number">10.244</span><span class="hljs-number">.2</span><span class="hljs-number">.10</span><br><br>   TCP：<br>   源IP: <span class="hljs-number">192.168</span><span class="hljs-number">.31</span><span class="hljs-number">.62</span><br>   目的iP：<span class="hljs-number">192.168</span><span class="hljs-number">.32</span><span class="hljs-number">.63</span><br></code></pre></div></td></tr></table></figure><p>3、数据包经过路由器三层转发到 Node2。</p><p>4、Node2 收到数据包后，网络协议栈会使用IPIP驱动进行解包，从中拿到原始IP包。</p><p>5、然后根据路由规则，将数据包转发给cali设备，从而到达 Pod2。</p><p>经过排障发现,当时主机的MTU为1454,而docker的MTU为1500.<br><img src="https://i.loli.net/2020/05/24/PIbBLknaqUKYrJM.png" srcset="/img/loading.gif" alt="DeepinScreenshot_select-area_20200524123542.png"></p><p>找到问题以后处理就很简单了。要么改主机的MTU要么改calico的。由于这里是云主机 改主机MTU可能会引发其他问题。所以我改了calico的MTU。问题修复</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes 拉取私有镜像 imagepullsecrets</title>
    <link href="/2020/05/23/kubernetes-%E6%8B%89%E5%8F%96%E7%A7%81%E6%9C%89%E9%95%9C%E5%83%8F-imagepullsecrets/"/>
    <url>/2020/05/23/kubernetes-%E6%8B%89%E5%8F%96%E7%A7%81%E6%9C%89%E9%95%9C%E5%83%8F-imagepullsecrets/</url>
    
    <content type="html"><![CDATA[<h3 id="docker-使用私有仓库"><a href="#docker-使用私有仓库" class="headerlink" title="docker 使用私有仓库"></a>docker 使用私有仓库</h3><p>使用docker时,由于私有仓库很多时候没有搭建https的认证证书,访问时需要在本地docker的配置文件中加上允许对次镜像或者对所有镜像的http请求。</p><figure class="highlight elixir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elixir">root<span class="hljs-variable">@Core</span><span class="hljs-symbol">:~</span><span class="hljs-comment"># cat /etc/docker/dameon.json </span><br>&#123;<span class="hljs-string">"insecure-registries"</span>: [<span class="hljs-string">"0.0.0.0/0"</span>]&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://i.loli.net/2020/05/23/b1jExvs8kBHRgYd.png" srcset="/img/loading.gif" alt="DeepinScreenshot_select-area_20200523193555.png"></p><p>然后使用docker login 登录的时候会发现,登录成功以后会在本地生<code>~/.docker/config.json</code>的配置文件。<br><img src="https://i.loli.net/2020/05/23/FAWPjmx4Bh9tqvX.png" srcset="/img/loading.gif" alt="DeepinScreenshot_select-area_20200523193918.png"><br>该文件会存放登录过的用户的token以及登录仓库的地址</p><h3 id="k8s使用私有仓库"><a href="#k8s使用私有仓库" class="headerlink" title="k8s使用私有仓库"></a>k8s使用私有仓库</h3><p>虚假的使用方法</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">在k8s中,想要使用私有仓库而用以上方法是不现实的。如下<br><span class="hljs-number">1.</span>由于pod是漂移的,不知道下次pod会在哪个节点。<br><span class="hljs-number">2.</span>并且如果几个部门合作之类的，不止只有一个私有库,在k8s集群中将非常麻烦。<br></code></pre></div></td></tr></table></figure><hr><p>真实的使用方法</p><p>将刚刚生成的<code>config.json</code>变成configmap放置到k8s中</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl create<span class="hljs-built_in"> secret </span>generic harborsecret \<br>    <span class="hljs-attribute">--from-file</span>=.dockerconfigjson=/root/.docker/config.json \<br>    <span class="hljs-attribute">--type</span>=kubernetes.io/dockerconfigjson<br></code></pre></div></td></tr></table></figure><p>查看一下<br>kubectl get secrets harborsecret<br><img src="https://i.loli.net/2020/05/23/nV25oGzHJIQkmSa.png" srcset="/img/loading.gif" alt="DeepinScreenshot_select-area_20200523222238.png"></p><p>kubectl get secret harborsecret –output=yaml<br><img src="https://i.loli.net/2020/05/23/WBXF4wsAdVQDR1o.png" srcset="/img/loading.gif" alt="DeepinScreenshot_select-area_20200523222224.png"></p><p>在要部署的deployment中放入此镜像的configmap配置文件</p><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-attribute">apiVersion</span>: apps/v1<br><span class="hljs-attribute">kind</span>: Deployment<br><span class="hljs-attribute">metadata</span>:<br>  <span class="hljs-attribute">namespace</span>: istio-cosmo<br>  <span class="hljs-attribute">name</span>: cosmo-bff<br><span class="hljs-attribute">spec</span>:<br>  <span class="hljs-attribute">selector</span>:<br>    <span class="hljs-attribute">matchLabels</span>:<br>      <span class="hljs-attribute">app</span>: istio<br>  <span class="hljs-attribute">template</span>:<br>    <span class="hljs-attribute">metadata</span>:<br>      <span class="hljs-attribute">labels</span>:<br>        <span class="hljs-attribute">app</span>: nginx<br>    <span class="hljs-attribute">spec</span>:<br>      <span class="hljs-attribute">imagePullSecrets</span>:<br>      - <span class="hljs-attribute">name</span>: daocloud-registry<br>      <span class="hljs-attribute">containers</span>:<br>      - <span class="hljs-attribute">name</span>: nginx<br>        <span class="hljs-attribute">image</span>: registry.daocloud.cn/xxx/<span class="hljs-attribute">nginx</span>:<span class="hljs-number">264</span><br>        <span class="hljs-attribute">ports</span>:<br>        - <span class="hljs-attribute">containerPort</span>: <span class="hljs-number">8080</span><br>        <span class="hljs-attribute">volumeMounts</span>:<br>        - <span class="hljs-attribute">name</span>: cosmo-conf<br>          <span class="hljs-attribute">mountPath</span>: /work/config<br>      <span class="hljs-attribute">volumes</span>:<br>      - <span class="hljs-attribute">name</span>: cosmo-conf<br>        <span class="hljs-attribute">configMap</span>:<br>          <span class="hljs-attribute">name</span>: cosmo-conf<br></code></pre></div></td></tr></table></figure><p>这样不管是哪台机器执行下载该镜像的任务都会调用这个config文件。</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s部署mysql单节点到sotrageclass</title>
    <link href="/2020/05/23/k8s%E9%83%A8%E7%BD%B2mysql%E5%8D%95%E8%8A%82%E7%82%B9%E5%88%B0sotrageclass/"/>
    <url>/2020/05/23/k8s%E9%83%A8%E7%BD%B2mysql%E5%8D%95%E8%8A%82%E7%82%B9%E5%88%B0sotrageclass/</url>
    
    <content type="html"><![CDATA[<h2 id="mysql5-7-单节点部署"><a href="#mysql5-7-单节点部署" class="headerlink" title="mysql5.7 单节点部署"></a>mysql5.7 单节点部署</h2><blockquote><p>记录一下方便以后复制粘贴</p></blockquote><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell">未经过强调说明的话都是以<span class="hljs-keyword">default</span>租户下部署，有存储的话用的都是名为nfs-storage的storageclass.<br></code></pre></div></td></tr></table></figure><p><img src="https://i.loli.net/2020/05/23/SB1KbhiX8D4HZ6T.png" srcset="/img/loading.gif" alt="DeepinScreenshot_select-area_20200523161014.png"></p><p>首先创建mysql的configmap</p><figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-section">[root@master conf]</span><span class="hljs-comment"># cat mysqld.cnf </span><br><br><span class="hljs-section">[mysqld]</span><br><span class="hljs-attr">pid-file</span>= /var/run/mysqld/mysqld.pid<br><span class="hljs-attr">socket</span>= /var/run/mysqld/mysqld.sock<br><span class="hljs-attr">datadir</span>= /var/lib/mysql<br><span class="hljs-comment">#log-error= /var/log/mysql/error.log</span><br><span class="hljs-comment"># By default we only accept connections from localhost</span><br><span class="hljs-comment">#bind-address= 127.0.0.1</span><br><span class="hljs-comment"># Disabling symbolic-links is recommended to prevent assorted security risks</span><br><span class="hljs-attr">symbolic-links</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">sql_mode</span>=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION<br></code></pre></div></td></tr></table></figure><p>注意  因为mysql5.7默认关闭了<code>group by</code>相关命令 需要在配置文件中加上sql_mode打开。</p><figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua">kubectl <span class="hljs-built_in">create</span> configmap mysql-<span class="hljs-built_in">config</span>  <span class="hljs-comment">--from-file=mysql.cnf</span><br></code></pre></div></td></tr></table></figure><p><img src="https://i.loli.net/2020/05/23/KfmWpMvNdBbunkC.png" srcset="/img/loading.gif" alt="DeepinScreenshot_select-area_20200523161014.png"></p><p>查看创建的configmap,接下来创建使用storageclass的deloyment</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">mysqldata</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">accessModes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteMany</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-attr">requests:</span><br>      <span class="hljs-attr">storage:</span> <span class="hljs-string">20G</span><br>  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">nfs-storage</span><br><span class="hljs-meta">---</span><br><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">mysql57</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">mysql57</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">mysql57</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">mysql57</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">env:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">MYSQL_ROOT_PASSWORD</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">"2020520.pst"</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">MYSQL_USER</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">"daocloud"</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">MYSQL_PASSWORD</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">"daocloud@123456"</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">"mysql:5.7"</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">mysql57</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">3306</span><br>          <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mysqldata</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">"/var/lib/mysql"</span><br>          <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">false</span><br>          <span class="hljs-attr">subPath:</span> <span class="hljs-string">mysql57</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mysql-config</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/mysql/mysql.conf.d</span><br>      <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mysqldata</span><br>        <span class="hljs-attr">persistentVolumeClaim:</span><br>          <span class="hljs-attr">claimName:</span> <span class="hljs-string">mysqldata</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mysql-config</span><br>        <span class="hljs-attr">configMap:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">mysql-config</span><br></code></pre></div></td></tr></table></figure><p>查看创建的服务以及pvc<br><img src="https://i.loli.net/2020/05/23/u3LmVFZPGSylkDT.png" srcset="/img/loading.gif" alt="DeepinScreenshot_select-area_20200523161856.png"></p><p>当然如果外部用的话也可以用service或者ingress映射出来.</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">mysql57</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">mysql57</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mysql3306</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">3306</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">3306</span><br>      <span class="hljs-attr">nodePort:</span> <span class="hljs-number">30881</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span><br></code></pre></div></td></tr></table></figure><p><img src="https://i.loli.net/2020/05/23/GLTzpdcrSgn7iv3.png" srcset="/img/loading.gif" alt="DeepinScreenshot_select-area_20200523162141.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s, 中间件, mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>获取k8sadmin的token</title>
    <link href="/2020/05/21/%E8%8E%B7%E5%8F%96k8sadmin%E7%9A%84token/"/>
    <url>/2020/05/21/%E8%8E%B7%E5%8F%96k8sadmin%E7%9A%84token/</url>
    
    <content type="html"><![CDATA[<h3 id="创建token"><a href="#创建token" class="headerlink" title="创建token"></a>创建token</h3><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">vim</span> <span class="hljs-string">k8s-admin.yaml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">dashboard-admin</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1beta1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">dashboard-admin</span><br><span class="hljs-attr">subjects:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">dashboard-admin</span><br>    <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br><span class="hljs-attr">roleRef:</span><br>  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">cluster-admin</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br><br><span class="hljs-string">kubectl</span> <span class="hljs-string">apply</span> <span class="hljs-string">-f</span> <span class="hljs-string">k8s-admin.yaml</span><br></code></pre></div></td></tr></table></figure><h3 id="获取secretname"><a href="#获取secretname" class="headerlink" title="获取secretname"></a>获取secretname</h3><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">get</span><span class="hljs-built_in"> secret </span>-n kube-system<br>NAME                                            <span class="hljs-built_in"> TYPE </span>                                 DATA   AGE<br>dashboard-admin-token-dhhmc                      kubernetes.io/service-account-token   3      69s<br></code></pre></div></td></tr></table></figure><h3 id="查询token"><a href="#查询token" class="headerlink" title="查询token"></a>查询token</h3><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile">[root@k8s-master ~]<span class="hljs-comment">#  kubectl describe secret dashboard-admin-token-dhhmc   -n kube-system</span><br><span class="hljs-section">Name:         dashboard-admin-token-dhhmc</span><br><span class="hljs-section">Namespace:    kube-system</span><br><span class="hljs-section">Labels:       &lt;none&gt;</span><br><span class="hljs-section">Annotations:  kubernetes.io/service-account.name: dashboard-admin</span><br>              kubernetes.io/service-account.uid: 98d070eb-875c-11e9-a538-000c297b4fe7<br><br><span class="hljs-section">Type:  kubernetes.io/service-account-token</span><br><br>Data<br>====<br><span class="hljs-section">ca.crt:     1025 bytes</span><br><span class="hljs-section">namespace:  11 bytes</span><br><span class="hljs-section">token:      eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJkYXNoYm9hcmQtYWRtaW4tdG9rZW4tZGhobWMiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGFzaGJvYXJkLWFkbWluIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQudWlkIjoiOThkMDcwZWItODc1Yy0xMWU5LWE1MzgtMDAwYzI5N2I0ZmU3Iiwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50Omt1YmUtc3lzdGVtOmRhc2hib2FyZC1hZG1pbiJ9.XDFpez2E84R_zlopt_uEHPvVGUtSavypyix6UcYJO3J4imHdJy7MEkfV-wltBA1H8x0TT2AW64rLlXaRJ8OkFWJ0myedfKdjnf7i0oLQ8j-7lw6rT3A0e2pKmpnOaBQfgzRm83-t2I5MMp3Iu9VNUiAbqQpjql4AKwRuJEEGCs99tKStUxzIsJKusmUHh9KAK4BAxySn9h16T2URZ7czLP4mty2crYWNV4KwSwFPthGhFPsl8mnet_hiV5k4me5a8frmXytOy64MmGW8w3TBgiM-7hBYSxt84QGGnyi84LU0EFgtLwBWEOTZeUKKQ6IkoAprMmNcSxX8WUJFlx_uJg</span><br></code></pre></div></td></tr></table></figure><h3 id="token干啥用的"><a href="#token干啥用的" class="headerlink" title="token干啥用的"></a>token干啥用的</h3><p>不知道干啥用的你看这个干啥,浪费生命。</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>装逼编程键盘最佳实践</title>
    <link href="/2020/04/28/%E8%A3%85%E9%80%BC%E7%BC%96%E7%A8%8B%E9%94%AE%E7%9B%98%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <url>/2020/04/28/%E8%A3%85%E9%80%BC%E7%BC%96%E7%A8%8B%E9%94%AE%E7%9B%98%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<p>之前逛淘宝,发现一款贼鸡儿好看的键盘. 心动以后脑子一热就买了<br><img src="/img/newimg/007S8ZIlgy1ge980l3kedj30m80dw3z0.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/newimg/007S8ZIlgy1ge9815yk2aj30m80eqdg9.jpg" srcset="/img/loading.gif" alt=""></p><p>U1S1 确实好看。</p><h3 id="问题来了"><a href="#问题来了" class="headerlink" title="问题来了"></a>问题来了</h3><p>第一次使用这种可编程键盘 我发现完全不会用 因为首先按键不够的情况下 很多东西只能用组合键来触发 所以一旦设置的按键不合理。可能常用的一行代码 或者一句话 可能要非常麻烦才能打出来。<br>不仅不好打出来  按键还不好记住。使用成本贼高 </p><p>于是乎在家三个晚上设计出来了程序员的键盘方式。分享一下过程</p><hr><p>先上一下我的按键设计图<br><img src="/img/newimg/007S8ZIlgy1ge984q0qduj30zy0plgmq.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/newimg/007S8ZIlgy1ge984wguuhj30y80q93zn.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/newimg/007S8ZIlgy1ge9851hbs2j31430qy75h.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/newimg/007S8ZIlgy1ge9856tt29j310n0q9my9.jpg" srcset="/img/loading.gif" alt=""></p><p>如上图  我这次设置的键盘有四个层级(每个层级的按键都可以是不同的效果)</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">层级0:</span><br>    <span class="hljs-string">在层级0中</span> <span class="hljs-string">设置了常用的英文按键以及逗号跟点,这俩不管是写代码还是聊天都是最常用的。并且设置了三个触发层</span> <br>        <span class="hljs-number">1</span><span class="hljs-string">.左空格</span>  <span class="hljs-string">作为第一层的触发按键</span> <span class="hljs-string">(所以第一层所需要的所有按键都需要提前按左空格触发)</span><br>        <span class="hljs-number">2</span><span class="hljs-string">.右空格</span>  <span class="hljs-string">作为第二层的触发按键</span><br>        <span class="hljs-number">3.</span><span class="hljs-string">ENTER</span>  <span class="hljs-string">作为第三层的触发按键</span> <span class="hljs-string">(本来是一直吧ALT作为第三层的触发键,但是发现很多东西都跟设置的不一样</span> <span class="hljs-string">开始以为是我windows或者mac的问题</span>  <span class="hljs-string">设置了都不行</span>  <span class="hljs-string">后来猜想到可能是</span> <span class="hljs-string">ALT本身就是一个组合键的触发</span> <span class="hljs-string">比如</span> <span class="hljs-string">ALT</span> <span class="hljs-string">+</span> <span class="hljs-string">Q</span> <span class="hljs-string">这种</span> <span class="hljs-string">于是设置为ENTER</span> <span class="hljs-string">以后发现ok)</span><br><br><span class="hljs-string">层级1:</span><br>    <span class="hljs-string">在层级1中</span> <span class="hljs-string">设置0到9的数字,以及常用的标点符号。</span><br>    <span class="hljs-string">第三排是(+-*/)</span> <span class="hljs-string">应该比较好记</span><br><br><br><span class="hljs-string">层级2:</span><br>    <span class="hljs-string">在层级2中</span> <span class="hljs-string">设置的是F1-F12</span><br>    <span class="hljs-string">以及四个在编程中常用的括号</span> <span class="hljs-string">由优先级大小排序,实测发现很容易打出来</span> <span class="hljs-string">并且好记</span><br><br><span class="hljs-string">层级3:</span><br>    <span class="hljs-string">在层级3中</span> <span class="hljs-string">设置的是几个标点符号</span><br>        <span class="hljs-number">1</span><span class="hljs-string">.(:;=这三是放在一排</span> <span class="hljs-string">因为这三个在实际聊天需求较少</span> <span class="hljs-string">并且在写代码需求较高</span> <span class="hljs-string">放在这儿很好触发)</span><br>        <span class="hljs-number">2</span><span class="hljs-string">.(~"'`)这四个放在左上角需要一些肌肉记忆才能记住</span>  <span class="hljs-string">跟层级1的标点一样</span> <span class="hljs-string">需要长期使用记忆。</span><br>        <span class="hljs-number">3.</span><span class="hljs-string">_?</span> <span class="hljs-string">这俩是为了跟普通键盘一样的放置位置</span> <span class="hljs-string">基本不需要记忆</span> <span class="hljs-string">直接能触发</span><br>        <span class="hljs-number">4</span><span class="hljs-string">.｜/\</span> <span class="hljs-string">这三个</span> <span class="hljs-string">因为放到方向键</span> <span class="hljs-string">很容易就能记住他们的区别</span> <span class="hljs-string">方便记忆</span><br><br><br><span class="hljs-string">放置方式基本就是这样</span> <span class="hljs-string">以上的按键设置满足了目前的使用键盘的需求。</span><br></code></pre></div></td></tr></table></figure><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>首先在gtithub上下载本系统的键盘编程驱动以及程序(mac自带驱动)<br><a href="https://github.com/qmk/qmk_toolbox/releases" target="_blank" rel="noopener">github下载地址</a></p><p>使用方法介绍<br>链接: <a href="https://pan.baidu.com/s/1J9_QfP22LtYEnH6z0ZPdpw" target="_blank" rel="noopener">https://pan.baidu.com/s/1J9_QfP22LtYEnH6z0ZPdpw</a>  密码: o2n2 (使用方法pdf)</p><p>然后 拿着 基础键盘模版去<a href="KBfirmware.com">网站</a>上编辑你自己的键盘排列方式 </p><p>基础键盘模版   链接: <a href="https://pan.baidu.com/s/1QDBm07WbEuDAs69zoTmV5w" target="_blank" rel="noopener">https://pan.baidu.com/s/1QDBm07WbEuDAs69zoTmV5w</a>  密码: 874u</p><p>编辑完以后点击下载就能拿到刚刚编辑好的东西 在用键盘编程程序写入键盘</p><h3 id="写入过程"><a href="#写入过程" class="headerlink" title="写入过程"></a>写入过程</h3><p>打开编程软件,连接上键盘<br><img src="/img/newimg/007S8ZIlgy1ge98x7jp63j305z05e3yo.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/newimg/007S8ZIlgy1ge98zgrknaj30in0dtzmi.jpg" srcset="/img/loading.gif" alt=""><br>ok</p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>此类似键盘使用者需要内心强大,不然容易走火入魔,类似周伯通的左右手互博。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Istio是个啥</title>
    <link href="/2020/04/26/Istio%E6%98%AF%E4%B8%AA%E5%95%A5/"/>
    <url>/2020/04/26/Istio%E6%98%AF%E4%B8%AA%E5%95%A5/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派4的 ubuntu 18.04 LTS 源</title>
    <link href="/2020/04/23/%E6%A0%91%E8%8E%93%E6%B4%BE4%E7%9A%84-ubuntu-18-04-LTS-%E6%BA%90/"/>
    <url>/2020/04/23/%E6%A0%91%E8%8E%93%E6%B4%BE4%E7%9A%84-ubuntu-18-04-LTS-%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<p>#阿里云源<br>deb <a href="https://mirrors.aliyun.com/ubuntu-ports/" target="_blank" rel="noopener">https://mirrors.aliyun.com/ubuntu-ports/</a> bionic main restricted universe multiverse<br>deb-src <a href="https://mirrors.aliyun.com/ubuntu-ports/" target="_blank" rel="noopener">https://mirrors.aliyun.com/ubuntu-ports/</a> bionic main restricted universe multiverse<br>deb <a href="https://mirrors.aliyun.com/ubuntu-ports/" target="_blank" rel="noopener">https://mirrors.aliyun.com/ubuntu-ports/</a> bionic-security main restricted universe multiverse<br>deb-src <a href="https://mirrors.aliyun.com/ubuntu-ports/" target="_blank" rel="noopener">https://mirrors.aliyun.com/ubuntu-ports/</a> bionic-security main restricted universe multiverse<br>deb <a href="https://mirrors.aliyun.com/ubuntu-ports/" target="_blank" rel="noopener">https://mirrors.aliyun.com/ubuntu-ports/</a> bionic-updates main restricted universe multiverse<br>deb-src <a href="https://mirrors.aliyun.com/ubuntu-ports/" target="_blank" rel="noopener">https://mirrors.aliyun.com/ubuntu-ports/</a> bionic-updates main restricted universe multiverse<br>deb <a href="https://mirrors.aliyun.com/ubuntu-ports/" target="_blank" rel="noopener">https://mirrors.aliyun.com/ubuntu-ports/</a> bionic-backports main restricted universe multiverse<br>deb-src <a href="https://mirrors.aliyun.com/ubuntu-ports/" target="_blank" rel="noopener">https://mirrors.aliyun.com/ubuntu-ports/</a> bionic-backports main restricted universe multiverse<br>deb <a href="https://mirrors.aliyun.com/ubuntu-ports/" target="_blank" rel="noopener">https://mirrors.aliyun.com/ubuntu-ports/</a> bionic-proposed main restricted universe multiverse<br>deb-src <a href="https://mirrors.aliyun.com/ubuntu-ports/" target="_blank" rel="noopener">https://mirrors.aliyun.com/ubuntu-ports/</a> bionic-proposed main restricted universe multiverse</p><p>#中科大源<br>deb <a href="https://mirrors.ustc.edu.cn/ubuntu-ports/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/ubuntu-ports/</a> bionic main restricted universe multiverse<br>deb-src <a href="https://mirrors.ustc.edu.cn/ubuntu-ports/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/ubuntu-ports/</a> bionic main restricted universe multiverse<br>deb <a href="https://mirrors.ustc.edu.cn/ubuntu-ports/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/ubuntu-ports/</a> bionic-updates main restricted universe multiverse<br>deb-src <a href="https://mirrors.ustc.edu.cn/ubuntu-ports/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/ubuntu-ports/</a> bionic-updates main restricted universe multiverse<br>deb <a href="https://mirrors.ustc.edu.cn/ubuntu-ports/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/ubuntu-ports/</a> bionic-backports main restricted universe multiverse<br>deb-src <a href="https://mirrors.ustc.edu.cn/ubuntu-ports/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/ubuntu-ports/</a> bionic-backports main restricted universe multiverse<br>deb <a href="https://mirrors.ustc.edu.cn/ubuntu-ports/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/ubuntu-ports/</a> bionic-security main restricted universe multiverse<br>deb-src <a href="https://mirrors.ustc.edu.cn/ubuntu-ports/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/ubuntu-ports/</a> bionic-security main restricted universe multiverse<br>deb <a href="https://mirrors.ustc.edu.cn/ubuntu-ports/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/ubuntu-ports/</a> bionic-proposed main restricted universe multiverse<br>deb-src <a href="https://mirrors.ustc.edu.cn/ubuntu-ports/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/ubuntu-ports/</a> bionic-proposed main restricted universe multiverse</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>谈一谈值类型与引用类型和装箱与拆箱</title>
    <link href="/2020/03/31/%E8%B0%88%E4%B8%80%E8%B0%88%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1/"/>
    <url>/2020/03/31/%E8%B0%88%E4%B8%80%E8%B0%88%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1/</url>
    
    <content type="html"><![CDATA[<h2 id="值类型与引用类型"><a href="#值类型与引用类型" class="headerlink" title="值类型与引用类型"></a>值类型与引用类型</h2><p>首先说一说什么是值类型和引用类型</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">值类型直接存储其值。<br>引用类型存储对值的引用。<br></code></pre></div></td></tr></table></figure><p>粗俗点儿翻译的就是值类型就是现金，要用直接用；引用类型是存折，要用还得先去银行取现。</p><p>衍生出几个问题:</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">1.</span>为什么能直接直接用<br><span class="hljs-number">2.</span>引用类型怎么引用的<br><span class="hljs-number">3.</span>有啥区别<br></code></pre></div></td></tr></table></figure><h3 id="问题1-为什么值类型的能直接用"><a href="#问题1-为什么值类型的能直接用" class="headerlink" title="问题1 为什么值类型的能直接用"></a>问题1 为什么值类型的能直接用</h3><blockquote><p>基础扎实的同学知道。栈空间是某个进程启动的时候所内置的内存空间,我们经常听到的比如局部变量。这类型信息就存在栈当中,所以可以直接使用。但是栈的空间比较小。如果有其他需求我们只能放到堆内存当中。</p></blockquote><h3 id="问题2-引用类型怎么引用的"><a href="#问题2-引用类型怎么引用的" class="headerlink" title="问题2 引用类型怎么引用的"></a>问题2 引用类型怎么引用的</h3><p><img src="/img/newimg/00831rSTgy1gddc3pkcflj30mw0jy0uq.jpg" srcset="/img/loading.gif" alt=""></p><blockquote><p>如图,我们创建<code>Name</code>类就是在堆内存中,而我们如果需要使用。实例化以后。如下图所示<br><img src="/img/newimg/00831rSTgy1gddc8328sjj31480l2wfs.jpg" srcset="/img/loading.gif" alt=""><br>obj这个变量存储的东西只是Name对象的地址.(这个引用过程就是传说中的指针)</p></blockquote><h3 id="问题3-有啥区别"><a href="#问题3-有啥区别" class="headerlink" title="问题3 有啥区别"></a>问题3 有啥区别</h3><p><img src="/img/newimg/00831rSTgy1gddch6bnphj313i0oan0i.jpg" srcset="/img/loading.gif" alt=""></p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">值类型通常被人们称为轻量级的类型，因为在大多数情况下，值类型的的实例都分配在线程栈中，因此它不受垃圾回收的控制，缓解了托管堆中的压力，减少了应用程序的垃圾回收的次数，提高性能。<br><br>所有的引用类型的实例都分配在托管堆上，c#中new操作符会返回一个内存地址指向当前的对象。所以当你在创建个一个引用类型实例的时候，你必须要考虑以下问题：<br><br><span class="hljs-quote">&gt; 内存是在托管堆上分配的</span><br><span class="hljs-quote">&gt; 在分配每一个对象时都会包含一些额外的成员（类型对象指针，同步块索引），这些成员必须初始化</span><br><span class="hljs-quote">&gt; 对象中的其他字节总是设为零</span><br><span class="hljs-quote">&gt; 在分配对象时，可能会进行一次垃圾回收操作（如果托管堆上的内存不够分配一次对象时）</span><br></code></pre></div></td></tr></table></figure><hr><h2 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h2><p>简单解释</p><figure class="highlight dart"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dart">装箱 就是把“值类型”转换成“引用类型”(<span class="hljs-built_in">Object</span>)；<br><br>拆箱 就是把“引用类型”转换成“值类型”；<br></code></pre></div></td></tr></table></figure><p>举个例子</p><figure class="highlight cs"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cs"><span class="hljs-comment">//装箱 boxing</span><br><span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span> ;  <span class="hljs-comment">//分配在栈上</span><br><span class="hljs-keyword">object</span> o = i ;<span class="hljs-comment">//隐式装箱操作，int i 在堆上</span><br><span class="hljs-keyword">object</span> b = (<span class="hljs-keyword">object</span>)i ; <span class="hljs-comment">//显示装箱操作</span><br><span class="hljs-comment">//拆箱 unboxing</span><br><span class="hljs-keyword">int</span> j = (<span class="hljs-keyword">int</span>) o ;<span class="hljs-comment">//显示拆箱（将对象o拆箱为int类型）</span><br> <br><span class="hljs-keyword">int</span> k = b ;<span class="hljs-comment">//error!!, 不能隐式拆箱</span><br></code></pre></div></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">值类型和引用类型理解透彻后，我们知道C#里面是值传递，但是有些变量是引用类型的，在传递和拷贝时需要特别注意。方法传递参数时加上<span class="hljs-built_in">ref</span>(<span class="hljs-keyword">out</span>)，为引用传递参数。<br><br>值传递仅仅传递的是值，不影响原始值。<br><br>引用传递，传递的是内存地址，修改后会改变内存地址对应储存的值<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Thinkpad L440双系统记录</title>
    <link href="/2020/03/29/Thinkpad-L440%E5%8F%8C%E7%B3%BB%E7%BB%9F%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/03/29/Thinkpad-L440%E5%8F%8C%E7%B3%BB%E7%BB%9F%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>驱动过程没啥好说的,EFI我整理好了如下</p><figure class="highlight elixir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elixir">EFI如下<br>链接<span class="hljs-symbol">:https</span><span class="hljs-symbol">://pan</span>.baidu.com/s/<span class="hljs-number">1X1</span>r5warmKrzWX423YdSMMw  密码<span class="hljs-symbol">:kdnc</span><br>镜像地址如下<br>链接<span class="hljs-symbol">:https</span><span class="hljs-symbol">://pan</span>.baidu.com/s/<span class="hljs-number">170</span>PKgxP-emez_BibOIHyhg  密码<span class="hljs-symbol">:qrj3</span><br></code></pre></div></td></tr></table></figure><h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">中间有意思的说一下做个记录<br>我这个笔记本有两个盘，想的一个盘做好mac以后 用四叶草驱动作为windows的启动项引导。<br>然后呢 装黑苹果的时候 Bios得开启AHIC模式,开启到这个模式以后,windows怎么都启动不起来。<br>win7直接蓝屏然后<span class="hljs-number">0x0000</span>...忘记了 <br>win10报错以后可以进入那种引导修复的状态。<br>重点来了<br>在这种状态中 进入高级设置里面 然后点击类似重装系统这种修复。<br>重装完以后 就可以在AHIC模式下启动windows了 我也不晓得为啥 试出来的<br></code></pre></div></td></tr></table></figure><p>上双系统的图瞧瞧<br><img src="/img/newimg/00831rSTgy1gdb90jbqawj31400u0di5.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/newimg/00831rSTgy1gdb91goay0j31hb0tz7wi.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/newimg/00831rSTgy1gdb91q3qc3j31hc0u0hdt.jpg" srcset="/img/loading.gif" alt=""></p><blockquote><p>补充一句,电脑已经卖掉了….只是买来玩玩。倒手转卖赚了500.(我真他娘应该去做销售的.)</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>学习c#</title>
    <link href="/2020/03/15/%E5%AD%A6%E4%B9%A0c/"/>
    <url>/2020/03/15/%E5%AD%A6%E4%B9%A0c/</url>
    
    <content type="html"><![CDATA[<p>链接:<a href="https://pan.baidu.com/s/1iw-tbafU6hRa6E4mV9c4Yg" target="_blank" rel="noopener">https://pan.baidu.com/s/1iw-tbafU6hRa6E4mV9c4Yg</a>  密码:3oa9</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">偷偷学习一波C#,预测一下 <span class="hljs-number">3</span>年以后回来看.  .NET Core绝对是牛逼的产品。而C#也是牛逼的语言<br>这次的跨平台尝试,并且看微软的发力力度，一定能有东西产出。<br><br>但是不一定能影响很大，因为由于之前的微软积极闭源。导致现在的开源社区基本都是从反对微软而成立的,微软做开源阻力很大。<br><br><br>如果一旦形成开源的势力 那么前后端以及APP将一统江湖.(只是可视化的一统江湖,后端还是有其他力量 比如 专门为微服务生的go 处理数据以及AI的python,虽然C#除了操作系统。什么都能做)<br><br>PS:目前C#工资水平在同期的开发薪资是非常低的,中档大概低百分之<span class="hljs-number">35</span>不止。但是这次尝试我会坚持<span class="hljs-number">3</span>年。<span class="hljs-number">3</span>年以后看再回来看这波博客。补上到时候的市场<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于编程中字符串不可变的特性的理解</title>
    <link href="/2020/03/13/%E5%85%B3%E4%BA%8E%E7%BC%96%E7%A8%8B%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E7%89%B9%E6%80%A7%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2020/03/13/%E5%85%B3%E4%BA%8E%E7%BC%96%E7%A8%8B%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E7%89%B9%E6%80%A7%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>做游戏是不是挺有意思的</title>
    <link href="/2020/03/08/%E5%81%9A%E6%B8%B8%E6%88%8F%E6%98%AF%E4%B8%8D%E6%98%AF%E6%8C%BA%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84/"/>
    <url>/2020/03/08/%E5%81%9A%E6%B8%B8%E6%88%8F%E6%98%AF%E4%B8%8D%E6%98%AF%E6%8C%BA%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式存储系统Minio简介</title>
    <link href="/2020/02/26/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FMinio%E7%AE%80%E4%BB%8B/"/>
    <url>/2020/02/26/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FMinio%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>通过Heketi为K8S集群提供持久化存储</title>
    <link href="/2020/02/25/%E9%80%9A%E8%BF%87Heketi%E4%B8%BAK8S%E9%9B%86%E7%BE%A4%E6%8F%90%E4%BE%9B%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/"/>
    <url>/2020/02/25/%E9%80%9A%E8%BF%87Heketi%E4%B8%BAK8S%E9%9B%86%E7%BE%A4%E6%8F%90%E4%BE%9B%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用GoAccess分析nginx日志</title>
    <link href="/2020/02/24/%E4%BD%BF%E7%94%A8GoAccess%E5%88%86%E6%9E%90nginx%E6%97%A5%E5%BF%97/"/>
    <url>/2020/02/24/%E4%BD%BF%E7%94%A8GoAccess%E5%88%86%E6%9E%90nginx%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 Cobra 构建命令行工具</title>
    <link href="/2020/02/21/%E4%BD%BF%E7%94%A8-Cobra-%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
    <url>/2020/02/21/%E4%BD%BF%E7%94%A8-Cobra-%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<p>Cobra既是用于创建强大的现代CLI应用程序的库，也是用于生成应用程序和命令文件的程序。</p><p>有多强呢,我列举一下优秀的开源项目中用到Cobra的</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">Kubernetes<br>Hugo<br>rkt<br>etcd<br>Moby (<span class="hljs-name">former</span> Docker)<br>Docker (<span class="hljs-name">distribution</span>)<br>OpenShift<br>Delve<br>GopherJS<br>CockroachDB<br>Bleve<br>ProjectAtomic (<span class="hljs-name">enterprise</span>)<br>GiantSwarm's swarm<br>Nanobox/Nanopack<br>rclone<br>nehm<br>Pouch<br></code></pre></div></td></tr></table></figure><h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><p>Cobra 结构由三部分组成：命令 (commands)、参数 (arguments)、标志 (flags)。基本模型如下：<br><code>APPNAME VERB NOUN --ADJECTIVE</code> 或者 <code>APPNAME COMMAND ARG --FLAG</code><br>如果不是太理解的话，没关系，我们先看个例子：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">hugo<span class="hljs-built_in"> server </span><span class="hljs-attribute">--port</span>=1313<br></code></pre></div></td></tr></table></figure><p>hugo：根命令<br>server：子命令<br>–port：标志</p><p>再看个带有参数的例子：</p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">URL</span> --bare<br></code></pre></div></td></tr></table></figure><p>git：根命令<br>clone：子命令<br>URL：参数，即 clone 作用的对象<br>–bare：标志</p><p>总结如下：</p><blockquote><p>commands 代表行为，是应用的中心点<br>arguments 代表行为作用的对象<br>flags 是行为的修饰符</p></blockquote><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><p>cobra 的主要功能如下，可以说每一项都很实用：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">简易的子命令行模式，如 app server， app fetch 等等<br>完全兼容 posix 命令行模式<br>嵌套子命令 subcommand<br>支持全局，局部，串联 flags<br>使用 cobra 很容易的生成应用程序和命令，使用 cobra create appname 和 cobra <span class="hljs-builtin-name">add</span> cmdname<br>如果命令输入错误，将提供智能建议，如 app srver，将提示 srver 没有，是不是 app server<br>自动生成 commands 和 flags 的帮助信息<br>自动生成详细的 help 信息，如 app help<br>自动识别帮助 flag -h，--help<br>自动生成应用程序在 bash 下命令自动完成功能<br>自动生成应用程序的 man 手册<br>命令行别名<br>自定义 help 和 usage 信息<br>可选的与 viper apps 的紧密集成<br></code></pre></div></td></tr></table></figure><p>上面的描述稍微有点抽象，下面结合例子讲下cobra如何做的。</p><h3 id="Cobra的安装"><a href="#Cobra的安装" class="headerlink" title="Cobra的安装"></a>Cobra的安装</h3><p>首先，通过go get下载cobra</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> -v github.<span class="hljs-keyword">com</span>/spf13/cobra/cobra<br><span class="hljs-keyword">go</span> install<br>完成安装 (GOROOT/bin/记得加到环境变量)<br></code></pre></div></td></tr></table></figure><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p>在命令行下运行下cobra命令<br><img src="/img/newimg/0082zybpgy1gc4duaem93j319c0qa13s.jpg" srcset="/img/loading.gif" alt=""><br>如图的话 就是安装OK了。接下来就可以使用cobra了。<br>假设我们现在要开发一个基于CLI的命令程序，名字的。如下dsb(大傻逼)图操作：</p><figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada">➜  src cobra init dsb <span class="hljs-comment">--pkg-name=dsb</span><br>Your Cobra applicaton <span class="hljs-keyword">is</span> ready <span class="hljs-keyword">at</span><br>/Users/jame_xhs/go/src/dsb<br></code></pre></div></td></tr></table></figure><p>当前目录结构为</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">dsb</span><br>├── <span class="hljs-selector-tag">cmd</span><br>│   └── <span class="hljs-selector-tag">root</span><span class="hljs-selector-class">.go</span><br>├── <span class="hljs-selector-tag">LICENSE</span><br>└── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.go</span><br></code></pre></div></td></tr></table></figure><p>可以看到初始化后的项目非常简单，主要是 main.go 和 root.go 文件。在编写代码之前，我们先分析下目前代码的逻辑。</p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>先查看下入口文件 <code>main.go</code>。代码逻辑很简单，就是调用 cmd 包里 Execute()函数:</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">"demo/cmd"</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  cmd.Execute()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>再看下 <code>root.go</code> 中 rootCmd 的字段：</p><figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata">...<br><br><span class="hljs-keyword">var</span> rootCmd = &amp;cobra.Command&#123;<br>  <span class="hljs-keyword">Use</span>:   <span class="hljs-string">"demo"</span>,<br>  Short: <span class="hljs-string">"A brief description of your application"</span>,<br>  Long: `A longer description that spans multiple lines and likely contains<br>examples and usage of using your application. <span class="hljs-keyword">For</span> example:<br><br>Cobra is a <span class="hljs-keyword">CLI</span> library <span class="hljs-keyword">for</span> Go that empowers applications.<br>This application is a tool to <span class="hljs-keyword">generate</span> the needed files<br>to quickly create a Cobra application.`,<br>  <span class="hljs-comment">// Uncomment the following line if your bare application</span><br>  <span class="hljs-comment">// has an action associated with it:</span><br>  <span class="hljs-comment">//    Run: func(cmd *cobra.Command, args []string) &#123; &#125;,</span><br>&#125;<br><br><span class="hljs-comment">// Execute adds all child commands to the root command and sets flags appropriately.</span><br><span class="hljs-comment">// This is called by main.main(). It only needs to happen once to the rootCmd.</span><br>func Execute() &#123;<br>  <span class="hljs-keyword">if</span> <span class="hljs-keyword">err</span> := rootCmd.Execute(); <span class="hljs-keyword">err</span> != nil &#123;<br>    fmt.Println(<span class="hljs-keyword">err</span>)<br>    os.<span class="hljs-keyword">Exit</span>(1)<br>  &#125;<br>&#125;<br><br>...<br></code></pre></div></td></tr></table></figure><p>简单说明：<br>Use：命令名<br>Short &amp; Long：帮助信息的文字内容<br>Run：运行命令的逻辑</p><p>Command 结构体中的字段当然远不止这些，受限于篇幅，这里无法全部介绍。有兴趣的童鞋可以查阅下官方文档。</p><p>运行测试：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">[root@localhost demo]# go <span class="hljs-builtin-name">run</span> main.go<br>A longer description that spans multiple lines <span class="hljs-keyword">and</span> likely contains<br>examples <span class="hljs-keyword">and</span> usage of using your application. <span class="hljs-keyword">For</span> example:<br><br>Cobra is a CLI library <span class="hljs-keyword">for</span> Go that empowers applications.<br>This application is a<span class="hljs-built_in"> tool </span><span class="hljs-keyword">to</span> generate the needed files<br><span class="hljs-keyword">to</span> quickly create a Cobra application.<br><br>subcommand is required<br>exit status 1<br></code></pre></div></td></tr></table></figure><p>如果运行的结果和我的一致，那我们就可以进入到实践环节了。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="子命令"><a href="#子命令" class="headerlink" title="子命令"></a>子命令</h3><p>之前运行会提示 subcommand is required，是因为根命令无法直接运行。那我们就添加个子命令试试。<br>通过 cobra add 添加子命令 create:<br><img src="/img/newimg/0082zybpgy1gc4f8adl5mj30mo03et8p.jpg" srcset="/img/loading.gif" alt=""></p><p>当前项目结构为：<br>dsb<br>├── cmd<br>│   ├── create.go<br>│   └── root.go<br>├── LICENSE<br>└── main.go<br>查看下 create.go，init() 说明了命令的层级关系:</p><figure class="highlight autoit"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs autoit">...<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> &#123;</span><br>       rootCmd.AddCommand(createCmd)        <br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行测试：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">[root@localhost demo]<span class="hljs-comment"># go run main.go create</span><br><span class="hljs-keyword">create</span> called<br><br><span class="hljs-comment"># 未知命令</span><br>[root@localhost demo]<span class="hljs-comment"># go run main.go crea</span><br><span class="hljs-keyword">Error</span>: <span class="hljs-literal">unknown</span> command <span class="hljs-string">"crea"</span> <span class="hljs-keyword">for</span> <span class="hljs-string">"demo"</span><br><br>Did you mean this?<br><span class="hljs-keyword">create</span><br><br>Run <span class="hljs-string">'demo --help'</span> <span class="hljs-keyword">for</span> usage.<br><span class="hljs-literal">unknown</span> command <span class="hljs-string">"crea"</span> <span class="hljs-keyword">for</span> <span class="hljs-string">"demo"</span><br><br>Did you mean this?<br><span class="hljs-keyword">create</span><br></code></pre></div></td></tr></table></figure><p><img src="/img/newimg/0082zybpgy1gc4fdq8cxxj30j60ekq3d.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="子命令嵌套"><a href="#子命令嵌套" class="headerlink" title="子命令嵌套"></a>子命令嵌套</h3><p>对于功能相对复杂的 CLI，通常会通过多级子命令，即：子命令嵌套的方式进行描述，那么该如何实现呢？</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">dsb <span class="hljs-keyword">create</span> <span class="hljs-keyword">rule</span><br></code></pre></div></td></tr></table></figure><p>首先添加子命令 rule :</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">[root@localhost dsb]<span class="hljs-comment"># cobra add rule</span><br>rule created at <span class="hljs-regexp">/root/g</span>o<span class="hljs-regexp">/src/</span>dsb<br></code></pre></div></td></tr></table></figure><p>当前目录结构如下：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">dsb</span><br>├── <span class="hljs-selector-tag">cmd</span><br>│   ├── <span class="hljs-selector-tag">create</span><span class="hljs-selector-class">.go</span><br>│   ├── <span class="hljs-selector-tag">root</span><span class="hljs-selector-class">.go</span><br>│   └── <span class="hljs-selector-tag">rule</span><span class="hljs-selector-class">.go</span><br>├── <span class="hljs-selector-tag">LICENSE</span><br>└── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.go</span><br></code></pre></div></td></tr></table></figure><p>目前create 和 rule 是同级的，所以需要修改 rule.go 的 init() 来改变子命令间的层级关系</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">...<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 修改子命令的层级关系</span><br>        <span class="hljs-comment">//rootCmd.AddCommand(ruleCmd)</span><br>        createCmd.AddCommand(ruleCmd)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样 rule 就属于create的子命令了。<br>虽然调整了命令的层级关系，但是目前运行 demo create 会打印 create called，我希望运行时可以打印帮助提示。所以我们继续完善下代码，修改 create.go：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">...<br><br><span class="hljs-keyword">var</span> createCmd = &amp;cobra.Command&#123;<br>        Use:   <span class="hljs-string">"create"</span>,<br>        Short: <span class="hljs-string">"create"</span>,<br>        Long: <span class="hljs-string">"Create Command."</span>,<br>        Run: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cmd *cobra.Command, args []<span class="hljs-keyword">string</span>)</span></span> &#123;<br>                <span class="hljs-comment">// 如果 create 命令后没有参数，则提示帮助信息</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) == <span class="hljs-number">0</span> &#123;<br>                  cmd.Help()<br>                  <span class="hljs-keyword">return</span><br>                &#125;<br>        &#125;,<br>&#125;<br><br>...<br></code></pre></div></td></tr></table></figure><p>运行测试：</p><p>直接运行 create，打印帮助提示：<br><img src="/img/newimg/0082zybpgy1gc4fi34sm4j310e0koq4y.jpg" srcset="/img/loading.gif" alt=""></p><p>运行 <code>create rule</code>，输出 <code>rule called</code>：</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">[root@localhost dsb]# go run main.go <span class="hljs-keyword">create</span> <span class="hljs-keyword">rule</span><br><span class="hljs-keyword">rule</span> <span class="hljs-keyword">called</span><br></code></pre></div></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>先说说参数。现在有个需求：给 CLI 加个位置参数，要求参数有且仅有一个。这个需求我们要如何实现呢？</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">dsb <span class="hljs-keyword">create</span> <span class="hljs-keyword">rule</span> foo<br></code></pre></div></td></tr></table></figure><p>实现前先说下，Command 结构体中有个 Args 的字段，接受类型为 <code>type PositionalArgs func(cmd *Command, args []string) error</code></p><p>内置的验证方法如下：</p><blockquote><p>NoArgs：如果有任何参数，命令行将会报错<br>ArbitraryArgs： 命令行将会接收任何参数<br>OnlyValidArgs： 如果有如何参数不属于 Command 的 ValidArgs 字段，命令行将会报错<br>MinimumNArgs(int)： 如果参数个数少于 N 个，命令行将会报错<br>MaximumNArgs(int)： 如果参数个数多于 N 个，命令行将会报错<br>ExactArgs(int)： 如果参数个数不等于 N 个，命令行将会报错<br>RangeArgs(min, max)： 如果参数个数不在 min 和 max 之间, 命令行将会报错</p></blockquote><p>由于需求里要求参数有且仅有一个，想想应该用哪个内置验证方法呢？ ExactArgs(int)。<br>改写下 <code>rule.go</code>：</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts">...<br><br>var ruleCmd = <span class="hljs-variable">&amp;cobra</span>.Command&#123;<br><span class="hljs-symbol">        Use:</span>   <span class="hljs-string">"rule"</span>,<br><span class="hljs-symbol">        Short:</span> <span class="hljs-string">"rule"</span>,<br><span class="hljs-symbol">        Long:</span> <span class="hljs-string">"Rule Command."</span>,<br>        <br><span class="hljs-symbol">        Args:</span> cobra.ExactArgs(<span class="hljs-number">1</span>),<br><span class="hljs-symbol">        Run:</span> func(cmd *cobra.Command, args []string) &#123;           <br>          fmt.Printf(<span class="hljs-string">"Create rule %s success.\n"</span>, args[<span class="hljs-number">0</span>])<br>        &#125;,<br>&#125;<br><br>...<br></code></pre></div></td></tr></table></figure><p>运行测试：</p><p>不输入参数：</p><figure class="highlight subunit"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs subunit">[root@localhost dsb]# go run main.go create rule<br><span class="hljs-keyword">Error: </span>accepts 1 arg(s), received 0<br></code></pre></div></td></tr></table></figure><p>输入 1 个参数：</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">[root@localhost dsb]# go run main.go <span class="hljs-keyword">create</span> <span class="hljs-keyword">rule</span> foo<br><span class="hljs-keyword">Create</span> <span class="hljs-keyword">rule</span> foo success.<br></code></pre></div></td></tr></table></figure><p>输入 2 个参数：</p><figure class="highlight subunit"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs subunit">[root@localhost dsb]# go run main.go create rule<br><span class="hljs-keyword">Error: </span>accepts 1 arg(s), received 2<br></code></pre></div></td></tr></table></figure><p>从测试的情况看，运行的结果符合我们的预期。如果需要对参数进行复杂的验证，还可以自定义 Args，这里就不多做赘述了。</p><h3 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h3><p>再说说标志。现在要求 CLI 不接受参数，而是通过标志 –name 对 rule 进行描述。这个又该如何实现？</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">demo <span class="hljs-keyword">create</span> <span class="hljs-keyword">rule</span> <span class="hljs-comment">--name foo</span><br></code></pre></div></td></tr></table></figure><p>Cobra 中有两种标志：持久标志 ( Persistent Flags ) 和 本地标志 ( Local Flags ) 。</p><blockquote><p>持久标志：指所有的 commands 都可以使用该标志。比如：–verbose ，–namespace<br>本地标志：指特定的 commands 才可以使用该标志。</p></blockquote><p>这个标志的作用是修饰和描述 rule的名字，所以选用本地标志。修改 rule.go：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> cmd<br><br><span class="hljs-keyword">import</span> (<br>        <span class="hljs-string">"fmt"</span>        <br>        <span class="hljs-string">"github.com/spf13/cobra"</span><br>)       <br><br><span class="hljs-comment">// 添加变量 name</span><br><span class="hljs-keyword">var</span> name <span class="hljs-keyword">string</span><br><br><span class="hljs-keyword">var</span> ruleCmd = &amp;cobra.Command&#123;<br>        Use:   <span class="hljs-string">"rule"</span>,<br>        Short: <span class="hljs-string">"rule"</span>,<br>        Long: <span class="hljs-string">"Rule Command."</span>,<br>        Run: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cmd *cobra.Command, args []<span class="hljs-keyword">string</span>)</span></span> &#123;<br>          <span class="hljs-comment">// 如果没有输入 name</span><br>          <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(name) == <span class="hljs-number">0</span> &#123;<br>            cmd.Help()<br>            <span class="hljs-keyword">return</span><br>          &#125;     <br>          fmt.Printf(<span class="hljs-string">"Create rule %s success.\n"</span>, name)<br>        &#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>        createCmd.AddCommand(ruleCmd)<br>        <span class="hljs-comment">// 添加本地标志</span><br>        ruleCmd.Flags().StringVarP(&amp;name, <span class="hljs-string">"name"</span>, <span class="hljs-string">"n"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">"rule name"</span>)<br></code></pre></div></td></tr></table></figure><p>说明：<code>StringVarP</code> 用来接收类型为字符串变量的标志。相较<code>StringVar</code>， <code>StringVarP</code> 支持标志短写。以我们的 CLI 为例：在指定标志时可以用 <code>--name</code>，也可以使用短写 <code>-n</code>。</p><p>运行测试：</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"># 这几种写法都可以执行<br>[root@localhost dsb]# go run main.go <span class="hljs-keyword">create</span> <span class="hljs-keyword">rule</span> -n foo<br><span class="hljs-keyword">Create</span> <span class="hljs-keyword">rule</span> foo success.<br>[root@localhost dsb]# go run main.go <span class="hljs-keyword">create</span> <span class="hljs-keyword">rule</span> <span class="hljs-comment">--name foo</span><br><span class="hljs-keyword">Create</span> <span class="hljs-keyword">rule</span> foo success.<br>[root@localhost dsb]# go run main.go <span class="hljs-keyword">create</span> -n foo <span class="hljs-keyword">rule</span><br><span class="hljs-keyword">Create</span> <span class="hljs-keyword">rule</span> foo success.<br></code></pre></div></td></tr></table></figure><h3 id="读取配置"><a href="#读取配置" class="headerlink" title="读取配置"></a>读取配置</h3><p>需求：要求 –name 标志存在默认值，且该值是可配置的。<br>如果只需要标志提供默认值，我们只需要修改 StringVarP 的 value 参数就可以实现。但是这个需求关键在于标志是可配置的，所以需要借助配置文件。</p><p>很多情况下，CLI 是需要读取配置信息的，比如 kubectl 的~/.kube/config。在帮助提示里可以看到默认的配置文件为 $HOME/.demo.yaml：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">Global Flags:<br>      --config string  <span class="hljs-built_in"> config </span>file (default is <span class="hljs-variable">$HOME</span>/.demo.yaml)<br></code></pre></div></td></tr></table></figure><p>​配置库我们可以使用 Viper。Viper 是 Cobra 集成的配置文件读取库，支持 <code>YAML</code>，<code>JSON</code>， <code>TOML</code>， <code>HCL</code> 等格式的配置。</p><p>添加配置文件 $HOME/.demo.yaml，增加 name 字段：</p><figure class="highlight applescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs applescript">[root@localhost ~]<span class="hljs-comment"># vim $HOME/.demo.yaml </span><br><span class="hljs-built_in">name</span>: xiangli<br></code></pre></div></td></tr></table></figure><p>修改 <code>rule.go</code>:</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> cmd<br><br><span class="hljs-keyword">import</span> (<br>        <span class="hljs-string">"fmt"</span><br>         <span class="hljs-comment">// 导入 viper 包</span><br>        <span class="hljs-string">"github.com/spf13/viper"</span><br>        <span class="hljs-string">"github.com/spf13/cobra"</span><br>)<br><br><span class="hljs-keyword">var</span> name <span class="hljs-keyword">string</span><br><br><span class="hljs-keyword">var</span> ruleCmd = &amp;cobra.Command&#123;<br>        Use:   <span class="hljs-string">"rule"</span>,<br>        Short: <span class="hljs-string">"rule"</span>,<br>        Long: <span class="hljs-string">"Rule Command."</span>,<br>        Run: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cmd *cobra.Command, args []<span class="hljs-keyword">string</span>)</span></span> &#123;<br>          <span class="hljs-comment">// 不输入 --name 从配置文件中读取 name</span><br>          <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(name) == <span class="hljs-number">0</span> &#123;<br>            name = viper.GetString(<span class="hljs-string">"name"</span>)<br>            <span class="hljs-comment">// 配置文件中未读取到 name，打印帮助提示</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(name) == <span class="hljs-number">0</span> &#123;<br>              cmd.Help()<br>              <span class="hljs-keyword">return</span><br>            &#125;<br>          &#125;<br>          fmt.Printf(<span class="hljs-string">"Create rule %s success.\n"</span>, name)<br>        &#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>        createCmd.AddCommand(ruleCmd)<br>        ruleCmd.Flags().StringVarP(&amp;name, <span class="hljs-string">"name"</span>, <span class="hljs-string">"n"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">"rule name"</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行测试：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">[root@localhost dsb]# go <span class="hljs-builtin-name">run</span> main.go create rule<br>Using<span class="hljs-built_in"> config </span>file: /root/.demo.yaml<br>Create rule xiangli success.<br></code></pre></div></td></tr></table></figure><p>如果 CLI 没有用到配置文件，可以在初始化项目的时候关闭 Viper 的选项以减少编译后文件的体积，如下：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">cobra init demo <span class="hljs-attribute">--pkg-name</span>=demo <span class="hljs-attribute">--viper</span>=<span class="hljs-literal">false</span><br></code></pre></div></td></tr></table></figure><h3 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h3><p>​编译生成命令行工具</p><figure class="highlight autoit"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@localhost</span> dsb]<span class="hljs-meta"># go build -o dsb</span><br></code></pre></div></td></tr></table></figure><p>运行测试：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">[root@localhost dsb]# ./dsb create rule<br>Using<span class="hljs-built_in"> config </span>file: /root/.demo.yaml<br>Create rule xiangli success.<br></code></pre></div></td></tr></table></figure><p>学起来啊,同学们。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>tcp/ip之TCP Fast open</title>
    <link href="/2020/02/20/tcp-ip%E4%B9%8BTCP-Fast-open/"/>
    <url>/2020/02/20/tcp-ip%E4%B9%8BTCP-Fast-open/</url>
    
    <content type="html"><![CDATA[<h3 id="产生背景"><a href="#产生背景" class="headerlink" title="产生背景"></a>产生背景</h3><p>Google研究发现TCP三次握手是页面延迟时间的重要组成部分，所以他们提出了TFO(TCP Fast Open)：在TCP握手期间交换数据，这样可以减少一次RTT。根据测试数据，TFO可以减少15%的HTTP传输延迟，全页面的下载时间平均节省10%，最高可达40%。</p><p>(RTT指的是往返时延。在计算机网络中它是一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。)</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>TFO允许在TCP握手期间发送和接收初始SYN分组中的数据。如果客户端和服务器都支持TFO功能，则可以减少建立到同一服务器的多个TCP连接的延迟。这是通过在初始TCP握手之后在客户端上存储TFO cookie来实现的。如果客户端稍后重新连接，则此TFO cookie将发送到服务器，从而允许连续的TCP握手跳过一个往返延迟，从而减少延迟。</p><h3 id="拓扑图"><a href="#拓扑图" class="headerlink" title="拓扑图"></a>拓扑图</h3><p>普通的TCP连接过程如下图所示<br><img src="/img/newimg/0082zybpgy1gc2s4f800fj30go08zwem.jpg" srcset="/img/loading.gif" alt=""></p><p>而TFO的连接过程如下<br><img src="/img/newimg/0082zybpgy1gc2s5lu0yij30go099dg0.jpg" srcset="/img/loading.gif" alt=""><br>当客户端断开一段时间后，再次连接过程如下<br><img src="/img/newimg/0082zybpgy1gc2s5whhzuj30go0ac3yr.jpg" srcset="/img/loading.gif" alt=""><br>可以看出使用TFO后，非第一次连接变成了两次握手即可</p><p>总揽<br><img src="/img/newimg/0082zybpgy1gc2pyjnhaoj30ry0nedis.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="TFO的开启"><a href="#TFO的开启" class="headerlink" title="TFO的开启"></a>TFO的开启</h3><p>TFO功能在Linux 3.7 内核中开始集成，因此RHEL7/CentOS7是支持的，但默认没有开启，使用以下方式开启：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">echo <span class="hljs-number">3</span> &gt; /proc/sys/net/ipv4/tcp_fastopen<br>#<span class="hljs-number">3</span>的意思是开启TFO客户端和服务器端<br>#<span class="hljs-number">1</span>表示开启客户端，<span class="hljs-number">2</span>表示开启服务器端<br></code></pre></div></td></tr></table></figure><p>除了内核的支持，应用程序也要开启支持，例如nginx（1.5.8+）开启方法如下：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">server &#123;<br>        listen 80 <span class="hljs-attribute">backlog</span>=4096 <span class="hljs-attribute">fastopen</span>=256 default;<br>        server_name _;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络抓包神器 Tcpdump 使用指南</title>
    <link href="/2020/02/17/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E7%A5%9E%E5%99%A8-Tcpdump-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2020/02/17/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E7%A5%9E%E5%99%A8-Tcpdump-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要内容摘抄自<a href="https://mp.weixin.qq.com/s/J3Rdrof9ts9b6_paJk1KJw" target="_blank" rel="noopener">开米朗基杨</a></p></blockquote><p><code>tcpdump</code> 是一款强大的网络抓包工具，它使用 <code>libpcap</code> 库来抓取网络数据包，这个库在几乎在所有的 Linux/Unix 中都有。熟悉 <code>tcpdump</code> 的使用能够帮助你分析调试网络数据，本文将通过一个个具体的示例来介绍它在不同场景下的使用方法。不管你是系统管理员，程序员，云原生工程师还是 yaml 工程师，掌握 tcpdump 的使用都能让你如虎添翼，升职加薪。</p><h2 id="基本语法和使用方法"><a href="#基本语法和使用方法" class="headerlink" title="基本语法和使用方法"></a>基本语法和使用方法</h2><p><code>tcpdump</code> 的常用参数如下：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">$ tcpdump -i eth0 -nn -s0 -v<span class="hljs-built_in"> port </span>80<br></code></pre></div></td></tr></table></figure><blockquote><p>-i : 选择要捕获的接口，通常是以太网卡或无线网卡，也可以是 vlan 或其他特殊接口。如果该系统上只有一个网络接口，则无需指定。<br>-nn : 单个 n 表示不解析域名，直接显示 IP；两个 n 表示不解析域名和端口。这样不仅方便查看 IP 和端口号，而且在抓取大量数据时非常高效，因为域名解析会降低抓取速度。<br>-s0 : tcpdump 默认只会截取前 96 字节的内容，要想截取所有的报文内容，可以使用 -s number， number 就是你要截取的报文字节数，如果是 0 的话，表示截取报文全部内容。<br>-v : 使用 -v，-vv 和 -vvv 来显示更多的详细信息，通常会显示更多与特定协议相关的信息。<br>port 80 : 这是一个常见的端口过滤器，表示仅抓取 80 端口上的流量，通常是 HTTP。</p></blockquote><p>额外再介绍几个常用参数：</p><blockquote><p>-p : 不让网络接口进入混杂模式。默认情况下使用 tcpdump 抓包时，会让网络接口进入混杂模式。一般计算机网卡都工作在非混杂模式下，此时网卡只接受来自网络端口的目的地址指向自己的数据。当网卡工作在混杂模式下时，网卡将来自接口的所有数据都捕获并交给相应的驱动程序。如果设备接入的交换机开启了混杂模式，使用 -p 选项可以有效地过滤噪声。<br>-e : 显示数据链路层信息。默认情况下 tcpdump 不会显示数据链路层信息，使用 -e 选项可以显示源和目的 MAC 地址，以及 VLAN tag 信息。例如：</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">$ tcpdump -n -e -c <span class="hljs-number">5</span> <span class="hljs-keyword">not</span> ip6<br><br>tcpdump: verbose output suppressed, use -v <span class="hljs-keyword">or</span> -vv <span class="hljs-keyword">for</span> full protocol decode<br>listening on br-lan, link-type EN10MB (Ethernet), capture size <span class="hljs-number">262144</span> bytes<br><span class="hljs-number">18</span>:<span class="hljs-number">27</span>:<span class="hljs-number">53.619865</span> <span class="hljs-number">24</span>:<span class="hljs-number">5</span>e:be:<span class="hljs-number">0</span>c:<span class="hljs-number">17</span>:af &gt; <span class="hljs-number">00</span>:e2:<span class="hljs-number">69</span>:<span class="hljs-number">23</span>:d3:<span class="hljs-number">3</span>b, ethertype IPv4 (<span class="hljs-number">0x0800</span>), length <span class="hljs-number">1162</span>: <span class="hljs-number">192.168</span><span class="hljs-number">.100</span><span class="hljs-number">.20</span><span class="hljs-number">.51410</span> &gt; <span class="hljs-number">180.176</span><span class="hljs-number">.26</span><span class="hljs-number">.193</span><span class="hljs-number">.58695</span>: Flags [.], seq <span class="hljs-number">2045333376</span>:<span class="hljs-number">2045334484</span>, ack <span class="hljs-number">3398690514</span>, win <span class="hljs-number">751</span>, length <span class="hljs-number">1108</span><br><span class="hljs-number">18</span>:<span class="hljs-number">27</span>:<span class="hljs-number">53.626490</span> <span class="hljs-number">00</span>:e2:<span class="hljs-number">69</span>:<span class="hljs-number">23</span>:d3:<span class="hljs-number">3</span>b &gt; <span class="hljs-number">24</span>:<span class="hljs-number">5</span>e:be:<span class="hljs-number">0</span>c:<span class="hljs-number">17</span>:af, ethertype IPv4 (<span class="hljs-number">0x0800</span>), length <span class="hljs-number">68</span>: <span class="hljs-number">220.173</span><span class="hljs-number">.179</span><span class="hljs-number">.66</span><span class="hljs-number">.36017</span> &gt; <span class="hljs-number">192.168</span><span class="hljs-number">.100</span><span class="hljs-number">.20</span><span class="hljs-number">.51410</span>: UDP, length <span class="hljs-number">26</span><br><span class="hljs-number">18</span>:<span class="hljs-number">27</span>:<span class="hljs-number">53.626893</span> <span class="hljs-number">24</span>:<span class="hljs-number">5</span>e:be:<span class="hljs-number">0</span>c:<span class="hljs-number">17</span>:af &gt; <span class="hljs-number">00</span>:e2:<span class="hljs-number">69</span>:<span class="hljs-number">23</span>:d3:<span class="hljs-number">3</span>b, ethertype IPv4 (<span class="hljs-number">0x0800</span>), length <span class="hljs-number">1444</span>: <span class="hljs-number">192.168</span><span class="hljs-number">.100</span><span class="hljs-number">.20</span><span class="hljs-number">.51410</span> &gt; <span class="hljs-number">220.173</span><span class="hljs-number">.179</span><span class="hljs-number">.66</span><span class="hljs-number">.36017</span>: UDP, length <span class="hljs-number">1402</span><br><span class="hljs-number">18</span>:<span class="hljs-number">27</span>:<span class="hljs-number">53.628837</span> <span class="hljs-number">00</span>:e2:<span class="hljs-number">69</span>:<span class="hljs-number">23</span>:d3:<span class="hljs-number">3</span>b &gt; <span class="hljs-number">24</span>:<span class="hljs-number">5</span>e:be:<span class="hljs-number">0</span>c:<span class="hljs-number">17</span>:af, ethertype IPv4 (<span class="hljs-number">0x0800</span>), length <span class="hljs-number">1324</span>: <span class="hljs-number">46.97</span><span class="hljs-number">.169</span><span class="hljs-number">.182</span><span class="hljs-number">.6881</span> &gt; <span class="hljs-number">192.168</span><span class="hljs-number">.100</span><span class="hljs-number">.20</span><span class="hljs-number">.59145</span>: Flags [P.], seq <span class="hljs-number">3058450381</span>:<span class="hljs-number">3058451651</span>, ack <span class="hljs-number">14349180</span>, win <span class="hljs-number">502</span>, length <span class="hljs-number">1270</span><br><span class="hljs-number">18</span>:<span class="hljs-number">27</span>:<span class="hljs-number">53.629096</span> <span class="hljs-number">24</span>:<span class="hljs-number">5</span>e:be:<span class="hljs-number">0</span>c:<span class="hljs-number">17</span>:af &gt; <span class="hljs-number">00</span>:e2:<span class="hljs-number">69</span>:<span class="hljs-number">23</span>:d3:<span class="hljs-number">3</span>b, ethertype IPv4 (<span class="hljs-number">0x0800</span>), length <span class="hljs-number">54</span>: <span class="hljs-number">192.168</span><span class="hljs-number">.100</span><span class="hljs-number">.20</span><span class="hljs-number">.59145</span> &gt; <span class="hljs-number">192.168</span><span class="hljs-number">.100</span><span class="hljs-number">.1</span><span class="hljs-number">.12345</span>: Flags [.], ack <span class="hljs-number">3058451651</span>, win <span class="hljs-number">6350</span>, length <span class="hljs-number">0</span><br><span class="hljs-number">5</span> packets captured<br></code></pre></div></td></tr></table></figure><h3 id="显示-ASCII-字符串"><a href="#显示-ASCII-字符串" class="headerlink" title="显示 ASCII 字符串"></a>显示 ASCII 字符串</h3><p><code>-A</code> 表示使用 <code>ASCII</code> 字符串打印报文的全部数据，这样可以使读取更加简单，方便使用 <code>grep</code> 等工具解析输出内容。<code>-X</code> 表示同时使用十六进制和 <code>ASCII</code> 字符串打印报文的全部数据。这两个参数不能一起使用。例如：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">$ tcpdump -A -s0<span class="hljs-built_in"> port </span>80<br></code></pre></div></td></tr></table></figure><h3 id="抓取特定协议的数据"><a href="#抓取特定协议的数据" class="headerlink" title="抓取特定协议的数据"></a>抓取特定协议的数据</h3><p>后面可以跟上协议名称来过滤特定协议的流量，以 UDP 为例，可以加上参数 udp 或 <code>protocol 17</code>，这两个命令意思相同。</p><figure class="highlight elixir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>tcpdump -i eth0 udp<br><span class="hljs-variable">$ </span>tcpdump -i eth0 proto <span class="hljs-number">17</span><br></code></pre></div></td></tr></table></figure><p>同理，tcp 与 <code>protocol 6</code> 意思相同。</p><h3 id="抓取特定主机的数据"><a href="#抓取特定主机的数据" class="headerlink" title="抓取特定主机的数据"></a>抓取特定主机的数据</h3><p>使用过滤器 <code>host</code> 可以抓取特定目的地和源 IP 地址的流量。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">$ tcpdump -i eth0 host <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span><br></code></pre></div></td></tr></table></figure><p>也可以使用 src 或 dst 只抓取源或目的地：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">$ tcpdump -i eth0 dst <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span><br></code></pre></div></td></tr></table></figure><h3 id="将抓取的数据写入文件"><a href="#将抓取的数据写入文件" class="headerlink" title="将抓取的数据写入文件"></a>将抓取的数据写入文件</h3><p>使用 tcpdump 截取数据报文的时候，默认会打印到屏幕的默认输出，你会看到按照顺序和格式，很多的数据一行行快速闪过，根本来不及看清楚所有的内容。不过，tcpdump 提供了把截取的数据保存到文件的功能，以便后面使用其他图形工具（比如 wireshark，Snort）来分析。</p><p><code>-w</code> 选项用来把数据报文输出到文件：</p><figure class="highlight armasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs armasm">$ tcpdump -i eth0 -<span class="hljs-built_in">s0</span> -w test.pcap<br></code></pre></div></td></tr></table></figure><h3 id="行缓冲模式"><a href="#行缓冲模式" class="headerlink" title="行缓冲模式"></a>行缓冲模式</h3><p>如果想实时将抓取到的数据通过管道传递给其他工具来处理，需要使用 <code>-l</code> 选项来开启行缓冲模式（或使用 <code>-c</code> 选项来开启数据包缓冲模式）。使用 <code>-l</code> 选项可以将输出通过立即发送给其他命令，其他命令会立即响应。</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">$ tcpdump -i eth0 -s0 -l<span class="hljs-built_in"> port </span>80 | grep <span class="hljs-string">'Server:'</span><br></code></pre></div></td></tr></table></figure><h3 id="组合过滤器"><a href="#组合过滤器" class="headerlink" title="组合过滤器"></a>组合过滤器</h3><p>过滤的真正强大之处在于你可以随意组合它们，而连接它们的逻辑就是常用的 <code>与/AND/&amp;&amp;</code>、 <code>或/OR/||</code> 和 <code>非/not/!</code>。</p><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">and </span><span class="hljs-keyword">or </span>&amp;&amp;<br><span class="hljs-keyword">or </span><span class="hljs-keyword">or </span><span class="hljs-title">||</span><br>not <span class="hljs-keyword">or </span>!<br></code></pre></div></td></tr></table></figure><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>关于 tcpdump 的过滤器，这里有必要单独介绍一下。</p><p>机器上的网络报文数量异常的多，很多时候我们只关系和具体问题有关的数据报（比如访问某个网站的数据，或者 icmp 超时的报文等等），而这些数据只占到很小的一部分。把所有的数据截取下来，从里面找到想要的信息无疑是一件很费时费力的工作。而 tcpdump 提供了灵活的语法可以精确地截取关心的数据报，简化分析的工作量。这些选择数据包的语句就是过滤器（filter）！</p><h3 id="Host-过滤器"><a href="#Host-过滤器" class="headerlink" title="Host 过滤器"></a>Host 过滤器</h3><p>Host 过滤器用来过滤某个主机的数据报文。例如：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">$ tcpdump host <span class="hljs-number">1.2</span><span class="hljs-number">.3</span><span class="hljs-number">.4</span><br></code></pre></div></td></tr></table></figure><p>该命令会抓取所有发往主机 <code>1.2.3.4</code> 或者从主机 <code>1.2.3.4</code> 发出的流量。如果想只抓取从该主机发出的流量，可以使用下面的命令：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">$ tcpdump src host <span class="hljs-number">1.2</span><span class="hljs-number">.3</span><span class="hljs-number">.4</span><br></code></pre></div></td></tr></table></figure><h3 id="Network-过滤器"><a href="#Network-过滤器" class="headerlink" title="Network 过滤器"></a>Network 过滤器</h3><p>Network 过滤器用来过滤某个网段的数据，使用的是 <code>CIDR[2]</code> 模式。可以使用四元组（x.x.x.x）、三元组（x.x.x）、二元组（x.x）和一元组（x）。四元组就是指定某个主机，三元组表示子网掩码为 255.255.255.0，二元组表示子网掩码为 <code>255.255.0.0</code>，一元组表示子网掩码为 <code>255.0.0.0</code>。例如，</p><p>抓取所有发往网段 <code>192.168.1.x</code> 或从网段 <code>192.168.1.x</code> 发出的流量：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">$ tcpdump net <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><br></code></pre></div></td></tr></table></figure><p>抓取所有发往网段 <code>10.x.x.x</code> 或从网段 <code>10.x.x.x</code> 发出的流量：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">$ tcpdump net <span class="hljs-number">10</span><br></code></pre></div></td></tr></table></figure><p>和 Host 过滤器一样，这里也可以指定源和目的：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">$ tcpdump src net <span class="hljs-number">10</span><br></code></pre></div></td></tr></table></figure><p>也可以使用 CIDR 格式：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">$ tcpdump src net <span class="hljs-number">172.16</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>/<span class="hljs-number">12</span><br></code></pre></div></td></tr></table></figure><h3 id="Proto-过滤器"><a href="#Proto-过滤器" class="headerlink" title="Proto 过滤器"></a>Proto 过滤器</h3><p>Proto 过滤器用来过滤某个协议的数据，关键字为 <code>proto</code>，可省略。proto 后面可以跟上协议号或协议名称，支持 <code>icmp</code>, <code>igmp</code>, <code>igrp</code>, <code>pim</code>, <code>ah</code>, <code>esp</code>, <code>carp</code>, <code>vrrp</code>, <code>udp</code>和 <code>tcp</code>。因为通常的协议名称是保留字段，所以在与 proto 指令一起使用时，必须根据 shell 类型使用一个或两个反斜杠（/）来转义。Linux 中的 shell 需要使用两个反斜杠来转义，MacOS 只需要一个。</p><p>例如，抓取 icmp 协议的报文：</p><figure class="highlight elixir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>tcpdump -n proto \\icmp<br><span class="hljs-comment"># 或者</span><br><span class="hljs-variable">$ </span>tcpdump -n icmp<br></code></pre></div></td></tr></table></figure><h3 id="Port-过滤器"><a href="#Port-过滤器" class="headerlink" title="Port 过滤器"></a>Port 过滤器</h3><p><code>Port</code> 过滤器用来过滤通过某个端口的数据报文，关键字为 <code>port</code>。例如：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">$ tcpdump<span class="hljs-built_in"> port </span>389<br></code></pre></div></td></tr></table></figure><h3 id="理解-tcpdump-的输出"><a href="#理解-tcpdump-的输出" class="headerlink" title="理解 tcpdump 的输出"></a>理解 tcpdump 的输出</h3><p>截取数据只是第一步，第二步就是理解这些数据，下面就解释一下 tcpdump 命令输出各部分的意义</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">21</span>:<span class="hljs-number">27</span>:<span class="hljs-number">06.995846</span> IP (tos <span class="hljs-number">0x0</span>, ttl <span class="hljs-number">64</span>, id <span class="hljs-number">45646</span>, offset <span class="hljs-number">0</span>, flags [DF], proto TCP (<span class="hljs-number">6</span>), length <span class="hljs-number">64</span>)<br>    <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.106</span><span class="hljs-number">.56166</span> &gt; <span class="hljs-number">124.192</span><span class="hljs-number">.132</span><span class="hljs-number">.54</span><span class="hljs-number">.80</span>: Flags [S], cksum <span class="hljs-number">0xa730</span> (correct), seq <span class="hljs-number">992042666</span>, win <span class="hljs-number">65535</span>, options [mss <span class="hljs-number">1460</span>,nop,wscale <span class="hljs-number">4</span>,nop,nop,TS val <span class="hljs-number">663433143</span> ecr <span class="hljs-number">0</span>,sackOK,eol], length <span class="hljs-number">0</span><br><br><span class="hljs-number">21</span>:<span class="hljs-number">27</span>:<span class="hljs-number">07.030487</span> IP (tos <span class="hljs-number">0x0</span>, ttl <span class="hljs-number">51</span>, id <span class="hljs-number">0</span>, offset <span class="hljs-number">0</span>, flags [DF], proto TCP (<span class="hljs-number">6</span>), length <span class="hljs-number">44</span>)<br>    <span class="hljs-number">124.192</span><span class="hljs-number">.132</span><span class="hljs-number">.54</span><span class="hljs-number">.80</span> &gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.106</span><span class="hljs-number">.56166</span>: Flags [S.], cksum <span class="hljs-number">0xedc0</span> (correct), seq <span class="hljs-number">2147006684</span>, ack <span class="hljs-number">992042667</span>, win <span class="hljs-number">14600</span>, options [mss <span class="hljs-number">1440</span>], length <span class="hljs-number">0</span><br><br><span class="hljs-number">21</span>:<span class="hljs-number">27</span>:<span class="hljs-number">07.030527</span> IP (tos <span class="hljs-number">0x0</span>, ttl <span class="hljs-number">64</span>, id <span class="hljs-number">59119</span>, offset <span class="hljs-number">0</span>, flags [DF], proto TCP (<span class="hljs-number">6</span>), length <span class="hljs-number">40</span>)<br>    <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.106</span><span class="hljs-number">.56166</span> &gt; <span class="hljs-number">124.192</span><span class="hljs-number">.132</span><span class="hljs-number">.54</span><span class="hljs-number">.80</span>: Flags [.], cksum <span class="hljs-number">0x3e72</span> (correct), ack <span class="hljs-number">2147006685</span>, win <span class="hljs-number">65535</span>, length <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p>最基本也是最重要的信息就是数据报的源地址/端口和目的地址/端口，上面的例子第一条数据报中，源地址 ip 是 <code>192.168.1.106</code>，源端口是 <code>56166</code>，目的地址是 <code>124.192.132.54</code>，目的端口是 <code>80</code>。&gt; 符号代表数据的方向。</p><p>此外，上面的三条数据还是 tcp 协议的三次握手过程，第一条就是 <code>SYN</code> 报文，这个可以通过 <code>Flags [S]</code> 看出。下面是常见的 TCP 报文的 Flags:</p><blockquote><p>[S] : SYN（开始连接）<br>[.] : 没有 Flag<br>[P] : PSH（推送数据）<br>[F] : FIN （结束连接）<br>[R] : RST（重置连接）<br>而第二条数据的 <code>[S.]</code> 表示 <code>SYN-ACK</code>，就是 <code>SYN</code> 报文的应答报文。</p></blockquote><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>下面给出一些具体的例子，每个例子都可以使用多种方法来获得相同的输出，你使用的方法取决于所需的输出和网络上的流量。我们在排障时，通常只想获取自己想要的内容，可以通过过滤器和 ASCII 输出并结合管道与 grep、cut、awk 等工具来实现此目的。</p><p>例如，在抓取 HTTP 请求和响应数据包时，可以通过删除标志 SYN/ACK/FIN 来过滤噪声，但还有更简单的方法，那就是通过管道传递给 grep。在达到目的的同时，我们要选择最简单最高效的方法。下面来看例子。</p><h3 id="提取-HTTP-用户代理"><a href="#提取-HTTP-用户代理" class="headerlink" title="提取 HTTP 用户代理"></a>提取 HTTP 用户代理</h3><p>从 HTTP 请求头中提取 HTTP 用户代理：</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">$ tcpdump -<span class="hljs-keyword">nn</span> -A -s1500 -<span class="hljs-keyword">l</span> | <span class="hljs-keyword">grep</span> <span class="hljs-string">"User-Agent:"</span><br></code></pre></div></td></tr></table></figure><p>通过 <code>egrep</code> 可以同时提取用户代理和主机名（或其他头文件）：</p><figure class="highlight coq"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coq">$ tcpdump -nn -A -s1500 -l | <span class="hljs-type">egrep</span> -i 'User-Agent:|<span class="hljs-type">Host</span>:'<br></code></pre></div></td></tr></table></figure><h3 id="只抓取-HTTP-GET-和-POST-流量"><a href="#只抓取-HTTP-GET-和-POST-流量" class="headerlink" title="只抓取 HTTP GET 和 POST 流量"></a>只抓取 HTTP GET 和 POST 流量</h3><p>抓取 HTTP GET 流量：</p><figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c">$ tcpdump -s <span class="hljs-number">0</span> -A -vv 'tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x<span class="hljs-number">47455420</span>'<br></code></pre></div></td></tr></table></figure><p>也可以抓取 HTTP POST 请求流量：</p><figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c">$ tcpdump -s <span class="hljs-number">0</span> -A -vv 'tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x504f<span class="hljs-number">5354</span>'<br></code></pre></div></td></tr></table></figure><p>注意：该方法不能保证抓取到 HTTP POST 有效数据流量，因为一个 POST 请求会被分割为多个 TCP 数据包。</p><p>上述两个表达式中的十六进制将会与 GET 和 POST 请求的 <code>ASCII</code> 字符串匹配。例如，<code>tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4]</code> 首先会确定我们感兴趣的字节的位置[3]（在 TCP header 之后），然后选择我们希望匹配的 4 个字节。</p><h3 id="提取-HTTP-请求的-URL"><a href="#提取-HTTP-请求的-URL" class="headerlink" title="提取 HTTP 请求的 URL"></a>提取 HTTP 请求的 URL</h3><p>提取 HTTP 请求的主机名和路径：</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">$ tcpdump -s <span class="hljs-number">0</span> -v -n -<span class="hljs-keyword">l</span> | egrep -i <span class="hljs-string">"POST /|GET /|Host:"</span><br><br>tcpdump: listening <span class="hljs-keyword">on</span> enp7s0, link-<span class="hljs-built_in">type</span> EN10MB (Ethernet), capture size <span class="hljs-number">262144</span> bytes<br>POST /<span class="hljs-keyword">wp</span>-login.php HTTP/<span class="hljs-number">1.1</span><br>Hos<span class="hljs-variable">t:</span> dev.example.<span class="hljs-keyword">com</span><br>GET /<span class="hljs-keyword">wp</span>-login.php HTTP/<span class="hljs-number">1.1</span><br>Hos<span class="hljs-variable">t:</span> dev.example.<span class="hljs-keyword">com</span><br>GET /favicon.ico HTTP/<span class="hljs-number">1.1</span><br>Hos<span class="hljs-variable">t:</span> dev.example.<span class="hljs-keyword">com</span><br>GET / HTTP/<span class="hljs-number">1.1</span><br>Hos<span class="hljs-variable">t:</span> dev.example.<span class="hljs-keyword">com</span><br></code></pre></div></td></tr></table></figure><h3 id="提取-HTTP-POST-请求中的密码"><a href="#提取-HTTP-POST-请求中的密码" class="headerlink" title="提取 HTTP POST 请求中的密码"></a>提取 HTTP POST 请求中的密码</h3><p>从 HTTP POST 请求中提取密码和主机名：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">$ tcpdump -s <span class="hljs-number">0</span> -A -n -l | egrep -i <span class="hljs-string">"POST /|pwd=|passwd=|password=|Host:"</span><br><br>tcpdump: verbose output suppressed, use -v <span class="hljs-keyword">or</span> -vv <span class="hljs-keyword">for</span> full protocol decode<br>listening on enp7s0, link-type EN10MB (Ethernet), capture size <span class="hljs-number">262144</span> bytes<br><span class="hljs-number">11</span>:<span class="hljs-number">25</span>:<span class="hljs-number">54.799014</span> IP <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.30</span><span class="hljs-number">.39224</span> &gt; <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.125</span><span class="hljs-number">.80</span>: Flags [P.], seq <span class="hljs-number">1458768667</span>:<span class="hljs-number">1458770008</span>, ack <span class="hljs-number">2440130792</span>, win <span class="hljs-number">704</span>, options [nop,nop,TS val <span class="hljs-number">461552632</span> ecr <span class="hljs-number">208900561</span>], length <span class="hljs-number">1341</span>: HTTP: POST /wp-login.php HTTP/<span class="hljs-number">1.1</span><br>.....s..POST /wp-login.php HTTP/<span class="hljs-number">1.1</span><br>Host: dev.example.com<br>.....s..log=admin&amp;pwd=notmypassword&amp;wp-submit=Log+In&amp;redirect_to=http%<span class="hljs-number">3</span>A%<span class="hljs-number">2</span>F%<span class="hljs-number">2</span>Fdev.example.com%<span class="hljs-number">2</span>Fwp-admin%<span class="hljs-number">2</span>F&amp;testcookie=<span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><h3 id="提取-Cookies"><a href="#提取-Cookies" class="headerlink" title="提取 Cookies"></a>提取 Cookies</h3><p>提取 <code>Set-Cookie</code>（服务端的 Cookie）和 <code>Cookie</code>（客户端的 Cookie）：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">$ tcpdump -nn -A -s0 -l | egrep -i <span class="hljs-string">'Set-Cookie|Host:|Cookie:'</span><br><br>tcpdump: verbose output suppressed, use -v <span class="hljs-keyword">or</span> -vv <span class="hljs-keyword">for</span> full protocol decode<br>listening on wlp58s0, link-type EN10MB (Ethernet), capture size 262144 bytes<br>Host: dev.example.com<br>Cookie: <span class="hljs-attribute">wordpress_86be02xxxxxxxxxxxxxxxxxxxc43</span>=admin%7C152xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxfb3e15c744fdd6; <span class="hljs-attribute">_ga</span>=GA1.2.21343434343421934; <span class="hljs-attribute">_gid</span>=GA1.2.927343434349426; <span class="hljs-attribute">wordpress_test_cookie</span>=WP+Cookie+check; <span class="hljs-attribute">wordpress_logged_in_86be654654645645645654645653fc43</span>=admin%7C15275102testtesttesttestab7a61e; <span class="hljs-attribute">wp-settings-time-1</span>=1527337439<br></code></pre></div></td></tr></table></figure><h3 id="抓取-ICMP-数据包"><a href="#抓取-ICMP-数据包" class="headerlink" title="抓取 ICMP 数据包"></a>抓取 ICMP 数据包</h3><p>查看网络上的所有 ICMP 数据包：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">$ tcpdump -n icmp<br><br>tcpdump: verbose output suppressed, use -v <span class="hljs-keyword">or</span> -vv <span class="hljs-keyword">for</span> full protocol decode<br>listening on enp7s0, link-type EN10MB (Ethernet), capture size 262144 bytes<br>11:34:21.590380<span class="hljs-built_in"> IP </span>10.10.1.217 &gt; 10.10.1.30: ICMP echo request, id 27948, seq 1, length 64<br>11:34:21.590434<span class="hljs-built_in"> IP </span>10.10.1.30 &gt; 10.10.1.217: ICMP echo reply, id 27948, seq 1, length 64<br>11:34:27.680307<span class="hljs-built_in"> IP </span>10.10.1.159 &gt; 10.10.1.1: ICMP 10.10.1.189 udp<span class="hljs-built_in"> port </span>59619 unreachable, length 115<br></code></pre></div></td></tr></table></figure><h3 id="抓取非-ECHO-REPLY-类型的-ICMP-数据包"><a href="#抓取非-ECHO-REPLY-类型的-ICMP-数据包" class="headerlink" title="抓取非 ECHO/REPLY 类型的 ICMP 数据包"></a>抓取非 ECHO/REPLY 类型的 ICMP 数据包</h3><p>通过排除 echo 和 reply 类型的数据包使抓取到的数据包不包括标准的 <code>ping</code> 包：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">$ tcpdump <span class="hljs-string">'icmp[icmptype] != icmp-echo and icmp[icmptype] != icmp-echoreply'</span><br><br>tcpdump: verbose output suppressed, use -v <span class="hljs-keyword">or</span> -vv <span class="hljs-keyword">for</span> full protocol decode<br>listening on enp7s0, link-type EN10MB (Ethernet), capture size 262144 bytes<br>11:37:04.041037<span class="hljs-built_in"> IP </span>10.10.1.189 &gt; 10.10.1.20: ICMP 10.10.1.189 udp<span class="hljs-built_in"> port </span>36078 unreachable, length 156<br></code></pre></div></td></tr></table></figure><h3 id="抓取-SMTP-POP3-协议的邮件"><a href="#抓取-SMTP-POP3-协议的邮件" class="headerlink" title="抓取 SMTP/POP3 协议的邮件"></a>抓取 SMTP/POP3 协议的邮件</h3><p>可以提取电子邮件的正文和其他数据。例如，只提取电子邮件的收件人：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">$ tcpdump -nn -l<span class="hljs-built_in"> port </span>25 | grep -i <span class="hljs-string">'MAIL FROM\|RCPT TO'</span><br></code></pre></div></td></tr></table></figure><h3 id="抓取-NTP-服务的查询和响应"><a href="#抓取-NTP-服务的查询和响应" class="headerlink" title="抓取 NTP 服务的查询和响应"></a>抓取 NTP 服务的查询和响应</h3><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">$ tcpdump dst<span class="hljs-built_in"> port </span>123<br><br>tcpdump: verbose output suppressed, use -v <span class="hljs-keyword">or</span> -vv <span class="hljs-keyword">for</span> full protocol decode<br>listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes<br>21:02:19.112502<span class="hljs-built_in"> IP </span>test33.ntp &gt; 199.30.140.74.ntp: NTPv4, Client, length 48<br>21:02:19.113888<span class="hljs-built_in"> IP </span>216.239.35.0.ntp &gt; test33.ntp: NTPv4, Server, length 48<br>21:02:20.150347<span class="hljs-built_in"> IP </span>test33.ntp &gt; 216.239.35.0.ntp: NTPv4, Client, length 48<br>21:02:20.150991<span class="hljs-built_in"> IP </span>216.239.35.0.ntp &gt; test33.ntp: NTPv4, Server, length 48<br></code></pre></div></td></tr></table></figure><h3 id="抓取-SNMP-服务的查询和响应"><a href="#抓取-SNMP-服务的查询和响应" class="headerlink" title="抓取 SNMP 服务的查询和响应"></a>抓取 SNMP 服务的查询和响应</h3><p>通过 SNMP 服务，渗透测试人员可以获取大量的设备和系统信息。在这些信息中，系统信息最为关键，如操作系统版本、内核版本等。使用 SNMP 协议快速扫描程序 onesixtyone，可以看到目标系统的信息：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">$ onesixtyone <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.10</span> <span class="hljs-keyword">public</span><br><br>Scanning <span class="hljs-number">1</span> hosts, <span class="hljs-number">1</span> communities<br><span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.10</span> [<span class="hljs-keyword">public</span>] Linux test33 <span class="hljs-number">4.15</span><span class="hljs-number">.0</span><span class="hljs-number">-20</span>-generic #<span class="hljs-number">21</span>-Ubuntu SMP Tue Apr <span class="hljs-number">24</span> <span class="hljs-number">06</span>:<span class="hljs-number">16</span>:<span class="hljs-number">15</span> UTC <span class="hljs-number">2018</span> x86_64<br></code></pre></div></td></tr></table></figure><p>可以通过 tcpdump 抓取 <code>GetRequest</code> 和 <code>GetResponse</code>：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">$ tcpdump -n -s0  port <span class="hljs-number">161</span> <span class="hljs-keyword">and</span> udp<br>tcpdump: verbose output suppressed, use -v <span class="hljs-keyword">or</span> -vv <span class="hljs-keyword">for</span> full protocol decode<br>listening on wlp58s0, link-type EN10MB (Ethernet), capture size <span class="hljs-number">262144</span> bytes<br><span class="hljs-number">23</span>:<span class="hljs-number">39</span>:<span class="hljs-number">13.725522</span> IP <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.159</span><span class="hljs-number">.36826</span> &gt; <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span><span class="hljs-number">.161</span>:  GetRequest(<span class="hljs-number">28</span>)  <span class="hljs-number">.1</span><span class="hljs-number">.3</span><span class="hljs-number">.6</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span><br><span class="hljs-number">23</span>:<span class="hljs-number">39</span>:<span class="hljs-number">13.728789</span> IP <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span><span class="hljs-number">.161</span> &gt; <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.159</span><span class="hljs-number">.36826</span>:  GetResponse(<span class="hljs-number">109</span>)  <span class="hljs-number">.1</span><span class="hljs-number">.3</span><span class="hljs-number">.6</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>=<span class="hljs-string">"Linux testmachine 4.15.0-20-generic #21-Ubuntu SMP Tue Apr 24 06:16:15 UTC 2018 x86_64"</span><br></code></pre></div></td></tr></table></figure><h3 id="切割-pcap-文件"><a href="#切割-pcap-文件" class="headerlink" title="切割 pcap 文件"></a>切割 pcap 文件</h3><p>当抓取大量数据并写入文件时，可以自动切割为多个大小相同的文件。例如，下面的命令表示每 3600 秒创建一个新文件 <code>capture-(hour).pcap</code>，每个文件大小不超过 <code>200*1000000</code> 字节：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">$ tcpdump  -w /tmp/capture-%H.pcap -G <span class="hljs-number">3600</span> -C <span class="hljs-number">200</span><br></code></pre></div></td></tr></table></figure><p>这些文件的命名为 <code>capture-{1-24}.pcap</code>，24 小时之后，之前的文件就会被覆盖。</p><h3 id="抓取-IPv6-流量"><a href="#抓取-IPv6-流量" class="headerlink" title="抓取 IPv6 流量"></a>抓取 IPv6 流量</h3><p>可以通过过滤器 <code>ip6</code> 来抓取 IPv6 流量，同时可以指定协议如 TCP：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">$ tcpdump -nn ip6 proto <span class="hljs-number">6</span><br></code></pre></div></td></tr></table></figure><p>从之前保存的文件中读取 IPv6 UDP 数据报文：</p><figure class="highlight smali"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs smali">$ tcpdump -nr ipv6-test.pcap ip6 proto 17<br></code></pre></div></td></tr></table></figure><h3 id="检测端口扫描"><a href="#检测端口扫描" class="headerlink" title="检测端口扫描"></a>检测端口扫描</h3><p>在下面的例子中，你会发现抓取到的报文的源和目的一直不变，且带有标志位 <code>[S]</code> 和 <code>[R]</code>，它们与一系列看似随机的目标端口进行匹配。当发送 <code>SYN</code> 之后，如果目标主机的端口没有打开，就会返回一个 <code>RESET</code>。这是 <code>Nmap</code> 等端口扫描工具的标准做法。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">$ tcpdump -nn<br><br><span class="hljs-number">21</span>:<span class="hljs-number">46</span>:<span class="hljs-number">19.693601</span> IP <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.10</span><span class="hljs-number">.60460</span> &gt; <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.199</span><span class="hljs-number">.5432</span>: Flags [S], seq <span class="hljs-number">116466344</span>, win <span class="hljs-number">29200</span>, options [mss <span class="hljs-number">1460</span>,sackOK,TS val <span class="hljs-number">3547090332</span> ecr <span class="hljs-number">0</span>,nop,wscale <span class="hljs-number">7</span>], length <span class="hljs-number">0</span><br><span class="hljs-number">21</span>:<span class="hljs-number">46</span>:<span class="hljs-number">19.693626</span> IP <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.10</span><span class="hljs-number">.35470</span> &gt; <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.199</span><span class="hljs-number">.513</span>: Flags [S], seq <span class="hljs-number">3400074709</span>, win <span class="hljs-number">29200</span>, options [mss <span class="hljs-number">1460</span>,sackOK,TS val <span class="hljs-number">3547090332</span> ecr <span class="hljs-number">0</span>,nop,wscale <span class="hljs-number">7</span>], length <span class="hljs-number">0</span><br><span class="hljs-number">21</span>:<span class="hljs-number">46</span>:<span class="hljs-number">19.693762</span> IP <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.10</span><span class="hljs-number">.44244</span> &gt; <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.199</span><span class="hljs-number">.389</span>: Flags [S], seq <span class="hljs-number">2214070267</span>, win <span class="hljs-number">29200</span>, options [mss <span class="hljs-number">1460</span>,sackOK,TS val <span class="hljs-number">3547090333</span> ecr <span class="hljs-number">0</span>,nop,wscale <span class="hljs-number">7</span>], length <span class="hljs-number">0</span><br><span class="hljs-number">21</span>:<span class="hljs-number">46</span>:<span class="hljs-number">19.693772</span> IP <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.199</span><span class="hljs-number">.389</span> &gt; <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.10</span><span class="hljs-number">.44244</span>: Flags [R.], seq <span class="hljs-number">0</span>, ack <span class="hljs-number">2214070268</span>, win <span class="hljs-number">0</span>, length <span class="hljs-number">0</span><br><span class="hljs-number">21</span>:<span class="hljs-number">46</span>:<span class="hljs-number">19.693783</span> IP <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.10</span><span class="hljs-number">.35172</span> &gt; <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.199</span><span class="hljs-number">.1433</span>: Flags [S], seq <span class="hljs-number">2358257571</span>, win <span class="hljs-number">29200</span>, options [mss <span class="hljs-number">1460</span>,sackOK,TS val <span class="hljs-number">3547090333</span> ecr <span class="hljs-number">0</span>,nop,wscale <span class="hljs-number">7</span>], length <span class="hljs-number">0</span><br><span class="hljs-number">21</span>:<span class="hljs-number">46</span>:<span class="hljs-number">19.693826</span> IP <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.10</span><span class="hljs-number">.33022</span> &gt; <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.199</span><span class="hljs-number">.49153</span>: Flags [S], seq <span class="hljs-number">2406028551</span>, win <span class="hljs-number">29200</span>, options [mss <span class="hljs-number">1460</span>,sackOK,TS val <span class="hljs-number">3547090333</span> ecr <span class="hljs-number">0</span>,nop,wscale <span class="hljs-number">7</span>], length <span class="hljs-number">0</span><br><span class="hljs-number">21</span>:<span class="hljs-number">46</span>:<span class="hljs-number">19.695567</span> IP <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.10</span><span class="hljs-number">.55130</span> &gt; <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.199</span><span class="hljs-number">.49154</span>: Flags [S], seq <span class="hljs-number">3230403372</span>, win <span class="hljs-number">29200</span>, options [mss <span class="hljs-number">1460</span>,sackOK,TS val <span class="hljs-number">3547090334</span> ecr <span class="hljs-number">0</span>,nop,wscale <span class="hljs-number">7</span>], length <span class="hljs-number">0</span><br><span class="hljs-number">21</span>:<span class="hljs-number">46</span>:<span class="hljs-number">19.695590</span> IP <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.199</span><span class="hljs-number">.49154</span> &gt; <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.10</span><span class="hljs-number">.55130</span>: Flags [R.], seq <span class="hljs-number">0</span>, ack <span class="hljs-number">3230403373</span>, win <span class="hljs-number">0</span>, length <span class="hljs-number">0</span><br><span class="hljs-number">21</span>:<span class="hljs-number">46</span>:<span class="hljs-number">19.695608</span> IP <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.10</span><span class="hljs-number">.33460</span> &gt; <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.199</span><span class="hljs-number">.49152</span>: Flags [S], seq <span class="hljs-number">3289070068</span>, win <span class="hljs-number">29200</span>, options [mss <span class="hljs-number">1460</span>,sackOK,TS val <span class="hljs-number">3547090335</span> ecr <span class="hljs-number">0</span>,nop,wscale <span class="hljs-number">7</span>], length <span class="hljs-number">0</span><br><span class="hljs-number">21</span>:<span class="hljs-number">46</span>:<span class="hljs-number">19.695622</span> IP <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.199</span><span class="hljs-number">.49152</span> &gt; <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.10</span><span class="hljs-number">.33460</span>: Flags [R.], seq <span class="hljs-number">0</span>, ack <span class="hljs-number">3289070069</span>, win <span class="hljs-number">0</span>, length <span class="hljs-number">0</span><br><span class="hljs-number">21</span>:<span class="hljs-number">46</span>:<span class="hljs-number">19.695637</span> IP <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.10</span><span class="hljs-number">.34940</span> &gt; <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.199</span><span class="hljs-number">.1029</span>: Flags [S], seq <span class="hljs-number">140319147</span>, win <span class="hljs-number">29200</span>, options [mss <span class="hljs-number">1460</span>,sackOK,TS val <span class="hljs-number">3547090335</span> ecr <span class="hljs-number">0</span>,nop,wscale <span class="hljs-number">7</span>], length <span class="hljs-number">0</span><br><span class="hljs-number">21</span>:<span class="hljs-number">46</span>:<span class="hljs-number">19.695650</span> IP <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.199</span><span class="hljs-number">.1029</span> &gt; <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.10</span><span class="hljs-number">.34940</span>: Flags [R.], seq <span class="hljs-number">0</span>, ack <span class="hljs-number">140319148</span>, win <span class="hljs-number">0</span>, length <span class="hljs-number">0</span><br><span class="hljs-number">21</span>:<span class="hljs-number">46</span>:<span class="hljs-number">19.695664</span> IP <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.10</span><span class="hljs-number">.45648</span> &gt; <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.199</span><span class="hljs-number">.5060</span>: Flags [S], seq <span class="hljs-number">2203629201</span>, win <span class="hljs-number">29200</span>, options [mss <span class="hljs-number">1460</span>,sackOK,TS val <span class="hljs-number">3547090335</span> ecr <span class="hljs-number">0</span>,nop,wscale <span class="hljs-number">7</span>], length <span class="hljs-number">0</span><br><span class="hljs-number">21</span>:<span class="hljs-number">46</span>:<span class="hljs-number">19.695775</span> IP <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.10</span><span class="hljs-number">.49028</span> &gt; <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.199</span><span class="hljs-number">.2000</span>: Flags [S], seq <span class="hljs-number">635990431</span>, win <span class="hljs-number">29200</span>, options [mss <span class="hljs-number">1460</span>,sackOK,TS val <span class="hljs-number">3547090335</span> ecr <span class="hljs-number">0</span>,nop,wscale <span class="hljs-number">7</span>], length <span class="hljs-number">0</span><br><span class="hljs-number">21</span>:<span class="hljs-number">46</span>:<span class="hljs-number">19.695790</span> IP <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.199</span><span class="hljs-number">.2000</span> &gt; <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.10</span><span class="hljs-number">.49028</span>: Flags [R.], seq <span class="hljs-number">0</span>, ack <span class="hljs-number">635990432</span>, win <span class="hljs-number">0</span>, length <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><h3 id="过滤-Nmap-NSE-脚本测试结果"><a href="#过滤-Nmap-NSE-脚本测试结果" class="headerlink" title="过滤 Nmap NSE 脚本测试结果"></a>过滤 Nmap NSE 脚本测试结果</h3><p>本例中 Nmap NSE 测试脚本 <code>http-enum.nse</code> 用来检测 HTTP 服务的合法 URL。</p><p>在执行脚本测试的主机上：</p><figure class="highlight crystal"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crystal">$ nmap -p <span class="hljs-number">80</span> --script=http-<span class="hljs-class"><span class="hljs-keyword">enum</span>.<span class="hljs-title">nse</span> <span class="hljs-title">targetip</span></span><br></code></pre></div></td></tr></table></figure><p>在目标主机上：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">$ tcpdump -nn<span class="hljs-built_in"> port </span>80 | grep <span class="hljs-string">"GET /"</span><br><br><span class="hljs-builtin-name">GET</span> /w3perl/ HTTP/1.1<br><span class="hljs-builtin-name">GET</span> /w-agora/ HTTP/1.1<br><span class="hljs-builtin-name">GET</span> /way-board/ HTTP/1.1<br><span class="hljs-builtin-name">GET</span> /web800fo/ HTTP/1.1<br><span class="hljs-builtin-name">GET</span> /webaccess/ HTTP/1.1<br><span class="hljs-builtin-name">GET</span> /webadmin/ HTTP/1.1<br><span class="hljs-builtin-name">GET</span> /webAdmin/ HTTP/1.1<br></code></pre></div></td></tr></table></figure><h3 id="抓取-DNS-请求和响应"><a href="#抓取-DNS-请求和响应" class="headerlink" title="抓取 DNS 请求和响应"></a>抓取 DNS 请求和响应</h3><p>向 Google 公共 DNS 发起的出站 DNS 请求和 A 记录响应可以通过 tcpdump 抓取到：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">$ tcpdump -i wlp58s0 -s0<span class="hljs-built_in"> port </span>53<br><br>tcpdump: verbose output suppressed, use -v <span class="hljs-keyword">or</span> -vv <span class="hljs-keyword">for</span> full protocol decode<br>listening on wlp58s0, link-type EN10MB (Ethernet), capture size 262144 bytes<br>14:19:06.879799<span class="hljs-built_in"> IP </span>test.53852 &gt; google-public-dns-a.google.com.domain: 26977+ [1au] A? play.google.com. (44)<br>14:19:07.022618<span class="hljs-built_in"> IP </span>google-public-dns-a.google.com.domain &gt; test.53852: 26977 1/0/1 A 216.58.203.110 (60)<br></code></pre></div></td></tr></table></figure><h3 id="抓取-HTTP-有效数据包"><a href="#抓取-HTTP-有效数据包" class="headerlink" title="抓取 HTTP 有效数据包"></a>抓取 HTTP 有效数据包</h3><p>抓取 80 端口的 HTTP 有效数据包，排除 TCP 连接建立过程的数据包（SYN / FIN / ACK）：</p><figure class="highlight inform7"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs inform7">$ tcpdump 'tcp port 80 and (((ip<span class="hljs-comment">[2:2]</span> - ((ip<span class="hljs-comment">[0]</span>&amp;0xf)&lt;&lt;2)) - ((tcp<span class="hljs-comment">[12]</span>&amp;0xf0)&gt;&gt;2)) != 0)'<br></code></pre></div></td></tr></table></figure><h3 id="将输出内容重定向到-Wireshark"><a href="#将输出内容重定向到-Wireshark" class="headerlink" title="将输出内容重定向到 Wireshark"></a>将输出内容重定向到 Wireshark</h3><p>通常 <code>Wireshark</code>（或 tshark）比 tcpdump 更容易分析应用层协议。一般的做法是在远程服务器上先使用 <code>tcpdump</code> 抓取数据并写入文件，然后再将文件拷贝到本地工作站上用 Wireshark 分析。</p><p>还有一种更高效的方法，可以通过 ssh 连接将抓取到的数据实时发送给 Wireshark 进行分析。以 MacOS 系统为例，可以通过 <code>brew cask install wireshark</code> 来安装，然后通过下面的命令来分析：</p><figure class="highlight elixir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>ssh root<span class="hljs-variable">@remotesystem</span> <span class="hljs-string">'tcpdump -s0 -c 1000 -nn -w - not port 22'</span> | <span class="hljs-regexp">/Applications/</span>Wireshark.app/Contents/MacOS/Wireshark -k -i -<br></code></pre></div></td></tr></table></figure><p>例如，如果想分析 DNS 协议，可以使用下面的命令：</p><figure class="highlight elixir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>ssh root<span class="hljs-variable">@remotesystem</span> <span class="hljs-string">'tcpdump -s0 -c 1000 -nn -w - port 53'</span> | <span class="hljs-regexp">/Applications/</span>Wireshark.app/Contents/MacOS/Wireshark -k -i -<br></code></pre></div></td></tr></table></figure><p>抓取到的数据：<br><img src="/img/newimg/0082zybpgy1gbz9bss742j31080s010t.jpg" srcset="/img/loading.gif" alt=""></p><p><code>-c</code> 选项用来限制抓取数据的大小。如果不限制大小，就只能通过 <code>ctrl-c</code> 来停止抓取，这样一来不仅关闭了 tcpdump，也关闭了 wireshark。</p><h3 id="找出发包最多的-IP"><a href="#找出发包最多的-IP" class="headerlink" title="找出发包最多的 IP"></a>找出发包最多的 IP</h3><p>找出一段时间内发包最多的 IP，或者从一堆报文中找出发包最多的 IP，可以使用下面的命令：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">$ tcpdump -nnn -t -c 200 | cut -f 1,2,3,4 -d <span class="hljs-string">'.'</span> | sort | uniq -c | sort -nr | head -n 20<br><br>tcpdump: verbose output suppressed, use -v <span class="hljs-keyword">or</span> -vv <span class="hljs-keyword">for</span> full protocol decode<br>listening on enp7s0, link-type EN10MB (Ethernet), capture size 262144 bytes<br>200 packets captured<br>261 packets received by filter<br>0 packets dropped by kernel<br>    108<span class="hljs-built_in"> IP </span>10.10.211.181<br>     91<span class="hljs-built_in"> IP </span>10.10.1.30<br>      1<span class="hljs-built_in"> IP </span>10.10.1.50<br></code></pre></div></td></tr></table></figure><blockquote><p>cut -f 1,2,3,4 -d ‘.’ : 以 . 为分隔符，打印出每行的前四列。即 IP 地址。<br>sort | uniq -c : 排序并计数<br>sort -nr : 按照数值大小逆向排序</p></blockquote><h3 id="抓取用户名和密码"><a href="#抓取用户名和密码" class="headerlink" title="抓取用户名和密码"></a>抓取用户名和密码</h3><p>本例将重点放在标准纯文本协议上，过滤出于用户名和密码相关的报文：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">$ tcpdump<span class="hljs-built_in"> port </span>http <span class="hljs-keyword">or</span><span class="hljs-built_in"> port </span>ftp <span class="hljs-keyword">or</span><span class="hljs-built_in"> port </span>smtp <span class="hljs-keyword">or</span><span class="hljs-built_in"> port </span>imap <span class="hljs-keyword">or</span><span class="hljs-built_in"> port </span>pop3 <span class="hljs-keyword">or</span><span class="hljs-built_in"> port </span>telnet -l -A | egrep -i -B5 <span class="hljs-string">'pass=|pwd=|log=|login=|user=|username=|pw=|passw=|passwd=|password=|pass:|user:|username:|password:|login:|pass |user '</span><br></code></pre></div></td></tr></table></figure><h3 id="抓取-DHCP-报文"><a href="#抓取-DHCP-报文" class="headerlink" title="抓取 DHCP 报文"></a>抓取 DHCP 报文</h3><p>最后一个例子，抓取 DHCP 服务的请求和响应报文，67 为 DHCP 端口，68 为客户机端口。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">$ tcpdump -v -n port <span class="hljs-number">67</span> <span class="hljs-keyword">or</span> <span class="hljs-number">68</span><br><br>tcpdump: listening on enp7s0, link-type EN10MB (Ethernet), capture size <span class="hljs-number">262144</span> bytes<br><span class="hljs-number">14</span>:<span class="hljs-number">37</span>:<span class="hljs-number">50.059662</span> IP (tos <span class="hljs-number">0x10</span>, ttl <span class="hljs-number">128</span>, id <span class="hljs-number">0</span>, offset <span class="hljs-number">0</span>, flags [none], proto UDP (<span class="hljs-number">17</span>), length <span class="hljs-number">328</span>)<br>    <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-number">.68</span> &gt; <span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.255</span><span class="hljs-number">.67</span>: BOOTP/DHCP, Request <span class="hljs-keyword">from</span> <span class="hljs-number">00</span>:<span class="hljs-number">0</span>c:xx:xx:xx:d5, length <span class="hljs-number">300</span>, xid <span class="hljs-number">0xc9779c2a</span>, Flags [none]<br>  Client-Ethernet-Address <span class="hljs-number">00</span>:<span class="hljs-number">0</span>c:xx:xx:xx:d5<br>  Vendor-rfc1048 Extensions<br>    Magic Cookie <span class="hljs-number">0x63825363</span><br>    DHCP-Message Option <span class="hljs-number">53</span>, length <span class="hljs-number">1</span>: Request<br>    Requested-IP Option <span class="hljs-number">50</span>, length <span class="hljs-number">4</span>: <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.163</span><br>    Hostname Option <span class="hljs-number">12</span>, length <span class="hljs-number">14</span>: <span class="hljs-string">"test-ubuntu"</span><br>    Parameter-Request Option <span class="hljs-number">55</span>, length <span class="hljs-number">16</span>:<br>      Subnet-Mask, BR, Time-Zone, Default-Gateway<br>      Domain-Name, Domain-Name-Server, Option <span class="hljs-number">119</span>, Hostname<br>      Netbios-Name-Server, Netbios-Scope, MTU, Classless-Static-Route<br>      NTP, Classless-Static-Route-Microsoft, Static-Route, Option <span class="hljs-number">252</span><br><span class="hljs-number">14</span>:<span class="hljs-number">37</span>:<span class="hljs-number">50.059667</span> IP (tos <span class="hljs-number">0x10</span>, ttl <span class="hljs-number">128</span>, id <span class="hljs-number">0</span>, offset <span class="hljs-number">0</span>, flags [none], proto UDP (<span class="hljs-number">17</span>), length <span class="hljs-number">328</span>)<br>    <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-number">.68</span> &gt; <span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.255</span><span class="hljs-number">.67</span>: BOOTP/DHCP, Request <span class="hljs-keyword">from</span> <span class="hljs-number">00</span>:<span class="hljs-number">0</span>c:xx:xx:xx:d5, length <span class="hljs-number">300</span>, xid <span class="hljs-number">0xc9779c2a</span>, Flags [none]<br>  Client-Ethernet-Address <span class="hljs-number">00</span>:<span class="hljs-number">0</span>c:xx:xx:xx:d5<br>  Vendor-rfc1048 Extensions<br>    Magic Cookie <span class="hljs-number">0x63825363</span><br>    DHCP-Message Option <span class="hljs-number">53</span>, length <span class="hljs-number">1</span>: Request<br>    Requested-IP Option <span class="hljs-number">50</span>, length <span class="hljs-number">4</span>: <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.163</span><br>    Hostname Option <span class="hljs-number">12</span>, length <span class="hljs-number">14</span>: <span class="hljs-string">"test-ubuntu"</span><br>    Parameter-Request Option <span class="hljs-number">55</span>, length <span class="hljs-number">16</span>:<br>      Subnet-Mask, BR, Time-Zone, Default-Gateway<br>      Domain-Name, Domain-Name-Server, Option <span class="hljs-number">119</span>, Hostname<br>      Netbios-Name-Server, Netbios-Scope, MTU, Classless-Static-Route<br>      NTP, Classless-Static-Route-Microsoft, Static-Route, Option <span class="hljs-number">252</span><br><span class="hljs-number">14</span>:<span class="hljs-number">37</span>:<span class="hljs-number">50.060780</span> IP (tos <span class="hljs-number">0x0</span>, ttl <span class="hljs-number">64</span>, id <span class="hljs-number">53564</span>, offset <span class="hljs-number">0</span>, flags [none], proto UDP (<span class="hljs-number">17</span>), length <span class="hljs-number">339</span>)<br>    <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span><span class="hljs-number">.67</span> &gt; <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.163</span><span class="hljs-number">.68</span>: BOOTP/DHCP, Reply, length <span class="hljs-number">311</span>, xid <span class="hljs-number">0xc9779c2a</span>, Flags [none]<br>  Your-IP <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.163</span><br>  Server-IP <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span><br>  Client-Ethernet-Address <span class="hljs-number">00</span>:<span class="hljs-number">0</span>c:xx:xx:xx:d5<br>  Vendor-rfc1048 Extensions<br>    Magic Cookie <span class="hljs-number">0x63825363</span><br>    DHCP-Message Option <span class="hljs-number">53</span>, length <span class="hljs-number">1</span>: ACK<br>    Server-ID Option <span class="hljs-number">54</span>, length <span class="hljs-number">4</span>: <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span><br>    Lease-Time Option <span class="hljs-number">51</span>, length <span class="hljs-number">4</span>: <span class="hljs-number">86400</span><br>    RN Option <span class="hljs-number">58</span>, length <span class="hljs-number">4</span>: <span class="hljs-number">43200</span><br>    RB Option <span class="hljs-number">59</span>, length <span class="hljs-number">4</span>: <span class="hljs-number">75600</span><br>    Subnet-Mask Option <span class="hljs-number">1</span>, length <span class="hljs-number">4</span>: <span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.0</span><br>    BR Option <span class="hljs-number">28</span>, length <span class="hljs-number">4</span>: <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.255</span><br>    Domain-Name-Server Option <span class="hljs-number">6</span>, length <span class="hljs-number">4</span>: <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span><br>    Hostname Option <span class="hljs-number">12</span>, length <span class="hljs-number">14</span>: <span class="hljs-string">"test-ubuntu"</span><br>    T252 Option <span class="hljs-number">252</span>, length <span class="hljs-number">1</span>: <span class="hljs-number">10</span><br>    Default-Gateway Option <span class="hljs-number">3</span>, length <span class="hljs-number">4</span>: <span class="hljs-number">10.10</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span><br></code></pre></div></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了 <code>tcpdump</code> 的基本语法和使用方法，并通过一些示例来展示它强大的过滤功能。将 tcpdump 与 wireshark 进行组合可以发挥更强大的功效，本文也展示了如何优雅顺滑地结合 tcpdump 和 wireshark。如果你想了解更多的细节，可以查看 tcpdump 的 <code>man</code> 手册。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>人是怎么废掉的</title>
    <link href="/2020/02/05/%E4%BA%BA%E6%98%AF%E6%80%8E%E4%B9%88%E5%BA%9F%E6%8E%89%E7%9A%84/"/>
    <url>/2020/02/05/%E4%BA%BA%E6%98%AF%E6%80%8E%E4%B9%88%E5%BA%9F%E6%8E%89%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<p>经历了这次令人难忘的春节,我知道自己的自制力比较弱 很多自己规划好的事情 就是不愿去执行。难成大事</p><p>想写下这篇博客 给自己提个醒.</p><p>人是怎么逐渐废掉的?  我总结出以下几条</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">1.</span>不能用来提升自我的熬夜<br><span class="hljs-number">2.</span>自以为舒服的赖床<br><span class="hljs-number">3.</span>在非睡觉的时间躺着<br><span class="hljs-number">4.</span>脑海中没有危机感<br><span class="hljs-number">5.</span>打游戏或者休闲时间过度<br><span class="hljs-number">6.</span>在关键时刻的糟糕表现,事后没有进行反思<br></code></pre></div></td></tr></table></figure><h3 id="怎么自我约束"><a href="#怎么自我约束" class="headerlink" title="怎么自我约束"></a>怎么自我约束</h3><p>这是一个很难得话题,人总是惰性的。并且舒适的环境让人停止思考或者不去思考<br>我的执行计划</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">每个月制定中短期目标,每周制定短期目标<br>每天规定自己的起床和睡觉时间,早上误差在<span class="hljs-number">5</span>分钟内。晚上睡觉误差在<span class="hljs-number">30</span>分钟内<br>每天晚上给自己的行为打分.<br>不看鸡汤.<br></code></pre></div></td></tr></table></figure><p>目前还没有什么好的方法约束自己,先做一个短期的尝试.记录到此博客</p><h3 id="尝试一"><a href="#尝试一" class="headerlink" title="尝试一"></a>尝试一</h3><p>开始时间 2020-02-05<br>尝试方法: 靠自我打分以及危机感、反思 自我约束。</p><h3 id="失败"><a href="#失败" class="headerlink" title="失败"></a>失败</h3><p>结束时间 2020-02-15<br>玩的更开心了。丝毫没约束到自己。</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建我的世界私服</title>
    <link href="/2020/01/27/%E6%90%AD%E5%BB%BA%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C%E7%A7%81%E6%9C%8D/"/>
    <url>/2020/01/27/%E6%90%AD%E5%BB%BA%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C%E7%A7%81%E6%9C%8D/</url>
    
    <content type="html"><![CDATA[<p>随着社会的进步,手动安装部署mc服务器已经落伍了. 现在用docker很好的能解决安装问题。</p><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>1.安装docker </p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">systemctl   <span class="hljs-keyword">stop</span> firewalld &amp;&amp; systemctl   <span class="hljs-keyword">disable</span>  firewalld<br>swapoff -a<br>sed -i <span class="hljs-string">'s#SELINUX=enforcing#SELINUX=disabled#'</span> /etc/selinux/config<br>yum <span class="hljs-keyword">install</span> -y yum-utils device-mapper-persistent-<span class="hljs-keyword">data</span> lvm2<br>yum-config-manager <span class="hljs-comment">--add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br>yum -y <span class="hljs-keyword">install</span> docker-ce<span class="hljs-number">-18.06</span><span class="hljs-number">.0</span>.ce<span class="hljs-number">-3.</span>el7  vim wget  tcpdump nload<br>iptables -P FORWARD <span class="hljs-keyword">ACCEPT</span><br>systemctl <span class="hljs-keyword">start</span> docker &amp;&amp; systemctl <span class="hljs-keyword">enable</span> docker<br></code></pre></div></td></tr></table></figure><p>2.搜索mc镜像</p><p><img src="/img/newimg/006tNbRwgy1gbbdw5dyo2j31rv0u01ky.jpg" srcset="/img/loading.gif" alt=""></p><p>这次我们使用的是kitematic/minecraft:latest 这个镜像</p><p>3.部署mc服务</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">mkdir</span>  /<span class="hljs-class"><span class="hljs-keyword">data</span> </span><br><span class="hljs-title">docker</span> run -itd  -p <span class="hljs-number">25565</span>:<span class="hljs-number">25565</span>  -v /<span class="hljs-class"><span class="hljs-keyword">data</span>:/<span class="hljs-keyword">data</span>  kitematic/minecraft:latest</span><br></code></pre></div></td></tr></table></figure><p>4.由于是私服,需要关闭服务器的认证</p><figure class="highlight axapta"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs axapta">vim  <span class="hljs-keyword">server</span>.properties<br></code></pre></div></td></tr></table></figure><p><img src="/img/newimg/006tNbRwgy1gbbdzykxnoj30jk1080xw.jpg" srcset="/img/loading.gif" alt=""></p><p>重启这个容器 </p><p>docker restart xxxxx</p><p>连接即可。</p><p>案例<br>Docker搭建我的世界私服并开启Forge插件</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-comment">//通过-e TYPE=FORGE在命令行中添加来启用Forge服务器模式</span><br><span class="hljs-comment">//默认情况下，容器将运行Forge服务器的RECOMMENDED版本， 但您也可以选择使用运行特定版本。-e FORGEVERSION=10.13.4.1448</span><br>docker run -d -p <span class="hljs-number">25565</span>:<span class="hljs-number">25565</span> \<br>-v /Users/litong/Desktop/Docker/Minecraft:/data \<br>-e EULA=TRUE \<br>-e VERSION=<span class="hljs-number">1.12</span><span class="hljs-number">.2</span> \<br>-e TYPE=FORGE \<br>--name=mc \<br>itzg/minecraft-server<br><br><span class="hljs-comment">//要从自定义位置（例如您自己的文件存储库）下载Forge安装程序</span><br>docker run -d -p <span class="hljs-number">25565</span>:<span class="hljs-number">25565</span>  -v /root/桌面/Minecraft:/data -e EULA=TRUE -e VERSION=<span class="hljs-number">1.12</span><span class="hljs-number">.2</span> -e TYPE=FORGE -e FORGE_INSTALLER_URL=http:<span class="hljs-comment">//HOST/forge-1.11.2-13.20.0.2228-installer.jar --name=mc itzg/minecraft-server</span><br><br><span class="hljs-comment">//使用预下载的Forge安装程序，将其放置在附件/data目录中，并使用来指定安装程序文件的名称FORGE_INSTALLER</span><br>docker run -d -p <span class="hljs-number">25565</span>:<span class="hljs-number">25565</span>  -v /root/桌面/Minecraft:/data -e EULA=TRUE -e VERSION=<span class="hljs-number">1.12</span><span class="hljs-number">.2</span> -e TYPE=FORGE -e FORGE_INSTALLER=forge<span class="hljs-number">-1.12</span><span class="hljs-number">.2</span><span class="hljs-number">-14.23</span><span class="hljs-number">.5</span><span class="hljs-number">.2768</span>-installer.jar --name=mc itzg/minecraft-server<br></code></pre></div></td></tr></table></figure><p>设置管理员</p><figure class="highlight vala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vala"><span class="hljs-meta"># 打开ops.json文件，添加管理员</span><br>[<br>  &#123;<br>    <span class="hljs-string">"uuid"</span>: <span class="hljs-string">"用户1的uuid"</span>,<br>    <span class="hljs-string">"name"</span>: <span class="hljs-string">"用户1名称"</span>,<br>    <span class="hljs-string">"level"</span>: <span class="hljs-number">4</span>,<br>    <span class="hljs-string">"bypassesPlayerLimit"</span>: <span class="hljs-literal">false</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-string">"uuid"</span>: <span class="hljs-string">"用户2的uuid"</span>,<br>    <span class="hljs-string">"name"</span>: <span class="hljs-string">"用户2名称"</span>,<br>    <span class="hljs-string">"level"</span>: <span class="hljs-number">4</span>,<br>    <span class="hljs-string">"bypassesPlayerLimit"</span>: <span class="hljs-literal">false</span><br>  &#125;<br>]<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu server连WiFi</title>
    <link href="/2020/01/24/ubuntu-server%E8%BF%9EWiFi/"/>
    <url>/2020/01/24/ubuntu-server%E8%BF%9EWiFi/</url>
    
    <content type="html"><![CDATA[<p>1、首先使用wpa_passphrase生成无线密钥</p><figure class="highlight autohotkey"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs autohotkey">sudo -i <br>wp<span class="hljs-built_in">a_passphrase</span> 无线名称 密码 &gt; /etc/wp<span class="hljs-built_in">a_supplicant</span>.conf<br></code></pre></div></td></tr></table></figure><p>2、接下来编辑 /etc/wpa_supplicant.conf</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros"><span class="hljs-attribute">ctrl_interface</span>=/var/run/wpa_supplicant<br><span class="hljs-attribute">ctrl_interface_group</span>=0<br><span class="hljs-attribute">ap_scan</span>=1<br>network=&#123;<br>        <span class="hljs-attribute">ssid</span>=<span class="hljs-string">"OpenWrt_2.4G_4680A1"</span><br>        <span class="hljs-attribute">proto</span>=RSN<br>        <span class="hljs-attribute">key_mgmt</span>=WPA-PSK<br>        <span class="hljs-attribute">pairwise</span>=CCMP TKIP<br>        <span class="hljs-attribute">group</span>=CCMP TKIP<br>        <span class="hljs-attribute">psk</span>=0192c3b3469fcf872387c0e069fee5731ce7f8782654e1a5caa0c165700e76c8<br>&#125;<br><br><br>network=&#123;<br>        <span class="hljs-attribute">ssid</span>=<span class="hljs-string">"my_network"</span>   #注意ssid名区分大小写。<br>        <span class="hljs-attribute">proto</span>=RSN           #Robust Security Network:强健安全网络，表示这个网络配置比WEP模式要更安全。<br>        <span class="hljs-attribute">key_mgmt</span>=WPA-PSK    #请无论你是使用WPA-PSK，WPA2-PSK，都请在这里输入 WPA-PSK。这在wpa_supplicant看来WPA-PSK，WPA2-PSK都是 WPA-PSK<br>        <span class="hljs-attribute">pairwise</span>=CCMP TKIP  #关键点，wpa_supplicant目前还不认AES的加密标准<br>        <span class="hljs-attribute">group</span>=CCMP TKIP     #同上<br>        <span class="hljs-attribute">psk</span>=7b271c9a7c8a6ac07d12403a1f0792d7d92b5957ff8dfd56481ced43ec6a6515 #wpa_supplicant算出来的加密密码。<br></code></pre></div></td></tr></table></figure><p>3、以上配置文件设置完成后，接下来手动应用配置</p><figure class="highlight autohotkey"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs autohotkey">sudo wp<span class="hljs-built_in">a_supplicant</span> -B -i wlan0 -c /etc/wp<span class="hljs-built_in">a_supplicant</span>.conf<br>sudo dhclient wlan0<br></code></pre></div></td></tr></table></figure><p>4、为了开机自动开启wifi，需要将启动脚本加到自动执行服务中，首先在/etc/init.d/(任意目录)中写上需要开机启动的脚本</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">➜  ~ cat /etc/init.d/wifi.sh<br><span class="hljs-meta">#!/bin/bash</span><br>sudo wpa_supplicant -i wlan0  -c /etc/wpa_supplicant.conf -B<br>sudo dhclient  wlan0<br></code></pre></div></td></tr></table></figure><p>在/etc/rc.local中写入以下</p><p>➜  ~ cat /etc/rc.local<br>#!/bin/bash<br>sh  /etc/init.d/wifi.sh<br>exit 0<br>➜  ~ chmod +x /etc/rc.local</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros"><br>然后在 /etc/systemd<span class="hljs-built_in">/system </span>目录中写上开机启动的systemd文件。<br></code></pre></div></td></tr></table></figure><p>➜  system cat rc-local.service<br>[Unit]<br>Description=/etc/rc.local Compatibility<br>ConditionPathExists=/etc/rc.local</p><p>[Service]<br>Type=forking<br>ExecStart=/etc/rc.local start<br>TimeoutSec=0<br>StandardOutput=tty<br>RemainAfterExit=yes<br>SysVStartPriority=99</p><p>[Install]<br>WantedBy=multi-user.target</p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><br>执行 systemctl enable  rc-local<br>重启后可以发现,已经能自动连上wifi,并且 systemd能看到已经启动<br>![](/img/<span class="hljs-keyword">new</span><span class="hljs-type">img</span>/<span class="hljs-number">006</span>tNbRwgy1gb7rgdj73cj31mu0f6e3g.jpg)<br><br>![](/img/<span class="hljs-keyword">new</span><span class="hljs-type">img</span>/<span class="hljs-number">006</span>tNbRwgy1gb7rgxzu1mj31qu0psqv5.jpg)<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>永生的代价</title>
    <link href="/2020/01/23/%E6%B0%B8%E7%94%9F%E7%9A%84%E4%BB%A3%E4%BB%B7/"/>
    <url>/2020/01/23/%E6%B0%B8%E7%94%9F%E7%9A%84%E4%BB%A3%E4%BB%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="永生，蝙蝠侠，冠状病毒"><a href="#永生，蝙蝠侠，冠状病毒" class="headerlink" title="永生，蝙蝠侠，冠状病毒"></a>永生，蝙蝠侠，冠状病毒</h2><p>公元一世纪的时候，希腊的普鲁塔克提出了一个问题：如果忒修斯船上的零件被逐渐替换，直到所有的零件都不是原来的零件，那么这艘船还是原来的那艘船吗？</p><p>这就是人类历史上的忒修斯悖论，其实里面有一个隐藏的彩蛋，那是永生的秘密。</p><p>天下武功唯快不破，一个人体内的衰老细胞只要更新的足够快，宛若新零件换旧零件一般，那么他就能躲过死神的杀猪刀，永远活下去。</p><p>然而，地球上的碳基猴子有个小小的问题，那就是细胞DNA分裂复制的时候，都会有出错的概率，虽然是极低的，但架不住细胞数量大，大约是十来次更新之后，也就是人类五六十岁的时候，DNA就出幺蛾子了，碱基对丢失或者错搭，最后表达出来的蛋白质都是歪瓜裂枣，这可就把人体细胞吓尿了。</p><p>算了，管球他呢，只要能永生，管他洪水滔天，于是一小撮别有用心的细胞黑化了，开始无限复制，无限争夺养分，真的永生了，而这，便是癌细胞的前传。</p><p>如果有一天，灭世的核弹来临后，在核辐射里，昆虫和啮齿类动物一定能活下来，因为它们足够小，不挑食，屎都能吃，还特别能生孩子。</p><p>蝙蝠也一样会活的很好，因为它们是哺乳动物里唯一的空军，吃昆虫就能活下去，在夜空里有声呐这种外挂，夜战能力吊锤猫头鹰夜枭这种恐龙后裔，几乎没有什么天敌了。</p><p>它们占据了天空后，生活的是如此滋润，以至于种群数量高达地球胎生动物的五分之一，随便找个大点的山洞里，就能发现里面密密麻麻倒挂着上百万只蝙蝠，彻底碾压了碳基猴子们。</p><p>在这一刻，达尔文一脸欣慰的慈父笑，他说，只要蝙蝠的数量管够，就不怕变异，蝙蝠侠一定会在哥谭市出现的。</p><p>是的，大约是在五百万年前，蝙蝠真他妈的变异了，它们的飞行特性导致了超高的新陈代谢率，天天浑身发烧40度，搁人身上，早特么的烧成智障挂了，但它们不会，就像没事人一样过了五百万年。</p><p>这种超高的代谢率意味着，蝙蝠在进行着普通哺乳动物难以想象的细胞快速更新，但前面说过，细胞更新是有定数的，次数多了，一般生物体的DNA复制肯定会出错。</p><p>然而蝙蝠经过千百万年高烧不退的进化，它们奇迹般的拥有了DNA损伤修复超能力，几乎不会出错，这导致了蝙蝠们超常的寿命，还很少得癌。</p><p>同时千万年的持续高烧还带来了蝙蝠免疫系统对炎症的持续应答，它们的身体时刻准备御敌，不像人类，不感染细菌病毒，白细胞和t细胞根本不会上班。</p><p>这些年，无数人被广告里的氧化衰老吓怕了，不过说实话，氧气和线粒体的氧化的确是人体衰老的元凶之一，因为人的细胞零件更新慢，抵抗不了氧化的侵蚀。</p><p>但蝙蝠是个奇葩，它们的细胞根本不怕氧化，天天活蹦乱跳的躁，按比例来换算，比王八都活的好。</p><p>于是乎，大自然的筛选剃刀无意间选出了高烧不退还在夜空下蹦迪、氧化应激水平超高、DNA损伤修复能力超强、固有免疫应答系统24小时不关机的怪物，什么埃博拉、马尔堡、狂犬病、SARS等病毒，完全干不死蝙蝠。</p><p>地球上最恐怖的病毒罐子就此诞生了，多少病毒在蝙蝠身上平静的共生着，谁也不知道，反正我们这些碳基猴子们，就像土鳖战列舰一样，无奈的看着蝙蝠在全球飞，往下扔病毒炸弹。</p><p>是的，达尔文说对了，蝙蝠侠真的出现了，不过它已经跟恶魔墨菲斯托签订了灵魂契约，换来了永生不死的能力，最后连小丑的工作都抢了，在非洲，食果蝙蝠的粪便沾染了水果，后来当地一个小孩吃了那个水果，埃博拉的魔盒就此打开。</p><p>时间的杀猪刀在轮回桥上，如同菜刀砍电线一般，一路火花带闪电，到了2002年，云南的中华菊头蝠在果子狸头上来了一泡屎，随后，那一年的冠状病毒SARS给无数头铁的人上了终身难忘的一课。</p><p>今年，它又来了，带着新的冠状病毒，在东方的长江畔低声吟唱着进化的悲怆奏鸣曲。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>穷逼K8S用户的负载均衡LB支持</title>
    <link href="/2020/01/20/%E7%A9%B7%E9%80%BCK8S%E7%94%A8%E6%88%B7%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1LB%E6%94%AF%E6%8C%81/"/>
    <url>/2020/01/20/%E7%A9%B7%E9%80%BCK8S%E7%94%A8%E6%88%B7%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1LB%E6%94%AF%E6%8C%81/</url>
    
    <content type="html"><![CDATA[<h3 id="背景项目"><a href="#背景项目" class="headerlink" title="背景项目"></a>背景项目</h3><p>很多公司使用k8s都是私有云方式,在没钱玩NMB的社会.连k8s都会歧视你。 服务的暴露方式只有nodeport、ExternalIP(直接使用主机网络)和ingress。剥夺了LoadBalance模式的权利</p><h3 id="metallb-简介"><a href="#metallb-简介" class="headerlink" title="metallb 简介"></a>metallb 简介</h3><p>这里简单介绍下它的实现原理，具体可以参考<a href="https://metallb.universe.tf/" target="_blank" rel="noopener">metallb官网</a>，文档非常简洁、清晰。目前有如下的使用限制：</p><blockquote><p>Kubernetes v1.9.0版本以上，暂不支持ipvs模式<br>支持网络组件 (flannel/weave/romana), calico 部分支持<br>layer2和bgp两种模式，其中bgp模式需要外部网络设备支持bgp协议</p></blockquote><p>metallb主要实现了两个功能：地址分配和对外宣告</p><blockquote><p>地址分配：需要向网络管理员申请一段ip地址，如果是layer2模式需要这段地址与node节点地址同个网段（同一个二层）；如果是bgp模式没有这个限制。<br>对外宣告：layer2模式使用arp协议，利用节点的mac额外宣告一个loadbalancer的ip（同mac多ip）；bgp模式下节点利用bgp协议与外部网络设备建立邻居，宣告loadbalancer的地址段给外部网络。</p></blockquote><h3 id="演示环境信息"><a href="#演示环境信息" class="headerlink" title="演示环境信息"></a>演示环境信息</h3><p><img src="/img/newimg/006tNbRwgy1gb4ghrhg6ij31xo068q9o.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="部署过程"><a href="#部署过程" class="headerlink" title="部署过程"></a>部署过程</h3><p>注: 因bgp模式需要外部路由器的支持，这里主要选用layer2模式（如需选择bgp模式，相应修改roles/cluster-addon/templates/metallb/bgp.yaml.j2）。</p><blockquote><p>Metallb 支持 Helm 和 YAML 两种安装方法，这里我们使用第二种：</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">wget https:<span class="hljs-comment">//raw.githubusercontent.com/google/metallb/v0.7.3/manifests/metallb.yaml</span><br>kubectl apply -f metallb.yaml<br>.<br>.<br>.<br>kubectl <span class="hljs-keyword">get</span> pod -n metallb-system  -o wide<br><br>NAME                          READY   STATUS    RESTARTS   AGE   IP               NODE     <br>controller<span class="hljs-number">-67496974</span>d9-wpgw8   <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">75</span>m   <span class="hljs-number">100.108</span><span class="hljs-number">.11</span><span class="hljs-number">.251</span>   node2    <br>speaker<span class="hljs-number">-4</span>cscj                 <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">75</span>m   <span class="hljs-number">10.6</span><span class="hljs-number">.204</span><span class="hljs-number">.2</span>       node1    <br>speaker<span class="hljs-number">-9</span>s55h                 <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">75</span>m   <span class="hljs-number">10.6</span><span class="hljs-number">.204</span><span class="hljs-number">.3</span>       node2    <br>speaker-kr2bm                 <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">75</span>m   <span class="hljs-number">10.6</span><span class="hljs-number">.204</span><span class="hljs-number">.1</span>       master<br></code></pre></div></td></tr></table></figure><p>kubectl get daemonset -n metallb-system</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">NAME      DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR                 <br>speaker   <span class="hljs-number">3</span>         <span class="hljs-number">3</span>         <span class="hljs-number">3</span>       <span class="hljs-number">3</span>            <span class="hljs-number">3</span>           beta.kubernetes.io/os=linux<br></code></pre></div></td></tr></table></figure><p>kubectl get deployment -n metallb-system</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">NAME         READY   UP-TO-DATE   AVAILABLE   AGE<br>controller   <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     <span class="hljs-number">1</span>            <span class="hljs-number">1</span>           <span class="hljs-number">76</span>m<br></code></pre></div></td></tr></table></figure><p>创建config.yaml提供IP池<br>wget <a href="https://raw.githubusercontent.com/google/metallb/v0.7.3/manifests/example-layer2-config.yaml" target="_blank" rel="noopener">https://raw.githubusercontent.com/google/metallb/v0.7.3/manifests/example-layer2-config.yaml</a><br>修改ip地址池和集群节点网段相同</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">[centos@k8s-master ~]$ vim example-layer2-config.yaml <br><br>apiVersion: v1<br>kind: ConfigMap<br>metadata:<br>  namespace: metallb-system<br>  name: config<br>data:<br>  config: |<br>    address-pools:<br>    - name: default<br>      protocol: layer2<br>      addresses:<br>      - 10.6.204.20-10.6.204.22<br></code></pre></div></td></tr></table></figure><p>执行yaml文件<br>kubectl apply -f example-layer2-config.yaml</p><p>创建后端应用和服务测试</p><figure class="highlight elixir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>wget <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/raw.githubusercontent.com/google</span><span class="hljs-regexp">/metallb/master</span><span class="hljs-regexp">/manifests/tutorial</span><span class="hljs-number">-2</span>.yaml<br><span class="hljs-variable">$ </span>kubectl apply -f tutorial<span class="hljs-number">-2</span>.yaml<br></code></pre></div></td></tr></table></figure><p>查看svc对象</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">kubectl <span class="hljs-keyword">get</span> service <br><br>NAME                TYPE           CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE<br>front-end-service   NodePort       <span class="hljs-number">10.101</span><span class="hljs-number">.75</span><span class="hljs-number">.133</span>    &lt;none&gt;        <span class="hljs-number">80</span>:<span class="hljs-number">31402</span>/TCP     <span class="hljs-number">48</span>d<br>gogs                NodePort       <span class="hljs-number">10.104</span><span class="hljs-number">.31</span><span class="hljs-number">.59</span>     &lt;none&gt;        <span class="hljs-number">3000</span>:<span class="hljs-number">30064</span>/TCP   <span class="hljs-number">19</span>d<br>kubernetes          ClusterIP      <span class="hljs-number">10.96</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>        &lt;none&gt;        <span class="hljs-number">443</span>/TCP          <span class="hljs-number">54</span>d<br>nexus3              NodePort       <span class="hljs-number">10.98</span><span class="hljs-number">.65</span><span class="hljs-number">.125</span>     &lt;none&gt;        <span class="hljs-number">8082</span>:<span class="hljs-number">31899</span>/TCP   <span class="hljs-number">8</span>h<br>nginx               LoadBalancer   <span class="hljs-number">10.98</span><span class="hljs-number">.137</span><span class="hljs-number">.237</span>    <span class="hljs-number">10.6</span><span class="hljs-number">.204</span><span class="hljs-number">.20</span>   <span class="hljs-number">80</span>:<span class="hljs-number">31909</span>/TCP     <span class="hljs-number">28</span>m<br>nginx-random        NodePort       <span class="hljs-number">10.111</span><span class="hljs-number">.254</span><span class="hljs-number">.203</span>   &lt;none&gt;        <span class="hljs-number">80</span>:<span class="hljs-number">31691</span>/TCP     <span class="hljs-number">48</span>d<br></code></pre></div></td></tr></table></figure><p>在集群内访问 10.6.204.20:80</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">curl 10.6.204.20<br><br><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Welcome to nginx!<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>    body &#123;<br>        width: 35em;<br>        margin: 0 auto;<br>        font-family: Tahoma, Verdana, Arial, sans-serif;<br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Welcome to nginx!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>If you see this page, the nginx web server is successfully installed and<br>working. Further configuration is required.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>For online documentation and support please refer to<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://nginx.org/"</span>&gt;</span>nginx.org<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>.<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>Commercial support is available at<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://nginx.com/"</span>&gt;</span>nginx.com<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>Thank you for using nginx.<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>在集群外部访问<br><img src="/img/newimg/006tNbRwgy1gb4goj0mqmj31vs0kgn1k.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>kube-dns与CoreDNS有何差异？</title>
    <link href="/2020/01/20/kube-dns%E4%B8%8ECoreDNS%E6%9C%89%E4%BD%95%E5%B7%AE%E5%BC%82%EF%BC%9F/"/>
    <url>/2020/01/20/kube-dns%E4%B8%8ECoreDNS%E6%9C%89%E4%BD%95%E5%B7%AE%E5%BC%82%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>使用kube-dns集群插件，基于DNS的服务发现已成为Kubernetes的一部分。这通常很有效，但是对于实施的可靠性、灵活性和安全性存在一些担忧。</p><p>CoreDNS是一个通用的、权威的DNS服务器，提供与Kubernetes后向兼容但可扩展的集成。它解决了kube-dns所遇到的问题，并提供了许多独特的功能，可以解决各种各样的用例。</p><p>在本文中，你将了解kube-dns和CoreDNS的实施差异，以及CoreDNS提供的一些有用的扩展。</p><h3 id="实施差异"><a href="#实施差异" class="headerlink" title="实施差异"></a>实施差异</h3><p>在kube-dns中，一个pod内使用了数个容器：kubedns、dnsmasq和sidecar。 kubedns容器监视Kubernetes API并基于Kubernetes DNS规范提供DNS记录，dnsmasq提供缓存和存根域支持，sidecar提供指标和健康检查。</p><p>此设置会导致一些问题随着时间的推移而出现。首先，dnsmasq中的安全漏洞导致过去需要发布Kubernetes安全补丁。此外，由于dnsmasq处理存根域，但kubedns处理External Services，因此你无法在外部服务中使用存根域，这非常限制该功能（参阅dns＃131）。</p><p>在CoreDNS中，所有这些功能都在一个容器中完成——该容器运行用Go编写的进程。启用的不同插件来复制（并增强）kube-dns中的功能。</p><h3 id="配置CoreDNS"><a href="#配置CoreDNS" class="headerlink" title="配置CoreDNS"></a>配置CoreDNS</h3><p>在kube-dns中，你可以修改ConfigMap以改变服务发现的行为。这允许添加诸如提供服务存根域、修改上游名称服务器以及启用联合之类的功能。</p><p>在CoreDNS中，你同样可以修改CoreDNS Corefile的ConfigMap以更改服务发现的工作方式。Corefile配置提供了比kube-dns更多的选项，因为它是CoreDNS用于配置其所有功能（甚至是那些与Kubernetes无关的功能）的主要配置文件。</p><p>使用kubeadm从kube-dns升级到CoreDNS时，现有的ConfigMap将用于为你生成自定义Corefile，包括存根域、联合和上游名称服务器的所有配置。有关更多详细信息，请参阅《使用CoreDNS进行服务发现》。</p><h3 id="bug修复和增强功能"><a href="#bug修复和增强功能" class="headerlink" title="bug修复和增强功能"></a>bug修复和增强功能</h3><p>kube-dns有几个还没解决的问题，而这些问题在CoreDNS中得到解决，无论是默认配置还是某些自定义配置。</p><p>——dns＃55：kube-dns的自定义DNS条目可以通过使用kubernetes插件中的“fallthrough”机制、使用重写插件或者仅使用不同的插件（如文件插件）提供子区域来处理。</p><p>——dns＃116：只有一个A记录集用于具有单个主机名的pod无头服务。此问题已修复，无需任何其他配置。</p><p>——dns＃131： externalName不使用stubDomains设置。此问题已修复，无需任何其他配置。</p><p>——dns＃167：启用skyDNS循环A / AAAA记录。可以使用负载均衡插件配置等效功能。</p><p>——dns＃190：kube-dns无法以非root用户身份运行。现在通过使用非默认镜像解决了此问题，但在将来的版本中它将成为默认的CoreDNS行为。</p><p>——dns＃232：将pod hostname修复为dns srv记录的podname，这是通过下面描述的“endpoint_pod_names”功能支持的增强功能。</p><h3 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h3><p>默认CoreDNS配置的功能行为与kube-dns相同。但是，你需要知道的一个区别是发布的指标不同。在kube-dns中，你可以获得单独的dnsmasq和kubedns（skydns）指标。在CoreDNS中，有一组完全不同的指标，因为它只是一个单一的进程。你可以在CoreDNS Prometheus插件页面上找到有关这些指标的更多详细信息。</p><h3 id="一些特殊功能"><a href="#一些特殊功能" class="headerlink" title="一些特殊功能"></a>一些特殊功能</h3><p>标准CoreDNS Kubernetes配置旨在向后兼容之前的kube-dns行为。但是，通过一些配置更改，CoreDNS可以允许你修改DNS服务发现在集群中的工作方式。许多这样的功能旨在仍然符合Kubernetes DNS规范：它们增强了功能，但保持向后兼容。由于CoreDNS不仅仅是为Kubernetes而设计的，而是一个通用的DNS服务器，因此除了该规范之外，你还可以做很多事情。</p><h3 id="pod-verified模式"><a href="#pod-verified模式" class="headerlink" title="pod verified模式"></a>pod verified模式</h3><p>在kube-dns中，pod名称记录是“假的”。也就是说，任何“a-b-c-d.namespace.pod.cluster.local”查询都将返回IP地址“a.b.c.d”。在某些情况下，这会削弱TLS提供的身份保证。因此，CoreDNS提供“pods verified”模式，如果指定的命名空间中有一个具有该IP地址的pod，它将仅返回IP地址。</p><h3 id="端点名称基于pod名称"><a href="#端点名称基于pod名称" class="headerlink" title="端点名称基于pod名称"></a>端点名称基于pod名称</h3><p>在kube-dns中，当使用无头服务时，你可以使用SRV请求来获取服务的所有端点的列表：</p><p>dnstools# host -t srv headless</p><p>headless.default.svc.cluster.local has SRV record 10 33 0 6234396237313665.headless.default.svc.cluster.local.</p><p>headless.default.svc.cluster.local has SRV record 10 33 0 6662363165353239.headless.default.svc.cluster.local.</p><p>headless.default.svc.cluster.local has SRV record 10 33 0 6338633437303230.headless.default.svc.cluster.local.</p><p>dnstools#</p><p>但是，端点DNS名称（出于实用目的）是随机的。在CoreDNS中，默认情况下，你将根据端点的IP地址获取端点DNS名称：</p><p>dnstools# host -t srv headless</p><p>headless.default.svc.cluster.local has SRV record 0 25 443 172-17-0-14.headless.default.svc.cluster.local.</p><p>headless.default.svc.cluster.local has SRV record 0 25 443 172-17-0-18.headless.default.svc.cluster.local.</p><p>headless.default.svc.cluster.local has SRV record 0 25 443 172-17-0-4.headless.default.svc.cluster.local.</p><p>headless.default.svc.cluster.local has SRV record 0 25 443 172-17-0-9.headless.default.svc.cluster.local.</p><p>对于某些应用程序，需要为此设置pod名称，而不是pod IP地址（例如，请参阅kubernetes＃47992和coredns＃1190）。要在CoreDNS中启用此功能，请在Corefile中指定“endpoint_pod_names”选项，结果如下：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><br><span class="hljs-selector-tag">dnstools</span># <span class="hljs-selector-tag">host</span> <span class="hljs-selector-tag">-t</span> <span class="hljs-selector-tag">srv</span> <span class="hljs-selector-tag">headless</span><br><br><span class="hljs-selector-tag">headless</span><span class="hljs-selector-class">.default</span><span class="hljs-selector-class">.svc</span><span class="hljs-selector-class">.cluster</span><span class="hljs-selector-class">.local</span> <span class="hljs-selector-tag">has</span> <span class="hljs-selector-tag">SRV</span> <span class="hljs-selector-tag">record</span> 0 25 443 <span class="hljs-selector-tag">headless-65bb4c479f-qv84p</span><span class="hljs-selector-class">.headless</span><span class="hljs-selector-class">.default</span><span class="hljs-selector-class">.svc</span><span class="hljs-selector-class">.cluster</span><span class="hljs-selector-class">.local</span>.<br><br><span class="hljs-selector-tag">headless</span><span class="hljs-selector-class">.default</span><span class="hljs-selector-class">.svc</span><span class="hljs-selector-class">.cluster</span><span class="hljs-selector-class">.local</span> <span class="hljs-selector-tag">has</span> <span class="hljs-selector-tag">SRV</span> <span class="hljs-selector-tag">record</span> 0 25 443 <span class="hljs-selector-tag">headless-65bb4c479f-zc8lx</span><span class="hljs-selector-class">.headless</span><span class="hljs-selector-class">.default</span><span class="hljs-selector-class">.svc</span><span class="hljs-selector-class">.cluster</span><span class="hljs-selector-class">.local</span>.<br><br><span class="hljs-selector-tag">headless</span><span class="hljs-selector-class">.default</span><span class="hljs-selector-class">.svc</span><span class="hljs-selector-class">.cluster</span><span class="hljs-selector-class">.local</span> <span class="hljs-selector-tag">has</span> <span class="hljs-selector-tag">SRV</span> <span class="hljs-selector-tag">record</span> 0 25 443 <span class="hljs-selector-tag">headless-65bb4c479f-q7lf2</span><span class="hljs-selector-class">.headless</span><span class="hljs-selector-class">.default</span><span class="hljs-selector-class">.svc</span><span class="hljs-selector-class">.cluster</span><span class="hljs-selector-class">.local</span>.<br><br><span class="hljs-selector-tag">headless</span><span class="hljs-selector-class">.default</span><span class="hljs-selector-class">.svc</span><span class="hljs-selector-class">.cluster</span><span class="hljs-selector-class">.local</span> <span class="hljs-selector-tag">has</span> <span class="hljs-selector-tag">SRV</span> <span class="hljs-selector-tag">record</span> 0 25 443 <span class="hljs-selector-tag">headless-65bb4c479f-566rt</span><span class="hljs-selector-class">.headless</span><span class="hljs-selector-class">.default</span><span class="hljs-selector-class">.svc</span><span class="hljs-selector-class">.cluster</span><span class="hljs-selector-class">.local</span>.<br></code></pre></div></td></tr></table></figure><h3 id="Autopath"><a href="#Autopath" class="headerlink" title="Autopath"></a>Autopath</h3><p>CoreDNS还具有一项特殊功能，可以改善外部名称DNS请求的延迟。 在Kubernetes中，pod的DNS搜索路径指定了一长串后缀。这样可以在请求集群中的服务时使用短名称，例如上面的“headless”，而不是“headless.default.svc.cluster.local”。 但是，当请求外部名称（例如“infoblox.com”时 ），客户端进行了好几次无效的DNS查询，每次都需要从客户端到kube-dns的往返：</p><p>infoblox.com.default.svc.cluster.local -&gt; NXDOMAIN<br>infoblox.com.svc.cluster.local -&gt; NXDOMAIN<br>infoblox.com.cluster.local -&gt; NXDOMAIN<br>infoblox.com.your-internal-domain.com -&gt; NXDOMAIN<br>infoblox.com -&gt; returns a valid record<br>在CoreDNS中，可以启用一个名为autopath的可选功能。该功能将导致在服务器中跟踪此搜索路径。也就是说，CoreDNS将从源IP地址中找出客户端pod所在的命名空间，并遍历此搜索列表，直到获得有效答案。由于前三个在CoreDNS内部解析，因此它会切断客户端和服务器之间的所有来回，从而减少延迟。</p><h3 id="其他Kubernetes特定功能"><a href="#其他Kubernetes特定功能" class="headerlink" title="其他Kubernetes特定功能"></a>其他Kubernetes特定功能</h3><p>在CoreDNS中，你可以使用标准DNS区域传输来导出整个DNS记录集。这对于调试服务以及将集群区域导入其他DNS服务器非常有用。</p><p>你还可以按命名空间或标签选择器进行过滤。这可以允许你运行特定的CoreDNS实例——这些实例仅服务于与过滤器匹配的记录，通过DNS公开一组有限的服务。</p><h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>除了上述功能外，CoreDNS还可以轻松扩展。可以构建CoreDNS的自定义版本。例如，此功能已用于扩展CoreDNS以使用未绑定插件进行递归解析，使用pdsql插件直接从数据库服务记录，并允许多个CoreDNS实例与redisc插件共享公共2级缓存。</p><p>还添加了许多其他有趣的扩展——你可以在CoreDNS站点的External Plugins页面上找到它们。Kubernetes和Istio用户真正感兴趣的是kubernetai插件，它允许单个CoreDNS实例连接到多个Kubernetes集群并提供跨所有这些集群的服务发现。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>coredns添加自定义DNS解析记录</title>
    <link href="/2020/01/20/coredns%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89DNS%E8%A7%A3%E6%9E%90%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/01/20/coredns%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89DNS%E8%A7%A3%E6%9E%90%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>coredns 自带 hosts 插件， 允许像配置 hosts 一样配置自定义 DNS 解析，修改 <code>kube-system</code> 中 <code>configMap</code> 的 <code>coredns</code> 添加如下设置即可。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">hosts &#123;<br>    <span class="hljs-number">172.21</span><span class="hljs-number">.91</span><span class="hljs-number">.28</span> cache.redis<br>    <span class="hljs-number">172.21</span><span class="hljs-number">.91</span><span class="hljs-number">.28</span> persistent.redis<br>      <br>    fallthrough<br>&#125;<br></code></pre></div></td></tr></table></figure><p>修改后文件如下（根据kubernetes 安装方式不同，可能有些许差别）</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">.:53 &#123;<br>    errors<br>    health<br>    kubernetes cluster.local in-addr.arpa ip6.arpa &#123;<br>       pods insecure<br>       upstream<br>       fallthrough in-addr.arpa ip6.arpa<br>    &#125;<br>    hosts &#123;<br>        172.21.91.28 cache.redis<br>        172.21.91.28 persistent.redis<br>          <br>        fallthrough<br>    &#125;<br>    prometheus :9153<br>   <span class="hljs-built_in"> proxy </span>. /etc/resolv.conf<br>    cache 30<br>    loop<br>    reload<br>    loadbalance<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="修改实践"><a href="#修改实践" class="headerlink" title="修改实践"></a>修改实践</h2><h3 id="找到kube-system命名空间的名称为coredns的configmap"><a href="#找到kube-system命名空间的名称为coredns的configmap" class="headerlink" title="找到kube-system命名空间的名称为coredns的configmap"></a>找到kube-system命名空间的名称为coredns的configmap</h3><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">» kubectl get configmap coredns -n kube-system                                                                     yjzeng@yjzeng-ubuntu<br>NAME      DATA   AGE<br>coredns   1      9d<br>------------------------------------------------------------------------------------------------------------------------------------------<br>~ »<br></code></pre></div></td></tr></table></figure><h3 id="编辑这个configmap"><a href="#编辑这个configmap" class="headerlink" title="编辑这个configmap"></a>编辑这个configmap</h3><figure class="highlight gauss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gauss">~ » kubectl <span class="hljs-keyword">edit</span> configmap coredns -n kube-<span class="hljs-keyword">system</span><br></code></pre></div></td></tr></table></figure><h3 id="编辑为以下内容-添加了hosts块-："><a href="#编辑为以下内容-添加了hosts块-：" class="headerlink" title="编辑为以下内容(添加了hosts块)："></a>编辑为以下内容(添加了hosts块)：</h3><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-symbol">apiVersion:</span> v1<br><span class="hljs-symbol">data:</span><br><span class="hljs-symbol">  Corefile:</span> |<br>    .:<span class="hljs-number">53</span> &#123;<br>        errors<br>        health<br>        kubernetes cluster.local in-addr.arpa ip6.<span class="hljs-class">arpa </span>&#123;<br>          pods insecure<br>          upstream<br>          fallthrough in-addr.arpa ip6.arpa<br>          ttl <span class="hljs-number">30</span><br>        &#125;<br>        <span class="hljs-class">hosts </span>&#123;<br>            <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.22</span> cos6-data1.test.alltest.com<br>            <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.23</span> cos6-data2.test.alltest.com<br>            <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.24</span> cos6-data3.test.alltest.com<br>            <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.25</span> cos6-data4.test.alltest.com<br>            <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.26</span> cos6-data5.test.alltest.com<br>            <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.41</span> cos6-datanode6.test.alltest.com<br>            <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.42</span> cos6-datanode7.test.alltest.com<br>            <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.43</span> cos6-datanode8.test.alltest.com<br>            <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.44</span> cos6-datanode9.test.alltest.com<br>        &#125;<br>        prometheus :<span class="hljs-number">9153</span><br>        forward . <span class="hljs-string">"/etc/resolv.conf"</span><br>        cache <span class="hljs-number">30</span><br>        loop<br>        reload<br>        loadbalance<br>    &#125;<br><span class="hljs-symbol">kind:</span> ConfigMap<br><span class="hljs-symbol">metadata:</span><br><span class="hljs-symbol">  annotations:</span><br>    kubectl.kubernetes.io/last-applied-configuration: |<br>      &#123;<span class="hljs-string">"apiVersion"</span>:<span class="hljs-string">"v1"</span>,<span class="hljs-string">"data"</span>:&#123;<span class="hljs-string">"Corefile"</span>:<span class="hljs-string">".:53 &#123;\n    errors\n    health\n    kubernetes cluster.local in-addr.arpa ip6.arpa &#123;\n      pods insecure\n      upstream\n      fallthrough in-addr.arpa ip6.arpa\n      ttl 30\n    &#125;\n    prometheus :9153\n    forward . \"/etc/resolv.conf\"\n    cache 30\n    loop\n    reload\n    loadbalance\n&#125;\n"</span>&#125;,<span class="hljs-string">"kind"</span>:<span class="hljs-string">"ConfigMap"</span>,<span class="hljs-string">"metadata"</span>:&#123;<span class="hljs-string">"annotations"</span>:&#123;&#125;,<span class="hljs-string">"labels"</span>:&#123;<span class="hljs-string">"addonmanager.kubernetes.io/mode"</span>:<span class="hljs-string">"EnsureExists"</span>&#125;,<span class="hljs-string">"name"</span>:<span class="hljs-string">"coredns"</span>,<span class="hljs-string">"namespace"</span>:<span class="hljs-string">"kube-system"</span>&#125;&#125;<br><span class="hljs-symbol">  creationTimestamp:</span> <span class="hljs-string">"2019-08-19T09:14:15Z"</span><br><span class="hljs-symbol">  labels:</span><br>    addonmanager.kubernetes.io/mode: EnsureExists<br><span class="hljs-symbol">  name:</span> coredns<br><span class="hljs-symbol">  namespace:</span> kube-system<br><span class="hljs-symbol">  resourceVersion:</span> <span class="hljs-string">"3231349"</span><br><span class="hljs-symbol">  selfLink:</span> <span class="hljs-meta-keyword">/api/</span>v1<span class="hljs-meta-keyword">/namespaces/</span>kube-system<span class="hljs-meta-keyword">/configmaps/</span>coredns<br><span class="hljs-symbol">  uid:</span> b791c47f-c261<span class="hljs-number">-11e9</span>-b426<span class="hljs-number">-525400116042</span><br></code></pre></div></td></tr></table></figure><h3 id="重启coredns："><a href="#重启coredns：" class="headerlink" title="重启coredns："></a>重启coredns：</h3><figure class="highlight mel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mel">~ » kubectl <span class="hljs-keyword">scale</span> deployment coredns -n kube-<span class="hljs-keyword">system</span> --replicas=<span class="hljs-number">0</span><br>deployment.extensions/coredns scaled<br><br>~ » kubectl <span class="hljs-keyword">scale</span> deployment coredns -n kube-<span class="hljs-keyword">system</span> --replicas=<span class="hljs-number">2</span>                                                     yjzeng@yjzeng-ubuntu<br>deployment.extensions/coredns scaled<br></code></pre></div></td></tr></table></figure><h3 id="测试，进入任意一个具有ping命令的pod中，ping自己插入的域名，能通就说明已经生效了。"><a href="#测试，进入任意一个具有ping命令的pod中，ping自己插入的域名，能通就说明已经生效了。" class="headerlink" title="测试，进入任意一个具有ping命令的pod中，ping自己插入的域名，能通就说明已经生效了。"></a>测试，进入任意一个具有ping命令的pod中，ping自己插入的域名，能通就说明已经生效了。</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>图解 kubernetes scheduler 源码设计系列-初步了解</title>
    <link href="/2020/01/20/%E5%9B%BE%E8%A7%A3-kubernetes-scheduler-%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E7%B3%BB%E5%88%97-%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3/"/>
    <url>/2020/01/20/%E5%9B%BE%E8%A7%A3-kubernetes-scheduler-%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E7%B3%BB%E5%88%97-%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="1-资源调度基础"><a href="#1-资源调度基础" class="headerlink" title="1.资源调度基础"></a>1.资源调度基础</h1><p>scheudler是kubernetes中的核心组件，负责为用户声明的pod资源选择合适的node,同时保证集群资源的最大化利用，这里先介绍下资源调度系统设计里面的一些基础概念</p><h2 id="1-1-基础任务资源调度"><a href="#1-1-基础任务资源调度" class="headerlink" title="1.1 基础任务资源调度"></a>1.1 基础任务资源调度</h2><p><img src="/img/newimg/006tNbRwgy1gb2yzzb1vbj311u0k6qa3.jpg" srcset="/img/loading.gif" alt="调度"><br>基础的任务资源调度通常包括三部分：</p><table><thead><tr><th>角色类型</th><th>功能</th></tr></thead><tbody><tr><td>node</td><td>node负责具体任务的执行,同时对包汇报自己拥有的资源</td></tr><tr><td>resource manager</td><td>汇总当前集群中所有node提供的资源,供上层的scheduler的调用获取,同时根据node汇报的任务信息来进行当前集群资源的更新</td></tr><tr><td>scheduler</td><td>结合当前集群的资源和用户提交的任务信息,选择合适的node节点当前的资源，分配节点任务，尽可能保证任务的运行</td></tr></tbody></table><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">通用的调度框架往往还会包含一个上层的集群管理器，负责针对集群中<span class="hljs-keyword">scheduler的管理和资源分配工作，同时负责scheduler集群状态甚至resource </span>manager的保存<br></code></pre></div></td></tr></table></figure><h2 id="1-2-资源调度设计的挑战"><a href="#1-2-资源调度设计的挑战" class="headerlink" title="1.2 资源调度设计的挑战"></a>1.2 资源调度设计的挑战</h2><h3 id="1-2-1-资源：集群资源利用的最大化与平均"><a href="#1-2-1-资源：集群资源利用的最大化与平均" class="headerlink" title="1.2.1 资源：集群资源利用的最大化与平均"></a>1.2.1 资源：集群资源利用的最大化与平均</h3><p>传统的IDC集群资源利用：<br>在IDC环境中我们通常希望机器利用率能够平均,让机器保持在某个平均利用率，然后根据资源的需要预留足够的buffer, 来应对集群的资源利用高峰，毕竟采购通常都有周期，我们既不能让机器空着，也不能让他跑满(业务无法弹性)<br><img src="/img/newimg/006tNbRwgy1gb30kf8t6xj31100ba407.jpg" srcset="/img/loading.gif" alt=""></p><hr><p>云环境下的资源利用：<br>而云环境下我们可以按需分配，而且云厂商通常都支持秒级交付，那其实下面的这种资源利用率其实也可以</p><p><img src="/img/newimg/006tNbRwgy1gb30kv8yjqj310g0asgn7.jpg" srcset="/img/loading.gif" alt=""><br>可以看到仅仅是环境的不一致，就可能会导致不同的调度结果，所有针对集群资源利用最大化这个目标，其实会有很多的不同</p><h3 id="1-2-2-调度-任务最少等待时间与优先级"><a href="#1-2-2-调度-任务最少等待时间与优先级" class="headerlink" title="1.2.2 调度: 任务最少等待时间与优先级"></a>1.2.2 调度: 任务最少等待时间与优先级</h3><p><img src="/img/newimg/006tNbRwgy1gb30lbl880j31200fgtc7.jpg" srcset="/img/loading.gif" alt=""><br>在集群任务繁忙的时候，可能会导致集群资源部足以分配给当前集群中的所有任务，在让所有任务都能够尽快完成的同时，我们还要保证高优先级的任务优先被完成</p><h3 id="1-2-3-调度-任务本地性"><a href="#1-2-3-调度-任务本地性" class="headerlink" title="1.2.3 调度: 任务本地性"></a>1.2.3 调度: 任务本地性</h3><p><img src="/img/newimg/006tNbRwgy1gb30mlnso0j311w0ciwgu.jpg" srcset="/img/loading.gif" alt=""><br>本地性是指在大数据处理中常用的一种机制，其核心是尽可能将任务分配到包含其任务执行资源的节点上，避免数据的复制</p><h3 id="1-2-4-集群-高可用性"><a href="#1-2-4-集群-高可用性" class="headerlink" title="1.2.4 集群: 高可用性"></a>1.2.4 集群: 高可用性</h3><p><img src="/img/newimg/006tNbRwgy1gb30mz8cx6j310w0li43n.jpg" srcset="/img/loading.gif" alt=""><br>在调度过程中可能由于硬件、系统或者软件导致任务的不可用，通常会由需要一些高可用机制，来保证当前集群不会因为部分节点宕机而导致整个系统不可用</p><h3 id="1-2-5-系统-可扩展性"><a href="#1-2-5-系统-可扩展性" class="headerlink" title="1.2.5 系统: 可扩展性"></a>1.2.5 系统: 可扩展性</h3><p><img src="/img/newimg/006tNbRwgy1gb30ndadspj312c0d8jub.jpg" srcset="/img/loading.gif" alt=""><br>扩展机制主要是指的，系统如何如何应对业务需求的变化，提供的一种可扩展机制，在集群默认调度策略不满足业务需求时，通过扩展接口，来进行系统的扩展满足业务需求</p><h2 id="1-3-Pod调度场景的挑战"><a href="#1-3-Pod调度场景的挑战" class="headerlink" title="1.3 Pod调度场景的挑战"></a>1.3 Pod调度场景的挑战</h2><p>Pod调度场景其实可以看做一类特殊的任务，除了上面资源调度的挑战，还有一些针对pod调度这个具体的场景(有些是共同的,这里通过pod来描述会比较清晰)</p><h3 id="1-3-1-亲和与反亲和"><a href="#1-3-1-亲和与反亲和" class="headerlink" title="1.3.1 亲和与反亲和"></a>1.3.1 亲和与反亲和</h3><p>在kubernetes中的亲和性主要体现pod和node两种资源，主要体现在两个方面:<br>1.亲和性: 1)pod之间的亲和性 2)pod与node之间的亲和性<br>2.反亲和: 1)pod之间的反亲和性 2)pod与node之间的反亲和<br>简单举例：<br>1.pod之间的反亲和: 为了保证高可用我们通常会将同一业务的多个节点分散在不通的数据中心和机架<br>2.pod与node亲和性: 比如某些需要磁盘io操作的pod，我们可以调度到具有ssd的机器上，提高IO性能</p><h3 id="1-3-2-多租户与容量规划"><a href="#1-3-2-多租户与容量规划" class="headerlink" title="1.3.2 多租户与容量规划"></a>1.3.2 多租户与容量规划</h3><p>多租户通常是为了进行集群资源的隔离，在业务系统中，通常会按照业务线来进行资源的隔离，同时会给业务设定对应的容量，从而避免单个业务线资源的过度使用影响整个公司的所有业务</p><h3 id="1-3-3-Zone与node选择"><a href="#1-3-3-Zone与node选择" class="headerlink" title="1.3.3 Zone与node选择"></a>1.3.3 Zone与node选择</h3><p>zone通常是在业务容灾中常见的概念，通过将服务分散在多个数据中心，避免因为单个数据中心故障导致业务完全不可用</p><p>因为之前亲和性的问题，如何在多个zone中的所有node中选择出一个合适的节点，则是一个比较大的挑战</p><h3 id="1-3-4-多样化资源的扩展"><a href="#1-3-4-多样化资源的扩展" class="headerlink" title="1.3.4 多样化资源的扩展"></a>1.3.4 多样化资源的扩展</h3><p>系统资源除了cpu、内存还包括网络、磁盘io、gpu等等，针对其余资源的分配调度，kubernetes还需要提供额外的扩展机制来进行调度扩展的支持</p><h3 id="1-3-5-资源混部"><a href="#1-3-5-资源混部" class="headerlink" title="1.3.5 资源混部"></a>1.3.5 资源混部</h3><p>kubernetes初期是针对pod调度场景而生，主要其实是在线web业务，这类任务的特点大部分都是无状态的，那如何针对离线场景的去支持离线的批处理计算等任务</p><h1 id="2-kubernetes中的调度初识"><a href="#2-kubernetes中的调度初识" class="headerlink" title="2. kubernetes中的调度初识"></a>2. kubernetes中的调度初识</h1><h2 id="2-1-中心化数据集中存储"><a href="#2-1-中心化数据集中存储" class="headerlink" title="2.1 中心化数据集中存储"></a>2.1 中心化数据集中存储</h2><p><img src="/img/newimg/006tNbRwgy1gb30vhaca4j311y0pu474.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="2-1-1-中心化的数据存储"><a href="#2-1-1-中心化的数据存储" class="headerlink" title="2.1.1 中心化的数据存储"></a>2.1.1 中心化的数据存储</h3><p>kubernetes是一个数据中心化存储的系统，集群中的所有数据都通过apiserver存储到etcd中，包括node节点的资源信息、节点上面的pod信息、当前集群的所有pod信息，在这里其实apiserver也充当了resource manager的角色，存储所有的集群资源和已经分配的资源</p><h3 id="2-1-2-调度数据的存储与获取"><a href="#2-1-2-调度数据的存储与获取" class="headerlink" title="2.1.2 调度数据的存储与获取"></a>2.1.2 调度数据的存储与获取</h3><p><img src="/img/newimg/006tNbRwgy1gb30vyoijuj31100gstd9.jpg" srcset="/img/loading.gif" alt=""></p><p>kubernetes中采用了一种list watch的机制，用于集群中其他节点从apiserver感知数据，scheduler也采用该机制，通过在感知apiserver的数据变化，同时在本地memory中构建一份cache数据(资源数据)，来提供调度使用，即SchedulerCache</p><h3 id="2-1-3-scheduler的高可用"><a href="#2-1-3-scheduler的高可用" class="headerlink" title="2.1.3 scheduler的高可用"></a>2.1.3 scheduler的高可用</h3><p>大多数系统的高可用机制都是通过类似zookeeper、etcd等AP系统实现，通过临时节点或者锁机制机制来实现多个节点的竞争，从而在主节点宕机时，能够快速接管， scheduler自然也是这种机制，通过apiserver底层的etcd来实现锁的竞争，然后通过apiserver的数据，就可以保证调度器的高可用</p><h2 id="2-2-调度器内部组成"><a href="#2-2-调度器内部组成" class="headerlink" title="2.2 调度器内部组成"></a>2.2 调度器内部组成</h2><h3 id="2-2-1-调度队列"><a href="#2-2-1-调度队列" class="headerlink" title="2.2.1 调度队列"></a>2.2.1 调度队列</h3><p><img src="/img/newimg/006tNbRwgy1gb30wk9d8xj311y0gyadu.jpg" srcset="/img/loading.gif" alt=""></p><p>当从apiserver感知到要调度的pod的时候,scheduler会根据pod的优先级，来讲其加入到内部的一个优先级队列中，后续调度的时候，会先获取优先级比较高的pod来进行优先满足调度</p><p>这里还有一个点就是如果优先调度了优先级比较低的pod，其实在后续的抢占过程中，也会被驱逐出去</p><h3 id="2-2-2-调度与抢占调度"><a href="#2-2-2-调度与抢占调度" class="headerlink" title="2.2.2 调度与抢占调度"></a>2.2.2 调度与抢占调度</h3><p><img src="/img/newimg/006tNbRwgy1gb30wyvh1uj313m0a2whc.jpg" srcset="/img/loading.gif" alt=""></p><p>前面提到过抢占,kubernetes默认会对所有的pod来尝试进行调度，当集群资源部满足的时候，则会尝试抢占调度，通过抢占调度，为高优先级的pod来进行优先调度 其核心都是通过调度算法实现即ScheduleAlgorithm</p><p>这里的调度算法实际上是一堆调度算法和调度配置的集合</p><h3 id="2-2-3-外部扩展机制"><a href="#2-2-3-外部扩展机制" class="headerlink" title="2.2.3 外部扩展机制"></a>2.2.3 外部扩展机制</h3><p><img src="/img/newimg/006tNbRwgy1gb30ze6fbyj311e0dc0wd.jpg" srcset="/img/loading.gif" alt=""><br>scheduler extender是k8s对调度器的一种扩展机制，我们可以定义对应的extender,在对应资源的调度的时候，k8s会检查对应的资源，如果发现需要调用外部的extender,则将当前的调度数据发送给extender,然后汇总调度数据，决定最终的调度结果</p><h3 id="2-2-4-内部扩展机制"><a href="#2-2-4-内部扩展机制" class="headerlink" title="2.2.4 内部扩展机制"></a>2.2.4 内部扩展机制</h3><p>上面提到调度算法是一组调度算法和调度配置的集合，kubernetes scheduler framework是则是一个框架声明对应插件的接口，从而支持用户编写自己的plugin,来影响调度决策，个人感觉这并不是一种好的机制，因为要修改代码，或者通过修改kubernetes scheduler启动来进行自定义插件的加载</p><h2 id="2-3-调度基础架构"><a href="#2-3-调度基础架构" class="headerlink" title="2.3 调度基础架构"></a>2.3 调度基础架构</h2><p><img src="/img/newimg/006tNbRwgy1gb30zuz9xmj31340jg45b.jpg" srcset="/img/loading.gif" alt=""><br>结合上面所说的就得到了一个最简单的架构，主要调度流程分为如下几部分：<br>0.通过apiserver来进行主节点选举，成功者进行调度业务流程处理<br>1.通过apiserver感知集群的资源数据和pod数据，更新本地schedulerCache<br>2.通过apiserver感知用户或者controller的pod调度请求，加入本地调度队列<br>3.通过调度算法来进行pod请求的调度，分配合适的node节点，此过程可能会发生抢占调度<br>4.将调度结果返回给apiserver,然后由kubelet组件进行后续pod的请求处理</p>]]></content>
    
    
    
    <tags>
      
      <tag>kubernetes,k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cenots7离线部署k3s</title>
    <link href="/2020/01/16/cenots7%E7%A6%BB%E7%BA%BF%E9%83%A8%E7%BD%B2k3s/"/>
    <url>/2020/01/16/cenots7%E7%A6%BB%E7%BA%BF%E9%83%A8%E7%BD%B2k3s/</url>
    
    <content type="html"><![CDATA[<h3 id="K3S简介："><a href="#K3S简介：" class="headerlink" title="K3S简介："></a>K3S简介：</h3><blockquote><p><a href="https://k3s.io/" target="_blank" rel="noopener">https://k3s.io/</a><br><a href="https://github.com/rancher/k3s" target="_blank" rel="noopener">https://github.com/rancher/k3s</a><br><a href="https://github.com/rancher/k3s/releases" target="_blank" rel="noopener">https://github.com/rancher/k3s/releases</a>      //版本及images<br><img src="/img/newimg/006tNbRwgy1gb315kdc6qj31ag0heq89.jpg" srcset="/img/loading.gif" alt=""></p></blockquote><p>总的来说就是轻量级k8s,master只要500M内存就能跑,一般场景是边缘计算或者本地测试k8s环境.</p><h3 id="部署环境"><a href="#部署环境" class="headerlink" title="部署环境"></a>部署环境</h3><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">k3s      <br>docker-ce<br>centos7<span class="hljs-number">.6</span><br></code></pre></div></td></tr></table></figure><h3 id="docker-ce安装"><a href="#docker-ce安装" class="headerlink" title="docker-ce安装"></a>docker-ce安装</h3><p>参考：</p><p><a href="https://www.cnblogs.com/xiaochina/p/11518007.html" target="_blank" rel="noopener">centos7.6在线yum安装docker-ce</a><br><a href="https://www.cnblogs.com/xiaochina/p/7074796.html" target="_blank" rel="noopener">基于Centos7.5搭建Docker环境</a><br><a href="https://www.cnblogs.com/xiaochina/p/10469715.html" target="_blank" rel="noopener">centos7下docker二进制安装</a></p><h3 id="导入k3s镜像"><a href="#导入k3s镜像" class="headerlink" title="导入k3s镜像"></a>导入k3s镜像</h3><p>下载 <a href="https://github.com/rancher/k3s/releases/download/v1.17.0%2Bk3s.1/k3s-airgap-images-amd64.tar" target="_blank" rel="noopener">https://github.com/rancher/k3s/releases/download/v1.17.0%2Bk3s.1/k3s-airgap-images-amd64.tar</a>  (注意自己的平台架构比如 x86,arm32,arm64)</p><p>docker load -i k3s-airgap-images-amd64.tar </p><figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy">Loaded <span class="hljs-string">image:</span> docker.io<span class="hljs-regexp">/coredns/</span><span class="hljs-string">coredns:</span><span class="hljs-number">1.3</span><span class="hljs-number">.0</span><br>Loaded <span class="hljs-string">image:</span> docker.io<span class="hljs-regexp">/library/</span><span class="hljs-string">traefik:</span><span class="hljs-number">1.7</span><span class="hljs-number">.12</span><br>Loaded <span class="hljs-string">image:</span> docker.io<span class="hljs-regexp">/rancher/</span>klipper-<span class="hljs-string">helm:</span>v0<span class="hljs-number">.1</span><span class="hljs-number">.5</span><br>Loaded <span class="hljs-string">image:</span> docker.io<span class="hljs-regexp">/rancher/</span>klipper-<span class="hljs-string">lb:</span>v0<span class="hljs-number">.1</span><span class="hljs-number">.1</span><br>Loaded <span class="hljs-string">image:</span> k8s.gcr.io/<span class="hljs-string">pause:</span><span class="hljs-number">3.1</span><br></code></pre></div></td></tr></table></figure><h3 id="部署k3s-server-agent"><a href="#部署k3s-server-agent" class="headerlink" title="部署k3s server/agent"></a>部署k3s server/agent</h3><p><a href="https://github.com/rancher/k3s/releases/download/v0.9.0/k3s" target="_blank" rel="noopener">https://github.com/rancher/k3s/releases/download/v0.9.0/k3s</a>   //下载二进制k3s</p><p><a href="https://raw.githubusercontent.com/rancher/k3s/master/install.sh" target="_blank" rel="noopener">https://raw.githubusercontent.com/rancher/k3s/master/install.sh</a>    //k3s安装脚本，具体可以看下脚本存在很多变量定义</p><p>export INSTALL_K3S_SKIP_DOWNLOAD=true           //设置跳过下载k3s二进制文件<br>export INSTALL_K3S_BIN_DIR=/usr/bin       //设置k3s安装目录<br>./install.sh       //自动建立service服务及软连接  kubectl ctr  ….</p><p>systemctl status k3s    //服务运行状态</p><p>journalctl -u k3s -f     //根据日志可以看到服务启动不起来,要去国外拉images，你懂得，heihei</p><h3 id="修正k3s服务改用docker"><a href="#修正k3s服务改用docker" class="headerlink" title="修正k3s服务改用docker"></a>修正k3s服务改用docker</h3><p>vim /etc/systemd/system/k3s.service<br>ExecStart=/usr/bin/k3s <br>server –docker\              //注意 两个杠，容器选择docker，替换默认的containerd</p><p>systemctl daemon-reload    //刷新服务配置文件，重新定向到target<br>systemctl restart k3s</p><p><img src="/img/newimg/006tNbRwgy1gb31og03w8j30t70dr0u4.jpg" srcset="/img/loading.gif" alt=""><br>k3s的pod运行在docker之中<br><img src="/img/newimg/006tNbRwgy1gb31onpelnj312k0faq6h.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="安装错误记录"><a href="#安装错误记录" class="headerlink" title="安装错误记录"></a>安装错误记录</h3><p>在树莓派4装的ubuntu 18.04 LTS 系统中跑k3s发现如下错误<br><img src="/img/newimg/007S8ZIlgy1ge3n7e4opzj31fr0u07wi.jpg" srcset="/img/loading.gif" alt=""><br>关键报错信息：</p><figure class="highlight smalltalk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs smalltalk">level=error msg=<span class="hljs-comment">"Failed to find memory cgroup, you may need to add \"</span>cgroup_memory=<span class="hljs-number">1</span> cgroup_enable=memory\<span class="hljs-comment">" to your linux cmdline (/boot/cmdline.txt on a Raspberry Pi)"</span><br></code></pre></div></td></tr></table></figure><h3 id="排查记录"><a href="#排查记录" class="headerlink" title="排查记录"></a>排查记录</h3><p>日志提示很明显，所以我们修改/boot/cmdline.txt并重启，但是重启后发现问题依旧，还是有这个问题。这个修改的本质是添加内核参数，所以我们从操作系统层面检查：</p><blockquote><p>$ cat /proc/cmdline | grep cgroup_memory<br>nothing return</p></blockquote><p>也就是说，cmdline的修改没有生效。所以，我们怀疑ubuntu这个镜像修改cmdline有其他方式：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros"><br>$ df -hT | grep mmc<br>/dev/mmcblk0p2 ext4       29G  2.8G   26G  10% /<br>/dev/mmcblk0p1 vfat      253M  117M  136M  47% /boot/firmware<br><span class="hljs-comment"># 真正的启动分区在/boot/firmware</span><br><br><span class="hljs-comment"># 阅读/boot/firmware/README</span><br><span class="hljs-comment"># 排查后得知，应该修改nobtcmd.txt</span><br></code></pre></div></td></tr></table></figure><p>在/boot/firmware/nobtcmd.txt添加cgroup相关参数后，重启后可以看到cmdline有了期望的配置：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">$ cat /proc/cmdline | grep cgroup_memory<br><span class="hljs-attribute">coherent_pool</span>=1M ………. <span class="hljs-attribute">cgroup_memory</span>=1 <span class="hljs-attribute">cgroup_enable</span>=memory<br></code></pre></div></td></tr></table></figure><p>这时发现k3s依然没有完成启动，日志输出缓慢，怀疑系统某些因素影响了启动过程。排查entropy，发现可用值非常低，低到会阻塞程序运行，一般来说&lt;1000程序就会卡住</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts">$ cat <span class="hljs-meta-keyword">/proc/</span>sys<span class="hljs-meta-keyword">/kernel/</span>random/entropy_avail<br><span class="hljs-number">522</span><br></code></pre></div></td></tr></table></figure><p>很多程序的运行都依赖随机数生成，比如hash、加密解密等过程。申请随机数就会消耗系统的entropy（熵），当entropy低到一定阈值，程序就运行缓慢，等待随机数种子。</p><p>一般来说kernel可以从硬件运行信息中收集噪声来补充entropy，但树莓派毕竟硬件能力有限，无法从硬件层面快速生成entropy，所以我们安装软件提供模拟算法进行补充：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> apt install haveged </span><br><span class="hljs-meta">$</span><span class="bash"> systemctl <span class="hljs-built_in">enable</span> haveged</span><br><br><span class="hljs-meta">$</span><span class="bash"> cat /proc/sys/kernel/random/entropy_avail</span><br>2366<br></code></pre></div></td></tr></table></figure><p>一切妥当之后，再查看k3s启动状态，k3s已经完成启动。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Linux运行在诸如树莓派这种简易硬件架构下，会有很多细微差别，平日在x86 server体系的认知和经验可能都是不成立，这就导致运行在服务器Linux上的软件并不会那么容易移植到小型终端设备上。对于树莓派，除了文中提及的内容，你还需要关注NTP时间同步，MicroSD卡的IO性能等等。</p><p>参考<br><a href="https://my.oschina.net/u/4407852/blog/3198647/print" target="_blank" rel="noopener">树莓派安装k3s报错</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes笔记: HostAliases</title>
    <link href="/2020/01/03/kubernetes%E7%AC%94%E8%AE%B0-HostAliases/"/>
    <url>/2020/01/03/kubernetes%E7%AC%94%E8%AE%B0-HostAliases/</url>
    
    <content type="html"><![CDATA[<p>k8s上不同服务之间可以通过service的域名来互相访问。域名的解析是一般是通过在集群中的kube-dns（主要是dnsmasq）或者coredns完成的。k8s的dns也可以向上级联dns服务器。</p><p>有的时候，我们希望给运行在k8s上的Pod增加一些域名的解析（例如宿主机的主机名），但又不想对dns模块动太多，有没有什么比较方便的办法呢？<br>方法如下:</p><blockquote><p>容器挂载宿主机/etc/hosts 并设置亲和性。让此pod只在该主机上<br>用k8s特性 .spec.hostAliases。hostAliases字段<br>更改集群中的coredns的记录</p></blockquote><p>此篇主要讲解hostAliases方法。</p><h2 id="使用-HostAliases-向-Pod-etc-hosts-文件添加条目"><a href="#使用-HostAliases-向-Pod-etc-hosts-文件添加条目" class="headerlink" title="使用 HostAliases 向 Pod /etc/hosts 文件添加条目"></a>使用 HostAliases 向 Pod /etc/hosts 文件添加条目</h2><p>当 DNS 配置以及其它选项不合理的时候，通过向 Pod 的 /etc/hosts 文件中添加条目，可以在 Pod 级别覆盖对主机名的解析。在 1.7 版本，用户可以通过 PodSpec 的 HostAliases 字段来添加这些自定义的条目。</p><p>建议通过使用 HostAliases 来进行修改，因为该文件由 Kubelet 管理，并且可以在 Pod 创建/重启过程中被重写。</p><h3 id="默认-hosts-文件内容"><a href="#默认-hosts-文件内容" class="headerlink" title="默认 hosts 文件内容"></a>默认 hosts 文件内容</h3><p>让我们从一个 Nginx Pod 开始，给该 Pod 分配一个 IP：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">run</span> nginx --image nginx <span class="hljs-attribute">--generator</span>=run-pod/v1<br>pod/nginx created<br></code></pre></div></td></tr></table></figure><p>检查Pod IP：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">get</span> pods <span class="hljs-attribute">--output</span>=wide<br><br>NAME     READY     STATUS    RESTARTS   AGE   <span class="hljs-built_in"> IP </span>          NODE<br>nginx    1/1       Running   0          13s    10.200.0.4   worker0<br></code></pre></div></td></tr></table></figure><p>主机文件的内容如下所示：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">kubectl exec nginx -- cat /etc/hosts<br><br># Kubernetes-managed hosts file.<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>localhost<br>::<span class="hljs-number">1</span>localhost ip6-localhost ip6-loopback<br>fe00::<span class="hljs-number">0</span>ip6-localnet<br>fe00::<span class="hljs-number">0</span>ip6-mcastprefix<br>fe00::<span class="hljs-number">1</span>ip6-allnodes<br>fe00::<span class="hljs-number">2</span>ip6-allrouters<br><span class="hljs-number">10.200</span><span class="hljs-number">.0</span><span class="hljs-number">.4</span>nginx<br></code></pre></div></td></tr></table></figure><p>默认，hosts 文件只包含 ipv4 和 ipv6 的样板内容，像 localhost 和主机名称。</p><h3 id="通过-HostAliases-增加额外的条目"><a href="#通过-HostAliases-增加额外的条目" class="headerlink" title="通过 HostAliases 增加额外的条目"></a>通过 HostAliases 增加额外的条目</h3><p>除了默认的样板内容，我们可以向 hosts 文件添加额外的条目，将 foo.local、 bar.local 解析为127.0.0.1， 将 foo.remote、 bar.remote 解析为 10.1.2.3，我们可以在 .spec.hostAliases 下为 Pod 添加 HostAliases。</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts">service<span class="hljs-meta-keyword">/networking/</span>hostaliases-pod.yaml <br><br><span class="hljs-symbol">apiVersion:</span> v1<br><span class="hljs-symbol">kind:</span> Pod<br><span class="hljs-symbol">metadata:</span><br><span class="hljs-symbol">  name:</span> hostaliases-pod<br><span class="hljs-symbol">spec:</span><br><span class="hljs-symbol">  restartPolicy:</span> Never<br><span class="hljs-symbol">  hostAliases:</span><br>  - ip: <span class="hljs-string">"127.0.0.1"</span><br><span class="hljs-symbol">    hostnames:</span><br>    - <span class="hljs-string">"foo.local"</span><br>    - <span class="hljs-string">"bar.local"</span><br>  - ip: <span class="hljs-string">"10.1.2.3"</span><br><span class="hljs-symbol">    hostnames:</span><br>    - <span class="hljs-string">"foo.remote"</span><br>    - <span class="hljs-string">"bar.remote"</span><br><span class="hljs-symbol">  containers:</span><br>  - name: cat-hosts<br><span class="hljs-symbol">    image:</span> busybox<br><span class="hljs-symbol">    command:</span><br>    - cat<br><span class="hljs-symbol">    args:</span><br>    - <span class="hljs-string">"/etc/hosts"</span><br></code></pre></div></td></tr></table></figure><p>可以使用以下命令启动此Pod：</p><figure class="highlight coq"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coq">kubectl <span class="hljs-built_in">apply</span> -f hostaliases-pod.yaml<br><br>pod/hostaliases-pod created<br></code></pre></div></td></tr></table></figure><p>检查Pod IP 和状态：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">get</span> pod <span class="hljs-attribute">--output</span>=wide<br><br>NAME                           READY     STATUS      RESTARTS   AGE      <span class="hljs-built_in"> IP </span>             NODE<br>hostaliases-pod                0/1       Completed   0          6s        10.200.0.5      worker0<br></code></pre></div></td></tr></table></figure><p>hosts 文件的内容看起来类似如下这样：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">kubectl</span> <span class="hljs-selector-tag">logs</span> <span class="hljs-selector-tag">hostaliases-pod</span><br><br># <span class="hljs-selector-tag">Kubernetes-managed</span> <span class="hljs-selector-tag">hosts</span> <span class="hljs-selector-tag">file</span>.<br>127<span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.1</span><span class="hljs-selector-tag">localhost</span><br><span class="hljs-selector-pseudo">::1</span><span class="hljs-selector-tag">localhost</span> <span class="hljs-selector-tag">ip6-localhost</span> <span class="hljs-selector-tag">ip6-loopback</span><br><span class="hljs-selector-tag">fe00</span><span class="hljs-selector-pseudo">::0</span><span class="hljs-selector-tag">ip6-localnet</span><br><span class="hljs-selector-tag">fe00</span><span class="hljs-selector-pseudo">::0</span><span class="hljs-selector-tag">ip6-mcastprefix</span><br><span class="hljs-selector-tag">fe00</span><span class="hljs-selector-pseudo">::1</span><span class="hljs-selector-tag">ip6-allnodes</span><br><span class="hljs-selector-tag">fe00</span><span class="hljs-selector-pseudo">::2</span><span class="hljs-selector-tag">ip6-allrouters</span><br>10<span class="hljs-selector-class">.200</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.5</span><span class="hljs-selector-tag">hostaliases-pod</span><br><br># <span class="hljs-selector-tag">Entries</span> <span class="hljs-selector-tag">added</span> <span class="hljs-selector-tag">by</span> <span class="hljs-selector-tag">HostAliases</span>.<br>127<span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.1</span><span class="hljs-selector-tag">foo</span><span class="hljs-selector-class">.local</span><span class="hljs-selector-tag">bar</span><span class="hljs-selector-class">.local</span><br>10<span class="hljs-selector-class">.1</span><span class="hljs-selector-class">.2</span><span class="hljs-selector-class">.3</span><span class="hljs-selector-tag">foo</span><span class="hljs-selector-class">.remote</span><span class="hljs-selector-tag">bar</span><span class="hljs-selector-class">.remote</span><br></code></pre></div></td></tr></table></figure><p>在最下面额外添加了一些条目</p><h3 id="为什么-Kubelet-管理-hosts文件？"><a href="#为什么-Kubelet-管理-hosts文件？" class="headerlink" title="为什么 Kubelet 管理 hosts文件？"></a>为什么 Kubelet 管理 hosts文件？</h3><p>kubelet 管理 Pod 中每个容器的 hosts 文件，避免 Docker 在容器已经启动之后去 修改 该文件。</p><p>因为该文件是托管性质的文件，无论容器重启或 Pod 重新调度，用户修改该 hosts 文件的任何内容，都会在 Kubelet 重新安装后被覆盖。因此，不建议修改该文件的内容。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>云原声的CICD工具-drone</title>
    <link href="/2020/01/02/%E4%BA%91%E5%8E%9F%E7%94%9F%E7%9A%84CICD%E5%B7%A5%E5%85%B7-drone/"/>
    <url>/2020/01/02/%E4%BA%91%E5%8E%9F%E7%94%9F%E7%9A%84CICD%E5%B7%A5%E5%85%B7-drone/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2019最后一次出游记录</title>
    <link href="/2019/12/28/2019%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E5%87%BA%E6%B8%B8%E8%AE%B0%E5%BD%95/"/>
    <url>/2019/12/28/2019%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E5%87%BA%E6%B8%B8%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>时间过得很快,转眼2019已经接近尾声.为了抓住今年的尾巴 跟小伙伴们一起自驾游。</p><h2 id="行程"><a href="#行程" class="headerlink" title="行程"></a>行程</h2><p>原计划的行程如下:</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">周五晚上:</span><br>香楠小区<br>宁国市政府<br>青龙湖景区<br><br><span class="hljs-section">周六一天:</span><br>红杉林景区<br>六道湾观景台<br>水墨汀溪风景区<br><br>周日(预计)<br>月亮湾生态旅游风景区<br>敬亭山风景名胜区<br>香楠小区<br></code></pre></div></td></tr></table></figure><p>总体来讲就是按照皖南川藏线的路线。主要是体验大自然,都基本是山路。<br>理论路线如下:<br><img src="/img/newimg/006tNbRwly1gacvq55d7xj30zk0ngx23.jpg" srcset="/img/loading.gif" alt="理论路线"></p><blockquote><p>当然计划就是拿来执行的,执行总可能有点差错……</p></blockquote><h3 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h3><p>周五晚上没啥子问题。我们租了两个车,一个五座一个七座。满满12个人 出发前往青龙湖景区的青龙池山庄</p><hr><p>这是出发前的照片,满满三箱子零食<br><img src="/img/newimg/006tNbRwly1gacu5ea7d8j31hc0om1az.jpg" srcset="/img/loading.gif" alt="出发"></p><p>我们晚上九点从上海出发,到凌晨三点才到青龙池山庄。进去就洗澡睡觉了.因为第二天还比较赶<br><img src="/img/newimg/006tNbRwly1gacu3hdgi9j31400u015k.jpg" srcset="/img/loading.gif" alt="青龙池山庄-1"><br><img src="/img/newimg/006tNbRwly1gacu3s1jzbj31400u07em.jpg" srcset="/img/loading.gif" alt="青龙池山庄-2"></p><blockquote><p>老板人不错,因为是淡季 房间从200每间讲价到120每间,还带早餐。提供包子馒头稀饭和咸菜 管够…忘记拍照了 冯睿一个人吃了五个包子三碗稀饭还吃了若干个鸡蛋…..</p></blockquote><h3 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h3><p>早餐吃完我们就出发到红杉林景区的码头停下,斟酌半天以后 全员登上快艇然后去湖对面玩儿。<br>码头上快艇<br><img src="/img/newimg/006tNbRwly1gacvtrwrwzj30u014078c.jpg" srcset="/img/loading.gif" alt="码头"><br><img src="/img/newimg/006tNbRwly1gacvub0bwoj30u0140npf.jpg" srcset="/img/loading.gif" alt="fr"><br><img src="/img/newimg/006tNbRwly1gacvuk7rckj31400u04qu.jpg" srcset="/img/loading.gif" alt="水花"><br><img src="/img/newimg/006tNbRwly1gacvv3xsvxj31400u0420.jpg" srcset="/img/loading.gif" alt=""></p><p>到了湖对面合影<br><img src="/img/newimg/006tNbRwly1gacuqvlep1j31400u047h.jpg" srcset="/img/loading.gif" alt="到了湖对面以后"></p><p>爬山遛狗<br><img src="/img/newimg/006tNbRwly1gacvhatn16j30u0140gyu.jpg" srcset="/img/loading.gif" alt="爬山遛狗"></p><p>反正景色真的不错。然后天公作美,拍出来的照片就像windows XP的壁纸<br><img src="/img/newimg/006tNbRwly1gacvwg7oi1j31400u0whf.jpg" srcset="/img/loading.gif" alt="bz1"><br><img src="/img/newimg/006tNbRwly1gacvwkv76zj31400u076k.jpg" srcset="/img/loading.gif" alt="bz2"><br><img src="/img/newimg/006tNbRwly1gacvws226qj31400u0mz1.jpg" srcset="/img/loading.gif" alt="bz3"></p><p>总计玩了一个小时左右，大家都饿了 听说码头边上有一个农家乐,菜都比较新鲜 都是自己家产的。<br>点完菜以后,农家阿姨去做饭 我们在这边嗮太阳，聊天。<br><img src="/img/newimg/006tNbRwly1gacuuwwb2mj31400u0dkx.jpg" srcset="/img/loading.gif" alt="吃饭前聊天"></p><p>等了大概一个小时，才吃上饭 因为只有阿姨一个人做饭,并且我们前面还有一桌。<br><img src="/img/newimg/006tNbRwly1gacuvgn0loj31400u0q6y.jpg" srcset="/img/loading.gif" alt="吃饭"></p><blockquote><p>不得不说 真的好吃。原滋原味的农家菜，在加上阿姨做饭手艺比较牛皮。(你们看刘磊的眼睛是不是比我的小啊….毋庸置疑的事情)</p></blockquote><hr><p>下午停车偶遇直升飞机,可以体验的那种.带着女朋友我俩去试了试,怎么说呢 感觉像坐公交车…不是很刺激 但是上面风景真的好，特别是下面是个风景区的情况下。<br><img src="/img/newimg/006tNbRwly1gacvgsboulj31400u0ae1.jpg" srcset="/img/loading.gif" alt="飞机1"><br><img src="/img/newimg/006tNbRwly1gacvgzst7jj31400u0gp7.jpg" srcset="/img/loading.gif" alt="飞机2"></p><p>问题来了 我们码头游玩以及吃饭大概花了四五个小时。导致计划的后面六道湾观景台根本没有时间去品。并且天还下起了小雨,一个同伴还晕车不舒服。于是一路快马加鞭飞奔到下一个酒店。<br>理论上的六道湾观景台的样子<br><img src="/img/newimg/006tNbRwly1gacw1ttshsj30go09cjsk.jpg" srcset="/img/loading.gif" alt="理论1"><br><img src="/img/newimg/006tNbRwly1gacw2fk356j30go0b374u.jpg" srcset="/img/loading.gif" alt="理论2"></p><p>我们看到的样子<br><img src="/img/newimg/006tNbRwly1gacvsj7kvaj30hs0a00sl.jpg" srcset="/img/loading.gif" alt="我们看到的"></p><blockquote><p>蜜汁尴尬,还好袁昭车技牛皮….不然都出不来了。</p></blockquote><p>到了酒店已经晚上8点,安置完行李就出去找了个地方吃东西, 可能是中午的饭菜太好吃了,晚上的这一顿饭菜总感觉没啥子印象。印象最深的倒是老板 挨个发烟,然后还给我们本地的芝麻糖吃。 </p><p>吃完回来以后,说好的晚上玩玩牌或者狼人杀来着,结果一会儿大家都睡了。估计都累了</p><hr><p>周日一早,我们一行人(除了李刚夫妇,一大早也不知道在干啥)出去吃早餐。订餐之前老板说这个地方吃早餐可多了…结果一早问他去哪儿吃，他说两公里以外的地方有一个桥 过了桥就有吃的……<br>出发前看到一只小黑</p><p><img src="/img/newimg/006tNbRwgy1gaet24wh6vj31400u00zj.jpg" srcset="/img/loading.gif" alt="小黑"><br>吃完早饭去了茶山瞧瞧</p><p>早上的样子<br><img src="/img/newimg/006tNbRwgy1gaet6et94wj31400u0aeq.jpg" srcset="/img/loading.gif" alt="早上"></p><p>吃完早饭出发去了茶山<br><img src="/img/newimg/006tNbRwgy1gaet501cglj31hc0omqgf.jpg" srcset="/img/loading.gif" alt="茶山"></p><hr><p>临近中午去了蹦蹦床玩<br>吃了最后一顿午饭<br><img src="/img/newimg/006tNbRwgy1gaetmlf8y1j30u0140whw.jpg" srcset="/img/loading.gif" alt=""><br>出发回上海<br><img src="/img/newimg/006tNbRwgy1gaetmwyfjij30u01t0thz.jpg" srcset="/img/loading.gif" alt=""><br>圆满结束此次行程。</p><h2 id="统计此次旅游花销"><a href="#统计此次旅游花销" class="headerlink" title="统计此次旅游花销"></a>统计此次旅游花销</h2><table><thead><tr><th>用途</th><th>费用</th><th>费用链接</th><th>说明</th></tr></thead><tbody><tr><td>租车</td><td>1585</td><td><a href="https://www.jxhs.me/img/newimg/006tNbRwgy1gadzv3kfawj30u01hcjtp.jpg">https://www.jxhs.me/img/newimg/006tNbRwgy1gadzv3kfawj30u01hcjtp.jpg</a> <br> <a href="https://www.jxhs.me/img/newimg/006tNbRwgy1gadzvht35qj30u01hcdi0.jpg">https://www.jxhs.me/img/newimg/006tNbRwgy1gadzvht35qj30u01hcdi0.jpg</a></td><td>无</td></tr><tr><td>提前买的零食水果</td><td>637.7</td><td><a href="https://www.jxhs.me/img/newimg/006tNbRwly1gacweq4klwj30ku112ad4.jpg">https://www.jxhs.me/img/newimg/006tNbRwly1gacweq4klwj30ku112ad4.jpg</a> <br> <a href="https://www.jxhs.me/img/newimg/006tNbRwly1gacwfa1tqhj30ku112mzr.jpg">https://www.jxhs.me/img/newimg/006tNbRwly1gacwfa1tqhj30ku112mzr.jpg</a> <br> <a href="https://www.jxhs.me/img/newimg/006tNbRwly1gacwffkh95j30ku112776.jpg">https://www.jxhs.me/img/newimg/006tNbRwly1gacwffkh95j30ku112776.jpg</a> <br> <a href="https://www.jxhs.me/img/newimg/006tNbRwly1gacwfkbayuj30ku0t90v0.jpg">https://www.jxhs.me/img/newimg/006tNbRwly1gacwfkbayuj30ku0t90v0.jpg</a> <br> <a href="https://www.jxhs.me/img/newimg/006tNbRwly1gacwfsxpcmj30ku112jt6.jpg">https://www.jxhs.me/img/newimg/006tNbRwly1gacwfsxpcmj30ku112jt6.jpg</a></td><td>买的有点多…下次主意</td></tr><tr><td>出发前买的两箱水和槟榔</td><td>144</td><td><a href="https://www.jxhs.me/img/newimg/006tNbRwly1gacwi8yuk1j30hs0i5mxl.jpg">https://www.jxhs.me/img/newimg/006tNbRwly1gacwi8yuk1j30hs0i5mxl.jpg</a></td><td>无</td></tr><tr><td>七座车停车高速加油以及零食</td><td>420</td><td><a href="https://www.jxhs.me/img/newimg/006tNbRwly1gacwm2zgocj30u00rzdh0.jpg">https://www.jxhs.me/img/newimg/006tNbRwly1gacwm2zgocj30u00rzdh0.jpg</a> <br> <a href="https://www.jxhs.me/img/newimg/006tNbRwly1gacwmdji4rj30u01t0juy.jpg">https://www.jxhs.me/img/newimg/006tNbRwly1gacwmdji4rj30u01t0juy.jpg</a> <br> <a href="https://www.jxhs.me/img/newimg/006tNbRwly1gacwjm7or2j30ac03qt8t.jpg">https://www.jxhs.me/img/newimg/006tNbRwly1gacwjm7or2j30ac03qt8t.jpg</a></td><td>无</td></tr><tr><td>五座车停车高速加油以及零食</td><td>594</td><td><a href="https://www.jxhs.me/img/newimg/006tNbRwly1gacwob90cxj315k0ne0wd.jpg">https://www.jxhs.me/img/newimg/006tNbRwly1gacwob90cxj315k0ne0wd.jpg</a> <br> <a href="https://www.jxhs.me/img/newimg/006tNbRwly1gacwp1igzhj30n80gqthu.jpg">https://www.jxhs.me/img/newimg/006tNbRwly1gacwp1igzhj30n80gqthu.jpg</a></td><td>无</td></tr><tr><td>周五住宿</td><td>720</td><td>图随后补上</td><td>无</td></tr><tr><td>快艇,以及停车</td><td>740</td><td><a href="https://www.jxhs.me/img/newimg/006tNbRwly1gacwr8zl7rj30gc0agjth.jpg">https://www.jxhs.me/img/newimg/006tNbRwly1gacwr8zl7rj30gc0agjth.jpg</a> <br> <a href="https://www.jxhs.me/img/newimg/006tNbRwly1gacwryed83j30hs0fwq38.jpg">https://www.jxhs.me/img/newimg/006tNbRwly1gacwryed83j30hs0fwq38.jpg</a></td><td>无</td></tr><tr><td>码头农家乐</td><td>500</td><td><a href="https://www.jxhs.me/img/newimg/006tNbRwly1gacwt8jmh2j30hs093q30.jpg">https://www.jxhs.me/img/newimg/006tNbRwly1gacwt8jmh2j30hs093q30.jpg</a></td><td>老板只收微信,冯睿先给的.我转他支付宝</td></tr><tr><td>周六住宿</td><td>720</td><td>图随后补上</td><td>无</td></tr><tr><td>周六晚餐</td><td>400</td><td><a href="https://www.jxhs.me/img/newimg/006tNbRwly1gacwuwb6b2j30hs0vk0u2.jpg">https://www.jxhs.me/img/newimg/006tNbRwly1gacwuwb6b2j30hs0vk0u2.jpg</a></td><td>袁昭没吃,结算的时候去掉他</td></tr><tr><td>周日早餐</td><td>145</td><td><a href="https://www.jxhs.me/img/newimg/006tNbRwgy1gadznrxc2xj30hs0ifmxu.jpg">https://www.jxhs.me/img/newimg/006tNbRwgy1gadznrxc2xj30hs0ifmxu.jpg</a>  <br> <a href="https://www.jxhs.me/img/newimg/006tNbRwgy1gadzox818ej30ku112tah.jpg">https://www.jxhs.me/img/newimg/006tNbRwgy1gadzox818ej30ku112tah.jpg</a></td><td>李刚夫妇没吃,结算去掉</td></tr><tr><td>早上牛奶</td><td>156</td><td><a href="https://www.jxhs.me/img/newimg/006tNbRwgy1gadzyc5pwjj30u01t0wkw.jpg">https://www.jxhs.me/img/newimg/006tNbRwgy1gadzyc5pwjj30u01t0wkw.jpg</a></td><td>订单跟私人订单混合,下次主意分开。</td></tr><tr><td>蹦床娱乐费用</td><td>731</td><td><a href="https://www.jxhs.me/img/newimg/006tNbRwgy1gadzs30pe7j30hs0gs3z0.jpg">https://www.jxhs.me/img/newimg/006tNbRwgy1gadzs30pe7j30hs0gs3z0.jpg</a></td><td>向莉没去 结算去掉</td></tr><tr><td>周日午饭</td><td>272</td><td><a href="https://www.jxhs.me/img/newimg/006tNbRwgy1gadzs9mzn9j30hs0vkab9.jpg">https://www.jxhs.me/img/newimg/006tNbRwgy1gadzs9mzn9j30hs0vkab9.jpg</a></td><td>老湿自己付的钱 单独给了 但是都吃了</td></tr><tr><td>回来加油费用</td><td>665</td><td><a href="https://www.jxhs.me/img/newimg/006tNbRwgy1gadzxnp4njj30u01t0q6l.jpg">https://www.jxhs.me/img/newimg/006tNbRwgy1gadzxnp4njj30u01t0q6l.jpg</a> <br> <a href="https://www.jxhs.me/img/newimg/006tNbRwgy1gadzxtkjyfj309k0a3dg5.jpg">https://www.jxhs.me/img/newimg/006tNbRwgy1gadzxtkjyfj309k0a3dg5.jpg</a></td><td>无</td></tr></tbody></table><p>总计  8429.7<br>向莉 : 596.2 +  13.2 + 36.4   =  645.4<br>李刚夫妇: 596.2 + 66.5 + 36.4  =  699.1<br>袁昭: 596.2  + 66.5 + 13.2    =  675.9</p><p>其他人<br>596.2 +  66.5 + 13.2 + 36.4 = 712.3</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>对于程序员来说个人宽带可以怎么利用?</title>
    <link href="/2019/12/11/%E5%AF%B9%E4%BA%8E%E7%A8%8B%E5%BA%8F%E5%91%98%E6%9D%A5%E8%AF%B4%E4%B8%AA%E4%BA%BA%E5%AE%BD%E5%B8%A6%E5%8F%AF%E4%BB%A5%E6%80%8E%E4%B9%88%E5%88%A9%E7%94%A8/"/>
    <url>/2019/12/11/%E5%AF%B9%E4%BA%8E%E7%A8%8B%E5%BA%8F%E5%91%98%E6%9D%A5%E8%AF%B4%E4%B8%AA%E4%BA%BA%E5%AE%BD%E5%B8%A6%E5%8F%AF%E4%BB%A5%E6%80%8E%E4%B9%88%E5%88%A9%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">目前在上海，家里有一个nas 和一些中日老师的学习视频，想在任何地方都获取知识.目前了解到的现状如下:<br>上海用的宽带都是SDN网络,全是内网<br>家里<span class="hljs-number">200</span>M的网虽然上下不对等，但是上行也有<span class="hljs-number">30</span>多M。如果用NAT穿透只能用我阿里云<span class="hljs-number">1</span>M小水管。不甘心<br></code></pre></div></td></tr></table></figure><h3 id="各种打听"><a href="#各种打听" class="headerlink" title="各种打听"></a>各种打听</h3><figure class="highlight armasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs armasm">首先打听到SDN网络可以让运营商转为桥接,跟他说光纤转桥接就行(电信运营商电话打到人工客服真不容易)<br>然后就有人跟你约时间上门调试,结果发现只是签字。网是后台直接调的。<br>然后你会发现，给你的网是内网。这时候继续给电信运营商打电话，说需要一个工网<span class="hljs-built_in">ip</span><br>他们会问你为啥需要工网<span class="hljs-keyword">balbalabala的。告诉他我家里有一个NAS需要在办公室访问就OK</span><br></code></pre></div></td></tr></table></figure><blockquote><p>此时路由器外面的就是工网IP了。然后路由器映射一下。就OK了。</p></blockquote><hr><p><img src="/img/newimg/006tNbRwgy1g9vhy02n31j31w10u07ab.jpg" srcset="/img/loading.gif" alt="路由器"><br><img src="/img/newimg/006tNbRwgy1g9vhyizmjvj31z20ms795.jpg" srcset="/img/loading.gif" alt="nginx"><br><img src="/img/newimg/006tNbRwgy1g9vhze8ngxj316a0jsad9.jpg" srcset="/img/loading.gif" alt="ip"><br><img src="/img/newimg/006tNbRwgy1g9vhyizmjvj31z20ms795.jpg" srcset="/img/loading.gif" alt="外部nginx"></p><p><img src="/img/newimg/006tNbRwgy1g9vhzw9ijhj31yk0m4gqn.jpg" srcset="/img/loading.gif" alt="docker内部架构图"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>命令行翻墙</title>
    <link href="/2019/12/11/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BF%BB%E5%A2%99/"/>
    <url>/2019/12/11/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BF%BB%E5%A2%99/</url>
    
    <content type="html"><![CDATA[<h2 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h2><blockquote><p>啥也不说，先上图。这样的痛苦 国内程序员应该都体会过<br><img src="/img/newimg/006tNbRwgy1g9t78ifnifj30to04gdhe.jpg" srcset="/img/loading.gif" alt="git clone"></p></blockquote><h2 id="共具介绍"><a href="#共具介绍" class="headerlink" title="共具介绍"></a>共具介绍</h2><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">对于技术人员<span class="hljs-keyword">shadowsocks应该不陌生，shadowsocks实质上也是一种socks5代理服务，类似于ssh代理。</span><br><span class="hljs-keyword"></span><br><span class="hljs-keyword">与vpn的全局代理不同，shadowsocks仅针对浏览器代理，不能代理应用软件，比如curl、wget等一些命令行软件。如果要让终端下的命令行工具都能支持代理，这时我们就要用上proxychains-ng这款神器了。</span><br></code></pre></div></td></tr></table></figure><h3 id="什么是-proxychains-ng"><a href="#什么是-proxychains-ng" class="headerlink" title="什么是 proxychains-ng"></a>什么是 proxychains-ng</h3><p>项目主页：<a href="https://github.com/rofl0r/proxychains-ng" target="_blank" rel="noopener">https://github.com/rofl0r/proxychains-ng</a></p><h3 id="proxychains-ng-介绍"><a href="#proxychains-ng-介绍" class="headerlink" title="proxychains-ng 介绍"></a>proxychains-ng 介绍</h3><blockquote><p>proxychains ng (new generation) - a preloader which hooks calls to sockets in dynamically linked programs and redirects it through one or more socks/http proxies. continuation of the unmaintained proxychains project.</p></blockquote><p>proxychains-ng是proxychains的加强版，主要有以下功能和不足：</p><ul><li>支持http/https/socks4/socks5</li><li>支持认证</li><li>远端dns查询</li><li>多种代理模式</li><li>不支持udp/icmp转发</li><li>少部分程序和在后台运行的可能无法代理</li></ul><h3 id="proxychains-ng-原理"><a href="#proxychains-ng-原理" class="headerlink" title="proxychains-ng 原理"></a>proxychains-ng 原理</h3><p>简单的说就是这个程序 Hook 了 sockets 相关的操作，让普通程序的 sockets 数据走 SOCKS/HTTP 代理。</p><p>其核心就是利用了 LD_PRELOAD 这个环境变量（Mac 上是 DYLD_INSERT_LIBRARIES）。</p><p>在 Unix 系统中，如果设置了 LD_PRELOAD 环境变量，那么在程序运行时，动态链接器会先加载该环境变量所指定的动态库。也就是说，这个动态库的加载优先于任何其它的库，包括 libc。</p><p>ProxyChains 创建了一个叫 libproxychains4.so（Mac 上是 libproxychains4.dylib）的动态库。里面重写了 connect、close 以及 sendto 等与 socket 相关的函数，通过这些函数发出的数据将会走代理，详细代码可以参考 libproxychains.c。</p><p>在主程序里，它会读取配置文件，查找 libproxychains4 所在位置，把这些信息存入环境变量后执行子程序。这样子程序里对 socket 相关的函数调用就会被 Hook 了，对子程序来说，跟代理相关的东西都是透明的。</p><h2 id="安装-proxychains-ng"><a href="#安装-proxychains-ng" class="headerlink" title="安装 proxychains-ng"></a>安装 proxychains-ng</h2><h3 id="源代码安装"><a href="#源代码安装" class="headerlink" title="源代码安装"></a>源代码安装</h3><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">git clone http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/rofl0r/proxychains-ng<br>./configure --prefix=/usr --sysconfdir=/etc<br><span class="hljs-keyword">make</span><br><span class="hljs-keyword">make</span> install<br><span class="hljs-keyword">make</span> install-config (安装proxychains.<span class="hljs-keyword">conf</span>配置文件)<br></code></pre></div></td></tr></table></figure><h3 id="MAC下安装"><a href="#MAC下安装" class="headerlink" title="MAC下安装"></a>MAC下安装</h3><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>proxychains-ng<br></code></pre></div></td></tr></table></figure><h3 id="配置-proxychains-ng"><a href="#配置-proxychains-ng" class="headerlink" title="配置 proxychains-ng"></a>配置 proxychains-ng</h3><p>proxychains-ng默认配置文件名为<code>proxychains.conf</code></p><ul><li>通过源代码编译安装的默认为<code>/etc/proxychains.conf</code></li><li>Mac下用Homebrew安装的默认为<code>/usr/local/etc/proxychains.conf</code></li></ul><p>proxychains-ng的配置非常简单，只需将代理加入[ProxyList]中即可。</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">$ vim proxychains.conf<br><br>quiet_mode<br>dynamic_chain<br>chain_len = <span class="hljs-number">1</span> #round_robin_chain和random_chain使用<br>proxy_dns<br>remote_dns_subnet <span class="hljs-number">224</span><br>tcp_read_time_out <span class="hljs-number">15000</span><br>tcp_connect_time_out <span class="hljs-number">8000</span><br>localnet <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>/<span class="hljs-number">255.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br>localnet <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>/<span class="hljs-number">255.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br>localnet <span class="hljs-number">172.16</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>/<span class="hljs-number">255.240</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br>localnet <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>/<span class="hljs-number">255.255</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br><br>[ProxyList]<br>socks5  <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-number">1086</span><br>http    <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-number">1087</span><br></code></pre></div></td></tr></table></figure><p>proxychains-ng支持多种代理模式,默认是选择 strict_chain。</p><ul><li>dynamic_chain ：动态模式,按照代理列表顺序自动选取可用代理</li><li>strict_chain ：严格模式,严格按照代理列表顺序使用代理，所有代理必须可用</li><li>round_robin_chain ：轮询模式，自动跳过不可用代理</li><li>random_chain ：随机模式,随机使用代理<h3 id="proxychains-ng-使用"><a href="#proxychains-ng-使用" class="headerlink" title="proxychains-ng 使用"></a>proxychains-ng 使用</h3></li></ul><p>proxychains-ng用法非常简单，使用格式如下:</p><figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode">proxychai<span class="hljs-symbol">ns4</span> 程序 参数<br></code></pre></div></td></tr></table></figure><h3 id="proxychains-ng-测试"><a href="#proxychains-ng-测试" class="headerlink" title="proxychains-ng 测试"></a>proxychains-ng 测试</h3><figure class="highlight armasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">proxychains4</span> curl <span class="hljs-built_in">ip</span>.sb<br></code></pre></div></td></tr></table></figure><h3 id="proxychains-ng-优化"><a href="#proxychains-ng-优化" class="headerlink" title="proxychains-ng 优化"></a>proxychains-ng 优化</h3><p>给proxychains4增加一个别名，在 /.zshrc或/.bashrc末尾加入如下行：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">alias</span> pc=<span class="hljs-string">'proxychains4'</span><br></code></pre></div></td></tr></table></figure><p>以后就可以类似$ pc curl <a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a>  这样调用proxychains4，简化了输入。</p><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>小米路由器3增强版刷机踩坑记录</title>
    <link href="/2019/12/07/%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A83%E5%A2%9E%E5%BC%BA%E7%89%88%E5%88%B7%E6%9C%BA%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <url>/2019/12/07/%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A83%E5%A2%9E%E5%BC%BA%E7%89%88%E5%88%B7%E6%9C%BA%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p><code>首先我想说明一点，本博客是踩坑的记录。安装文档网上的基本都能用，为了文章的完整性还是写上安装步骤。</code></p><h2 id="排坑过程"><a href="#排坑过程" class="headerlink" title="排坑过程"></a>排坑过程</h2><p>本次主要以为小米路由器3G(R3G)为例</p><h3 id="坑1"><a href="#坑1" class="headerlink" title="坑1"></a>坑1</h3><p>原版路由器先刷官方开发版ROM（开发版才能打开ssh通道）小米路由器ROM</p><figure class="highlight elixir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elixir">坑<span class="hljs-number">1</span><span class="hljs-symbol">:</span>小米官方以及下架了刷ROM开发版的页面,已经找不到了。<br>解决方案: 万能的网友有存档。我也在百度存了一份<br>链接<span class="hljs-symbol">:https</span><span class="hljs-symbol">://pan</span>.baidu.com/s/<span class="hljs-number">1</span>MGL8dJ_QfU4ytY8U0xz6fw  密码<span class="hljs-symbol">:oc9b</span><br></code></pre></div></td></tr></table></figure><p><img src="/img/newimg/006tNbRwgy1g9omfgrukyj316i0ac40u.jpg" srcset="/img/loading.gif" alt="百度云"></p><h3 id="坑2"><a href="#坑2" class="headerlink" title="坑2"></a>坑2</h3><p>刷完开发版系统以后,就可以安装官方的ssh插件开启ssh功能了<a href="https://d.miwifi.com/rom/ssh" target="_blank" rel="noopener">ssh</a></p><p><img src="/img/newimg/006tNbRwgy1g9omhu2hjqj319i0rytds.jpg" srcset="/img/loading.gif" alt="ssh"></p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">坑2:官网提醒下载miwifi_ssh.bin,结果我手贱点了两下，并且还把第一个删掉了只剩下一个这个<br>坑的就是这个括号前面还有一个空格<span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>导致怎么都开启不了ssh。光这个就折腾了两天<br></code></pre></div></td></tr></table></figure><p><img src="/img/newimg/006tNbRwgy1g9omlhqsrbj30ci02k3yi.jpg" srcset="/img/loading.gif" alt="ssh1"></p><h3 id="坑3"><a href="#坑3" class="headerlink" title="坑3"></a>坑3</h3><p>开启完ssh 放入不死boot刷完以后。备份原来的系统就可以刷新系统了，比如我提供的潘多拉。</p><figure class="highlight lasso"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lasso">刷完以后看到网上都能直接以 http:<span class="hljs-comment">//192.168.123.1 admin/admin 访问</span><br>可是我这边怎么都不行，但是路由器已经能使得连上他的能上网了。<br>一直以为是功能没刷完整导致的。于是各种搜各种刷，无济于事。<br>最后特么发现是chrome不支持而已。。firefox以及mac自带的safari都可以打开<span class="hljs-params">...</span><span class="hljs-params">...</span>..<br></code></pre></div></td></tr></table></figure><p><img src="/img/newimg/006tNbRwgy1g9omri1nklj31nl0u0qoi.jpg" srcset="/img/loading.gif" alt="chrome vs firefox"></p><p>最后上一张刷好以后的后台界面,目前支持的功能非常多。要是碰巧你在会玩点儿，那就简直牛的离谱了。(以后别买小米的路由器…)<br><img src="/img/newimg/006tNbRwgy1g9omvt373hj31i30u048u.jpg" srcset="/img/loading.gif" alt="chrome vs firefox"></p>]]></content>
    
    
    
    <tags>
      
      <tag>杂项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>热重启docker</title>
    <link href="/2019/11/29/%E7%83%AD%E9%87%8D%E5%90%AFdocker/"/>
    <url>/2019/11/29/%E7%83%AD%E9%87%8D%E5%90%AFdocker/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>众所周知，由于docker架构原因,docker是有守护进程的。而所有的容器进程父进程都是这个守护进程,如下图:<br><img src="https://i.loli.net/2019/11/29/JrG9j7QxCK1HpAL.png" srcset="/img/loading.gif" alt="docker架构"></p><p>这样的蠢架构导致了很多问题:</p><ul><li>生产环境docker内存泄漏无法处理或者处理繁琐</li><li>升级生产docker版本繁琐</li></ul><p>从docker 1.12以后更新了热更新的配置,虽然架构还是不咋地,但是至少解决了以上问题</p><h2 id="热更新配置"><a href="#热更新配置" class="headerlink" title="热更新配置"></a>热更新配置</h2><h3 id="Step-1-使用-docker-live-restore-amp-amp-SIGHU-reload-配置"><a href="#Step-1-使用-docker-live-restore-amp-amp-SIGHU-reload-配置" class="headerlink" title="Step 1. 使用 docker live restore &amp;&amp; SIGHU reload 配置"></a>Step 1. 使用 docker live restore &amp;&amp; SIGHU reload 配置</h3><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">配置 live restore 到 /etc/docker/daemon.json （注意加逗号）<br>&#123; <span class="hljs-string">"live-restore"</span>: <span class="hljs-literal">true</span> &#125;<br>reload  docker 配置【⚠️：要先做这步，才能重启！！】<br>kill -SIGHUP <span class="hljs-constructor">$(<span class="hljs-params">pidof</span> <span class="hljs-params">dockerd</span>)</span><br>检查配置<br>docker info <span class="hljs-pattern-match">| grep -i <span class="hljs-constructor">Live</span></span><br></code></pre></div></td></tr></table></figure><p>应该能看到如下配置</p><p><img src="https://i.loli.net/2019/11/29/sY31qC4miSgWGHF.png" srcset="/img/loading.gif" alt="image.png"></p><p>重启 docker<br>systemctl restart docker</p><p>注意 </p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">重启 docker 后请 <span class="hljs-builtin-name">disable</span> live-restore ！<br></code></pre></div></td></tr></table></figure><p>设置  /etc/docker/daemon.json 参数 live-restore 为 false， “live-restore”: false<br>reload： kill -SIGHUP $(pidof dockerd)<br>检查：docker info | grep Live，确认是false</p><h3 id="Step-2-重启直接挂载-var-run-docker-sock的容器"><a href="#Step-2-重启直接挂载-var-run-docker-sock的容器" class="headerlink" title="Step 2. 重启直接挂载/var/run/docker.sock的容器"></a>Step 2. 重启直接挂载/var/run/docker.sock的容器</h3><p>查看该主机上直接挂载 docker.sock 的容器   </p><p>docker inspect $(docker ps -q)|grep ‘Source.*docker.sock|Name”: “/‘|grep sock -B1|grep Name<br>重启之</p><p>【理论分析】<br>[原因] 因为挂载了/var/run/docker.sock文件，docker机制是绑定主机上该文件的 inode。当docker-engine热重启，该文件的inode改变，所以容器内部所认的这个inode事实上已经木有用了。 所以跟docker.sock相关的功能：容器控制台/容器日志等都无法工作。（例如你的docker的挂载了一个主机文件，当你删除该主机文件并重建之后，docker内部是看不到新文件的！ 如果挂载的是其目录则不会有这个问题。）</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>重启完之后，记得把配置再改回去</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>k8s v1.17 新特性预告: 拓扑感知服务路由</title>
    <link href="/2019/11/28/k8s-v1-17-%E6%96%B0%E7%89%B9%E6%80%A7%E9%A2%84%E5%91%8A-%E6%8B%93%E6%89%91%E6%84%9F%E7%9F%A5%E6%9C%8D%E5%8A%A1%E8%B7%AF%E7%94%B1/"/>
    <url>/2019/11/28/k8s-v1-17-%E6%96%B0%E7%89%B9%E6%80%A7%E9%A2%84%E5%91%8A-%E6%8B%93%E6%89%91%E6%84%9F%E7%9F%A5%E6%9C%8D%E5%8A%A1%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<p align="right">转摘自roc   https://imroc.io</p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul><li>拓扑域: 表示在集群中的某一类 “地方”，比如某节点、某机架、某可用区或某地域等，这些都可以作为某种拓扑域。</li><li>endpoint: k8s 某个服务的某个 ip+port，通常是 pod 的 ip+port。</li><li>service: k8s 的 service 资源(服务)，关联一组 endpoint ，访问 service 会被转发到关联的某个 endpoint 上。</li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>拓扑感知服务路由，此特性最初由杜军大佬提出并设计。为什么要设计此特性呢？想象一下，k8s 集群节点分布在不同的地方，service 对应的 endpoints 分布在不同节点，传统转发策略会对所有 endpoint 做负载均衡，通常会等概率转发，当访问 service 时，流量就可能被分散打到这些不同的地方。虽然 service 转发做了负载均衡，但如果 endpoint 距离比较远，流量转发过去网络时延就相对比较高，会影响网络性能，在某些情况下甚至还可能会付出额外的流量费用。要是如能实现 service 就近转发 endpoint，是不是就可以实现降低网络时延，提升网络性能了呢？是的！这也正是该特性所提出的目的和意义。</p><h2 id="k8s-亲和性"><a href="#k8s-亲和性" class="headerlink" title="k8s 亲和性"></a>k8s 亲和性</h2><p>service 的就近转发实际就是一种网络的亲和性，倾向于转发到离自己比较近的 endpoint。在此特性之前，已经在调度和存储方面有一些亲和性的设计与实现:</p><ul><li>节点亲和性 (Node Affinity): 让 Pod 被调度到符合一些期望条件的 Node 上，比如限制调度到某一可用区，或者要求节点支持 GPU，这算是调度亲和，调度结果取决于节点属性。</li><li>Pod 亲和性与反亲和性 (Pod Affinity/AntiAffinity): 让一组 Pod 调度到同一拓扑域的节点上，或者打散到不同拓扑域的节点， 这也算是调度亲和，调度结果取决于其它 Pod。</li><li>数据卷拓扑感知调度 (Volume Topology-aware Scheduling): 让 Pod 只被调度到符合其绑定的存储所在拓扑域的节点上，这算是调度与存储的亲和，调度结果取决于存储的拓扑域。</li><li>本地数据卷 (Local Persistent Volume): 让 Pod 使用本地数据卷，比如高性能 SSD，在某些需要高 IOPS 低时延的场景很有用，它还会保证 Pod 始终被调度到同一节点，数据就不会不丢失，这也算是调度与存储的亲和，调度结果取决于存储所在节点。</li><li>数据卷拓扑感知动态创建 (Topology-Aware Volume Dynamic Provisioning): 先调度 Pod，再根据 Pod 所在节点的拓扑域来创建存储，这算是存储与调度的亲和，存储的创建取决于调度的结果。</li></ul><p>而 k8s 目前在网络方面还没有亲和性能力，拓扑感知服务路由这个新特性恰好可以补齐这个的空缺，此特性使得 service 可以实现就近转发而不是所有 endpoint 等概率转发。</p><h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><p>我们知道，service 转发主要是 node 上的 kube-proxy 进程通过 watch apiserver 获取 service 对应的 endpoint，再写入 iptables 或 ipvs 规则来实现的; 对于 headless service，主要是通过 kube-dns 或 coredns 动态解析到不同 endpoint ip 来实现的。实现 service 就近转发的关键点就在于如何将流量转发到跟当前节点在同一拓扑域的 endpoint 上，也就是会进行一次 endpoint 筛选，选出一部分符合当前节点拓扑域的 endpoint 进行转发。</p><p>那么如何判断 endpoint 跟当前节点是否在同一拓扑域里呢？只要能获取到 endpoint 的拓扑信息，用它跟当前节点拓扑对比下就可以知道了。那又如何获取 endpoint 的拓扑信息呢？答案是通过 endpoint 所在节点的 label，我们可以使用 node label 来描述拓扑域。</p><p>通常在节点初始化的时候，controller-manager 就会为节点打上许多 label，比如 <code>kubernetes.io/hostname</code> 表示节点的 hostname 来区分节点；另外，在云厂商提供的 k8s 服务，或者使用 cloud-controller-manager 的自建集群，通常还会给节点打上 <code>failure-domain.beta.kubernetes.io/zone</code> 和 <code>failure-domain.beta.kubernetes.io/region</code> 以区分节点所在可用区和所在地域，但自 v1.17 开始将会改名成 <code>topology.kubernetes.io/zon</code>e 和 <code>topology.kubernetes.io/region</code>，参见 <a href="https://github.com/kubernetes/kubernetes/pull/81431" target="_blank" rel="noopener">PR #81431</a>。</p><p>如何根据 endpoint 查到它所在节点的这些 label 呢？答案是通过 <code>Endpoint Slice</code>，该特性在 v1.16 发布了 alpha，在 v1.17 将会进入 beta，它相当于 Endpoint API 增强版，通过将 endpoint 做数据分片来解决大规模 endpoint 的性能问题，并且可以携带更多的信息，包括 endpoint 所在节点的拓扑信息，拓扑感知服务路由特性会通过 <code>Endpoint Slice</code> 获取这些拓扑信息实现 endpoint 筛选 (过滤出在同一拓扑域的 endpoint)，然后再转换为 iptables 或 ipvs 规则写入节点以实现拓扑感知的路由转发。</p><p>细心的你可能已经发现，之前每个节点上转发 service 的 iptables/ipvs 规则基本是一样的，但启用了拓扑感知服务路由特性之后，每个节点上的转发规则就可能不一样了，因为不同节点的拓扑信息不一样，导致过滤出的 endpoint 就不一样，也正是因为这样，service 转发变得不再等概率，灵活的就近转发才得以实现。</p><p>当前还不支持 headless service 的拓扑路由，计划在 beta 阶段支持。由于 headless service 不是通过 kube-proxy 生成转发规则，而是通过 dns 动态解析实现的，所以需要改 kube-dns/coredns 来支持这个特性。</p><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>启用当前 alpha 实现的拓扑感知服务路由特性需要满足以下前提条件:</p><ul><li>集群版本在 v1.17 及其以上。</li><li>Kube-proxy 以 iptables 或 IPVS 模式运行 (alpha 阶段暂时只实现了这两种模式)。</li><li>启用了 <a href="https://kubernetes.io/docs/concepts/services-networking/endpoint-slices/" target="_blank" rel="noopener">Endpoint Slices</a> (此特性虽然在 v1.17 进入 beta，但没有默认开启)。</li></ul><h2 id="如何启用此特性"><a href="#如何启用此特性" class="headerlink" title="如何启用此特性"></a>如何启用此特性</h2><p>给所有 k8s 组件打开 <code>ServiceTopology</code> 和 <code>EndpointSlice</code> 这两个 feature:</p><figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">--feature-gates</span>=<span class="hljs-string">"ServiceTopology=true,EndpointSlice=true"</span><br></code></pre></div></td></tr></table></figure><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>在 Service spec 里加上 <code>topologyKeys</code> 字段，表示该 Service 优先顺序选用的拓扑域列表，对应节点标签的 key；当访问此 Service 时，会找是否有 endpoint 有对应 topology key 的拓扑信息并且 value 跟当前节点也一样，如果是，那就选定此 topology key 作为当前转发的拓扑域，并且筛选出其余所有在这个拓扑域的 endpoint 来进行转发；如果没有找到任何 endpoint 在当前 topology key 对应拓扑域，就会尝试第二个 topology key，依此类推；如果遍历完所有 topology key 也没有匹配到 endpoint 就会拒绝转发，就像此 service 没有后端 endpoint 一样。</p><p>有一个特殊的 topology key “<em>“，它可以匹配所有 endpoint，如果 <code>topologyKeys</code> 包含了 `</em>`，它必须在列表末尾，通常是在没有匹配到合适的拓扑域来实现就近转发时，就打消就近转发的念头，可以转发到任意 endpoint 上。</p><p>当前 topology key 支持以下可能的值（未来会增加更多）:</p><ul><li>kubernetes.io/hostname: 节点的 hostname，通常将它放列表中第一个，表示如果本机有 endpoint 就直接转发到本机的 endpoint。</li><li>topology.kubernetes.io/zone: 节点所在的可用区，通常将它放在 kubernetes.io/hostname 后面，表示如果本机没有对应 endpoint，就转发到当前可用区其它节点上的 endpoint（部分云厂商跨可用区通信会收取额外的流量费用）。</li><li>topology.kubernetes.io/region: 表示节点所在的地域，表示转发到当前地域的 endpoint，这个用的应该会比较少，因为通常集群所有节点都只会在同一个地域，如果节点跨地域了，节点之间通信延时将会很高。</li><li>*: 忽略拓扑域，匹配所有 endpoint，相当于一个保底策略，避免丢包，只能放在列表末尾。</li></ul><p>除此之外，还有以下约束:</p><ul><li>topologyKeys 与 externalTrafficPolicy=Local 不兼容，是互斥的，如果 externalTrafficPolicy 为 Local，就不能定义 topologyKeys，反之亦然。</li><li>topology key 必须是合法的 label 格式，并且最多定义 16 个 key。</li></ul><p>这里给出一个简单的 Service 示例:</p><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-attribute">apiVersion</span>: v1<br><span class="hljs-attribute">kind</span>: Service<br><span class="hljs-attribute">metadata</span>:<br>  <span class="hljs-attribute">name</span>: nginx<br><span class="hljs-attribute">spec</span>:<br>  <span class="hljs-attribute">type</span>: ClusterIP<br>  <span class="hljs-attribute">ports</span>:<br>  - <span class="hljs-attribute">name</span>: http<br>    <span class="hljs-attribute">port</span>: <span class="hljs-number">80</span><br>    <span class="hljs-attribute">protocol</span>: TCP<br>    <span class="hljs-attribute">targetPort</span>: <span class="hljs-number">80</span><br>  <span class="hljs-attribute">selector</span>:<br>    <span class="hljs-attribute">app</span>: nginx<br>  <span class="hljs-attribute">topologyKeys</span>: [<span class="hljs-string">"kubernetes.io/hostname"</span>, <span class="hljs-string">"topology.kubernetes.io/zone"</span>, <span class="hljs-string">"*"</span>]<br></code></pre></div></td></tr></table></figure><p>解释: 当访问 nginx 服务时，首先看本机是否有这个服务的 endpoint，如果有就直接本机路由过去；如果没有，就看是否有 endpoint 位于当前节点所在可用区，如果有，就转发过去，如果还是没有，就转发给任意 endpoint。<br><img src="/img/newimg/006y8mN6gy1g9dkunyvsqj30na0h20sy.jpg" srcset="/img/loading.gif" alt="endpoint"></p><p>上图就是其中一次转发的例子：Pod 访问 nginx 这个 service 时，发现本机没有 endpoint，就找当前可用区的，找到了就转发过去，也就不会考虑转发给另一可用区的 endpoint。</p><h2 id="背后小故事"><a href="#背后小故事" class="headerlink" title="背后小故事"></a>背后小故事</h2><p>此特性的 KEP Proposal 最终被认可（合并）时的设计与当前最终的代码实现已经有一些差别，实现方案历经一变再变，但同时也推动了其它特性的发展，我来讲下这其中的故事。</p><p>一开始设计是在 alpha 时，让 kube-proxy 直接暴力 watch node，每个节点都有一份全局的 node 的缓存，通过 endpoint 的 <code>nodeName</code> 字段找到对应的 node 缓存，再查 node 包含的 label 就可以知道该 endpoint 的拓扑域了，但在集群节点数量多的情况下，kube-proxy 将会消耗大量资源，不过优点是实现上很简单，可以作为 alpha 阶段的实现，beta 时再从 watch node 切换到 watch 一个新设计的 PodLocator API，作为拓扑信息存储的中介，避免 watch 庞大的 node。</p><p>实际上一开始我也是按照 watch node 的方式，花了九牛二虎之力终于实现了这个特性，后来 v1.15 时 k8s 又支持了 metadata-only watch，参见 PR 71548，利用此特性可以仅仅 watch node 的 metadata，而不用 watch 整个 node，可以极大减小传输和缓存的数据量，然后我就将实现切成了 watch node metadata; 即便如此，metadata 还是会更新比较频繁，主要是 <code>resourceVersion</code> 会经常变 (kubelet 经常上报 node 状态)，所以虽然 watch node metadata 比 watch node 要好，但也还是可能会造成大量不必要的网络流量，但作为 alpha 实现是可以接受的。</p><p>可惜在 v1.16 code freeze 之前没能将此特性合进去，只因有一点小细节还没讨论清楚。 实际在实现 watch node 方案期间，Endpoint Slice 特性就提出来了，在这个特性讨论的阶段，我们就想到了可以利用它来携带拓扑信息，以便让拓扑感知服务路由这个特性后续可以直接利用 Endpoint Slice 来获取拓扑信息，也就可以替代之前设计的 PodLocator API，但由于它还处于很早期阶段，并且代码还未合并进去，所以 alpha 阶段先不考虑 watch Endpint Slice。后来，Endpoint Slice 特性在 v1.16 发布了 alpha。</p><p>由于 v1.16 没能将拓扑感知服务路由特性合进去，在 v1.17 周期开始后，有更多时间来讨论小细节，并且 Endpoint Slice 代码已经合并，我就干脆直接又将实现从 watch node metadata 切成了 watch Endpint Slice，在 alpha 阶段就做了打算在 beta 阶段做的事情，终于，此特性实现代码最终合进了主干。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>拓扑感知服务路由可以实现 service 就近转发，减少网络延时，进一步提升 k8s 的网络性能，此特性将于 k8s v1.17 发布 alpha，时间是 12 月上旬，让我们一起期待吧！k8s 网络是块难啃的硬骨头，感兴趣的同学可以看下杜军的新书 《Kubernetes 网络权威指南》，整理巩固一下 k8s 的网络知识。</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ip协议簇</title>
    <link href="/2019/11/25/ip%E5%8D%8F%E8%AE%AE%E7%B0%87/"/>
    <url>/2019/11/25/ip%E5%8D%8F%E8%AE%AE%E7%B0%87/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天，也就是 2019-11-25日，全世界所有的ipv4已经分配完毕。这一天终于到来了！<br><img src="/img/newimg/006y8mN6gy1g9ckh60znsj30mq0rsju1.jpg" srcset="/img/loading.gif" alt="网络协调中心宣布ipv4的43亿个ip已经完全分配完毕"><br>以后的日子中，ipv6的占比会越来越大，网络也会越来越复杂。作为IT从业人员，网络知识的掌握是必不可少的。<br>网络是我们工程师的基础技能之一, 毕竟没有网络我们什么也干不了! 从各大公司的招聘要求上看,网络也是重点的考核部分. 今天就和大家一起复习下(还)大学里的课程(欠下的债)! TCP/IP协议簇的IP协议.</p><hr><h2 id="理解网络模型"><a href="#理解网络模型" class="headerlink" title="理解网络模型"></a>理解网络模型</h2><p>网络的设计大佬们想出了分层的设计,将各个功能分开,交付给不同的层,这样的好处是便于更新和维护(IPv6的到来并没有使整个网络重新设计),也便于我们的学习和理解.下面是各个版本的网络体系的结构图:<br><img src="/img/newimg/006y8mN6gy1g9cl89028zj30i309itb2.jpg" srcset="/img/loading.gif" alt="网络结构图"></p><p>让我们明确下各层的工作职责(以五层协议为例):</p><figure class="highlight erlang"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs erlang">应用层,该层协议主要负责各个应用程序之间交互的规则.如HTTP,DNS,其交互的数据单元可以称为”报文”.<br>运输层,为应用层提供通用的数据传输服务.为上层跑腿的.TCP,UDP均是运输层协议.<br>网络层,为网络中不同的主机提供通信服务.IP协议工作在该层.<br>数据链路层,负责相邻两点的数据传送.<br>物理层, 传输比特流, <span class="hljs-number">0</span> 或 <span class="hljs-number">1</span>.<br></code></pre></div></td></tr></table></figure><p>每一层将数据封装成自己能理解的数据格式,交付给下一层,下一层将收到的作为自己的数据再次添加本层的必要数据,向下交付,直到链路层,传递到目的地后,每层再将该层的必要数据去掉,交付给上层.如下图:<br><img src="/img/newimg/006y8mN6gy1g9cljgokpwj30hw08ugoh.jpg" srcset="/img/loading.gif" alt="数据包传递过程"></p><h2 id="理解IP协议"><a href="#理解IP协议" class="headerlink" title="理解IP协议"></a>理解IP协议</h2><p>在理解了网络模型和各层直接的配合之后,下面进入今天的正题,网际协议(IP).</p><p>该节主要理解IP协议给我们提供的功能有哪些,说白了就是它能干嘛.</p><figure class="highlight erlang"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs erlang">为网络中的主机(PC或路由或网关)提供身份证.<br>定义了网络主机的基本交流方式, 从IP数据报的格式可以看出.<br>为路由寻址提供方便, 从路由表结构可以看出.<br></code></pre></div></td></tr></table></figure><p>任何一个协议都可以由语法,语义和同步三部分组成.</p><figure class="highlight erlang"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs erlang">语法,交换信息的格式,对于IP协议,就是IP报文的格式.<br>语义,即需要发出何种控制信息,以及接收到信息后如何响应.<br>同步,对事件顺序的详细说明.<br></code></pre></div></td></tr></table></figure><p>也就是定义了使用IP协议进行交流的法则.</p><h3 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h3><p>IPv4是IP协议的第4个版本,就是我们现在使用的.下面从多个方面了解下该版本.</p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>网络上的主机都需要一个IP地址,这样才能知道彼此的位置.IPv4地址由32bit构成,常使用<code>点分十进制表示(192.168.1.1)</code>.</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>IP地址的分类就是把所有IP划分为若干类别, 每一类都由固定长度的字段组成.分别为网络号和主机号.下面是各类地址组成示意图:<br><img src="/img/newimg/006y8mN6gy1g9clmthbynj30cw07n75r.jpg" srcset="/img/loading.gif" alt="ip分类"></p><ul><li>A类地址,8位网络号,第一位固定为0,可用的网络号只有126个(2^7-2),网络号从0到127. 减去2是因为:IP地址全为0表示”本网络”,保留; 网络号为127作为软件回环测试使用, 若主机发出目的地为127.0.0.1的数据时,该数据不会向任何网络上的主机发送.也就是说127开头的地址不能使用. 对于A类地址中的每一个网络号,对应的主机号有(2^24-2)个: 主机号全0表示,其网络号对应的网络地址, 全1表示所有主机的意思.</li><li>B类地址网络号为16位,但前面2位以固定为1 0.无论怎么取值,无法出现全0或全1的情况.128.0.0.0的网络是不使用的,实际使用的最小B类网络地址为128.1.0.0.所以B类的网络地址有(2^14-1)个.</li><li>C类的地址有24位的网络号,最前面的3位固定为1 1 0.192.0.0.0的网络地址也是不使用的,最小的C类地址为192.0.1.0</li></ul><h3 id="总结如下"><a href="#总结如下" class="headerlink" title="总结如下:"></a>总结如下:</h3><p><img src="/img/newimg/006y8mN6gy1g9cltkpc7hj30hu06edg5.jpg" srcset="/img/loading.gif" alt="ip分类总结"><br>分类的好处:</p><figure class="highlight erlang"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs erlang">方便管理,IP地址管理机构只需管理网络号,剩下的可以由下级管理.<br>路由寻址时根据网络地址转发分组,减小路由表.<br></code></pre></div></td></tr></table></figure><h3 id="数据报格式"><a href="#数据报格式" class="headerlink" title="数据报格式"></a>数据报格式</h3><p>先看下IP数据报的基本格式:<br><img src="/img/newimg/006y8mN6gy1g9clulcooyj30id09jq58.jpg" srcset="/img/loading.gif" alt="数据包格式"><br>可以看到IP数据报包含了首部和数据部分. 其中首部包含固定的20字节和可变的部分. 下面是各部分的解释:</p><ul><li>版本,占4位,IP协议的版本号,通信双方需要相同.</li><li>首部长度,占4位, 单位4字节.最大能表示(2^4-1) * 4 = 60字节.当IP分组的首部长度不是4的整数倍时,需要使用填充字段填充.</li><li>区分服务,占8位, 表示服务类型,未使用.</li><li>总长度, 占16位,表示首部和数据部分的总长度(单位字节).因此数据报的最大总长度为(2^16-1 = 65535)字节.</li><li>标识(identification), 占16位.当数据报长度超过下层的MTU时,需要分片, 被分片的数据报的标识一样,这样可以进行重组.</li><li>标志(Flag), 占3位, 目前只有2位有意义</li><li>最低位,MF(More Fragment) = 1 表示后面还有分片. MF = 0 表示分片中的最后一个.</li><li>中间一位,DF(Don’t Fragment),不要分片,只有当DF=0才允许分片</li><li>片偏移, 占13位.较长的分组在分片后, 某片在原分组的相对位置.必须是8字节的整数倍.</li><li>生存时间, 占8位, Time To Live(TTL),开始指生存的秒数,后来变为经过路由的跳数,每经过一个路由,TTL减小1,当为0时,丢弃该数据.显然,最大跳数为255, 为1时就只能在局域网中传播了.</li><li>协议, 占8位.支出该数据报的数据是使用何种协议, 以便目的主机IP层知道将数据交付给哪个协议处理.</li></ul><p>常用的协议及对应数值:</p><table><thead><tr><th>议名称</th><th>ICMP</th><th>IGMP</th><th>IP</th><th>TCP</th><th>EGP</th><th>IGP</th><th>UDP</th><th>IPV6</th><th>ESP</th><th>OSPF</th></tr></thead><tbody><tr><td>议字段值</td><td>1</td><td>2</td><td>4</td><td>6</td><td>8</td><td>9</td><td>17</td><td>41</td><td>50</td><td>89</td></tr></tbody></table><ul><li>首部校验和, 占16位.数据报的首部校验和,不包括数据部分.</li><li>源地址, 目的地址, 各占32位</li></ul><h3 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h3><p>IPv6的出现是解决IPv4资源枯竭的问题.其仍然支持无连接的传送, 但传送的是PDU分组,而不是IPv4的数据报.</p><h3 id="IP地址-1"><a href="#IP地址-1" class="headerlink" title="IP地址"></a>IP地址</h3><p>IPv6的地址是128bit,在可预见的未来是够用的.但和IPv4版本并不兼容, 若使用IPv4版本的主机A和使用IPv6版本的主机B之间通信是需要特殊处理的,在后面会介绍方法.</p><h3 id="IPv6的地址表示"><a href="#IPv6的地址表示" class="headerlink" title="IPv6的地址表示"></a>IPv6的地址表示</h3><p>IPv6的地址采用<code>冒号十六进制记法</code> , 8组4个16进制数字,中间使用冒号隔开.例如:</p><p><code>6845:8C64:FFFF:FFFF:0:1180:9000:FFFF</code></p><p>若一组中全是0,可以省略三个.<br>若存在连续多组0,可以使用冒号取代,但只能压缩一次 <code>FF05:0:0:0:0:0:0:B3 可以压缩为 FF05::B3 1090:0:0:0:8:800:200C:417A  可以压缩为 1090::8:800:200C:417A</code> <code>全零可记为 ::</code></p><p>最后的2组可以使用IPv4的点分十进制表示 <code>0:0:0:0:0:0:128.10.2.1 可表示为 ::128.10.2.1</code></p><h2 id="数据报格式-1"><a href="#数据报格式-1" class="headerlink" title="数据报格式"></a>数据报格式</h2><p>IPv6数据报由两大部分组成, <code>基本首部</code>和<code>有效载荷</code>.有效载荷运行有0个或多个扩展首部.<br><img src="/img/newimg/006y8mN6gy1g9cvt2bxkaj30h30amgoa.jpg" srcset="/img/loading.gif" alt="数据包格式"></p><p>可以看到,IPv6的首部是固定的40字节,和IPv4不同;在组成上也有很大区别,下面看下各部分的意思.</p><ul><li>版本, 占4位, 协议的版本,通信双方需要相同</li><li>通信量类, 占8位.区分不同的IPv6的数据报或优先级.</li><li>流标号, 占20位. IPv6一个新机制就是支持资源预分配, 运行路由把每个数据报与特定的资源分配和联系.IPv6提出流的概念.指互联网上从 特定源点到特定终点的一系列数据报(如实时的音频或视频传输), 在这个流经过的路径上路由都保证指明的服务质量.所有属于同一个流的数据报具有相同的流标号.赋值为0即为关闭.</li><li>有效载荷长度, 占16位.指明除基本首部以外的字节数.最大64KB.</li><li>下一首部, 占8位.相当于IPv4的协议字段或可选字段.</li><li>当IPv6没有扩展首部时, 该字段和IPv4的协议字段一样.</li><li>有扩展首部时,表示第一个扩展首部的类型.</li><li>跳数限制, 和IPv4的TTL一样</li><li>源地址,目的地址, 各占128位</li></ul><h2 id="从IPv4向IPv6过渡"><a href="#从IPv4向IPv6过渡" class="headerlink" title="从IPv4向IPv6过渡"></a>从IPv4向IPv6过渡</h2><p>网络如此庞大,从IPv4向IPv6的变换不可能一蹴而就.若要在两个版本的协议下通信,有下面的2个方法</p><h3 id="双协议栈"><a href="#双协议栈" class="headerlink" title="双协议栈"></a>双协议栈</h3><p>简单的说就是一个主机能够理解两个版本的内容,这样主机也要有2个版本对应的IP地址.具有双协议栈的主机, 可以通过DNS系统知道目的主机使用的协议版本.</p><p>下面是两台使用IPv6的主机通信示意图,它们之间需要通过IPv4网络, 在必要的时候经过双协议栈的主机进行协议的转换,当然转换的时候有些信息可能丢失,这也是不可避免的.<br><img src="/img/newimg/006y8mN6gy1g9cvtpahpgj30hf08d414.jpg" srcset="/img/loading.gif" alt="双栈"></p><h3 id="使用隧道技术"><a href="#使用隧道技术" class="headerlink" title="使用隧道技术"></a>使用隧道技术</h3><p>隧道技术的原理是,在IPv6的数据需要进入IPv4网络时,将IPv6的数据报(准确的说是PDU)当成IPv4数据报的数据部分,使用IPv4版本传输,在离开IPv4网络时在此组装成IPv6的数据,发往目的地.下面是一个示意图:</p><p><img src="/img/newimg/006y8mN6gy1g9cvtw1j80j30gy08fq5z.jpg" srcset="/img/loading.gif" alt="隧道"></p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CKA题库</title>
    <link href="/2019/11/17/CKA%E9%A2%98%E5%BA%93/"/>
    <url>/2019/11/17/CKA%E9%A2%98%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="题库一"><a href="#题库一" class="headerlink" title="题库一"></a>题库一</h1><p>24 题，160 分钟。</p><h2 id="第一题-5-日志"><a href="#第一题-5-日志" class="headerlink" title="第一题 (5%) 日志"></a>第一题 (5%) 日志</h2><p>监控 Pod bar 的日志，并提取与错误 file-not-found 相对应的日志行,将这些日志行写入 /opt/dir/bar</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">kubectl logs <span class="hljs-symbol">&lt;podname&gt;</span> | <span class="hljs-keyword">grep</span> Error &gt; /<span class="hljs-keyword">opt</span>/KUCC000xxx/KUCC000xxx.txt<br></code></pre></div></td></tr></table></figure><p>考点：Monitor, Log, and Debug</p><h2 id="第二题-3-PV-按大小排序"><a href="#第二题-3-PV-按大小排序" class="headerlink" title="第二题 (3%) PV 按大小排序"></a>第二题 (3%) PV 按大小排序</h2><p>(使用 kubectl 的自带功能对输出排序，不要做其他任何处理)<br>按 capacity 排序列出所有 persistent volumes, 将完整的 kubectl 输出保存到 /opt/dir/volume_list</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">get</span> pv <span class="hljs-attribute">--sort-by</span>=<span class="hljs-string">'&#123;spec.capacity.storage&#125;'</span><br></code></pre></div></td></tr></table></figure><p><strong>列出环境内所有的 pv 并以 name 字段排序（使用 kubectl 自带排序功能）</strong></p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">get</span> pv <span class="hljs-attribute">--sort-by</span>=.metadata.name<br></code></pre></div></td></tr></table></figure><p>考点：kubectl 命令熟悉程度</p><h2 id="第三题-3-创建-Pod"><a href="#第三题-3-创建-Pod" class="headerlink" title="第三题 (3%) 创建 Pod"></a>第三题 (3%) 创建 Pod</h2><p>按如下要求创建一个 Pod：</p><p>名称：jenkins<br>使用 image: jenkins<br>在名为 website-frontend 的 新 kubernetes namespace 中</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros"><span class="hljs-comment"># 方法一: 通过命令创建</span><br>kubectl <span class="hljs-builtin-name">run</span> jenkins <span class="hljs-attribute">--image</span>=jenkins <span class="hljs-attribute">--namespace</span>=website-frontend <span class="hljs-attribute">--replicas</span>=1 <span class="hljs-attribute">--generator</span>=run-pod/v1 <span class="hljs-attribute">--labels</span>=app=jenkins --dry-<span class="hljs-builtin-name">run</span> -o yaml<br><br><span class="hljs-comment"># 方法二: 编写yaml</span><br>apiVersion: v1<br>kind: Pod<br>nameSpace: website-frontend<br>metadata:<br>  name: jenkins<br>spec:<br>  containers:<br>  - name: jenkins<br>    image: jenkins<br></code></pre></div></td></tr></table></figure><h2 id="第四题-4-EmptyDir"><a href="#第四题-4-EmptyDir" class="headerlink" title="第四题 (4%) EmptyDir"></a>第四题 (4%) EmptyDir</h2><p>按如下要求创建一个 Pod：</p><p>名称：non-persistent-redis<br>Container image: redis<br>Persistent volume name: cache-control<br>Mount Path: /data/redis<br>应在 staging namespace 中发布，且该 volume 必须不能是永久的。</p><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-attribute">apiVersion</span>: v1<br><span class="hljs-attribute">kind</span>: Pod<br><span class="hljs-attribute">metadata</span>:<br>  <span class="hljs-attribute">name</span>: non-persistent-redis<br>  <span class="hljs-attribute">namespace</span>: staging<br><span class="hljs-attribute">spec</span>:<br>  <span class="hljs-attribute">containers</span>:<br>  - <span class="hljs-attribute">name</span>: non-persistent-redis<br>    <span class="hljs-attribute">image</span>: redis<br>    <span class="hljs-attribute">volumeMounts</span>:<br>      - <span class="hljs-attribute">name</span>: cache-control<br>        <span class="hljs-attribute">mountPath</span>: /data/redis<br>  <span class="hljs-attribute">volumes</span>:<br>  - <span class="hljs-attribute">name</span>: cache-control<br>    <span class="hljs-attribute">emptyDir</span>: &#123;&#125;<br></code></pre></div></td></tr></table></figure><p>考点：Volume、emptdir</p><p>参考：<a href="https://kubernetes.io/docs/concepts/storage/volumes/#emptydir" target="_blank" rel="noopener">Volumes</a></p><h2 id="第五题-3-DaemonSet"><a href="#第五题-3-DaemonSet" class="headerlink" title="第五题 (3%) DaemonSet"></a>第五题 (3%) DaemonSet</h2><p>确保在 Kubernetes cluster 的每个 node 上都运行 pod nginx 的一个实例，此处，nginx 也表示必须使用的 image 名称。切勿覆盖当前存在的任何 taint。</p><p>使用 DaemonSet 完成此任务，并使用 ds-kubesc12345 作为 DaemonSet 名称。</p><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-attribute">apiVersion</span>: apps/v1<br><span class="hljs-attribute">kind</span>: DaemonSet<br><span class="hljs-attribute">metadata</span>:<br>  <span class="hljs-attribute">name</span>: ds-kubesc12345<br>  <span class="hljs-attribute">annotations</span>:<br>    <span class="hljs-attribute">wocao</span>: wuqing<br>  <span class="hljs-attribute">labels</span>:<br>    <span class="hljs-attribute">app</span>: ds-kubesc12345<br><span class="hljs-attribute">spec</span>:<br>  <span class="hljs-attribute">selector</span>:<br>    <span class="hljs-attribute">matchLabels</span>:<br>      <span class="hljs-attribute">name</span>: ds-kubesc12345<br>  <span class="hljs-attribute">template</span>:<br>    <span class="hljs-attribute">metadata</span>:<br>      <span class="hljs-attribute">labels</span>:<br>        <span class="hljs-attribute">name</span>: ds-kubesc12345<br>    <span class="hljs-attribute">spec</span>:<br>      <span class="hljs-attribute">containers</span>:<br>      - <span class="hljs-attribute">name</span>: ds-kubesc12345<br>        <span class="hljs-attribute">image</span>: busybox<br>        <span class="hljs-attribute">command</span>:<br>        - sh<br>      <span class="hljs-attribute">tolerations</span>:<br>      - <span class="hljs-attribute">key</span>: node-role.kubernetes.io/master<br>        <span class="hljs-attribute">effect</span>: NoSchedule<br></code></pre></div></td></tr></table></figure><p><strong>另外:建议直接先创建一个 deployment 然后修改 yaml 使其成为 daemonset 编排(注意删除 replicas 和其他不必要字段字段)</strong></p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino">kubectl <span class="hljs-built_in">run</span> ds-kubesc12345 --<span class="hljs-built_in">image</span> nginx --<span class="hljs-built_in">image</span>-pull-policy IfNotPresent --dry-<span class="hljs-built_in">run</span> -o yaml<br></code></pre></div></td></tr></table></figure><p>考点：DaemonSet</p><p>参考：<a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" target="_blank" rel="noopener">DaemonSet</a></p><h2 id="第六题-4-Rollout"><a href="#第六题-4-Rollout" class="headerlink" title="第六题 (4%) Rollout"></a>第六题 (4%) Rollout</h2><p>按如下要求创建一个 Deployment:</p><p>Name: nginx-app</p><p>Image: nginx</p><p>ImageTag: 1.10.2-alpine</p><p>Replicas: 3</p><p>然后，执行滚动更新，使用新版本 1.11.13-alpine 部署应用并记录此更新。</p><p>最后，将此更新回滚至之前版本 1.10.2-alpine</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">run</span> nginx-app <span class="hljs-attribute">--image</span>=nginx:1.10.2-alpine<br>kubectl <span class="hljs-builtin-name">set</span> image deployment nginx-app <span class="hljs-attribute">nginx-app</span>=nginx:1.11.13-alpine --record<br><span class="hljs-comment"># 直接回滚到上一个版本</span><br>kubectl rollout undo deployment nginx-app<br>kubectl rollout status -w deployment nginx-app<br><br><span class="hljs-comment"># 通过查看历史记录回滚到指定版本</span><br>kubectl rollout history deploy/nginx<br>kubectl rollout undo deploy/nginx  <span class="hljs-attribute">--to-revision</span>=2<br></code></pre></div></td></tr></table></figure><p>考点：资源的更新</p><p>参考：<a href="https://kubernetes.io/docs/reference/kubectl/cheatsheet/#updating-resources" target="_blank" rel="noopener">Kubectl Cheat Sheet:Updating Resources</a></p><h2 id="第七题-3-Deployment"><a href="#第七题-3-Deployment" class="headerlink" title="第七题 (3%) Deployment"></a>第七题 (3%) Deployment</h2><p>创建一个 Deployment 的 spec 文件：</p><p>Image: nginx<br>Replicas: 4<br>Label: app_env_stage=prod<br>Name: kual12345<br>将此 spec 文件的副本保存至 /opt/dir/deployment_spec.yaml (或 .json)。</p><p>完成后，清理(删除)执行此任务时生成的任何新 Kubernetes API 对象。</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">kubectl</span> <span class="hljs-string">run</span> <span class="hljs-string">kual12345</span> <span class="hljs-string">--image</span> <span class="hljs-string">nginx</span> <span class="hljs-string">--replicas</span> <span class="hljs-number">4</span> <span class="hljs-string">--labels</span> <span class="hljs-string">app_env_stage=prod</span> <span class="hljs-string">--dry-run</span> <span class="hljs-string">-o</span> <span class="hljs-string">yaml</span><br><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">creationTimestamp:</span> <span class="hljs-literal">null</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app_env_stage:</span> <span class="hljs-string">prod</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kual12345</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">4</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app_env_stage:</span> <span class="hljs-string">prod</span><br>  <span class="hljs-attr">strategy:</span> <span class="hljs-string">&#123;&#125;</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">creationTimestamp:</span> <span class="hljs-literal">null</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app_env_stage:</span> <span class="hljs-string">prod</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">kual12345</span><br>        <span class="hljs-attr">resources:</span> <span class="hljs-string">&#123;&#125;</span><br><span class="hljs-attr">status:</span> <span class="hljs-string">&#123;&#125;</span><br></code></pre></div></td></tr></table></figure><h2 id="第八题-7-init-container"><a href="#第八题-7-init-container" class="headerlink" title="第八题 (7%) init container"></a>第八题 (7%) init container</h2><p>执行以下任务：</p><p>添加一个 init container 至 bumpy-llama (已在 spec 文件 /opt/dir/Pod-spec-12345.yaml 中定义)<br>init container 应该：创建一个名为 /workdir/faithful.txt 的 空文件<br>如果未检测到 /workdir/failthful.txt , Pod 应退出<br>一旦使用 init container 定义更新 spec 文件，则应创建 Pod</p><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-attribute">apiVersion</span>: v1<br><span class="hljs-attribute">kind</span>: Pod<br><span class="hljs-attribute">metadata</span>:<br>  <span class="hljs-attribute">name</span>: hungry-bear<br><span class="hljs-attribute">spec</span>:<br>  <span class="hljs-attribute">volumes</span>:<br>  - <span class="hljs-attribute">name</span>: workdir<br>    <span class="hljs-attribute">emptyDir</span>: &#123;&#125;<br>  <span class="hljs-attribute">containers</span>:<br>  - <span class="hljs-attribute">name</span>: checker<br>    <span class="hljs-attribute">image</span>: busybox<br>    <span class="hljs-attribute">command</span>: [<span class="hljs-string">"/bin/sh"</span>, <span class="hljs-string">"-c"</span>, <span class="hljs-string">"if [ -f /workdir/faithful.txt ] ; then sleep 100000; else exit 1; fi"</span>]<br>    <span class="hljs-attribute">volumeMounts</span>:<br>    - <span class="hljs-attribute">name</span>: workdir<br>      <span class="hljs-attribute">mountPath</span>: /workdir<br>  <span class="hljs-attribute">initContainers</span>:<br>  - <span class="hljs-attribute">name</span>: init-c<br>    <span class="hljs-attribute">image</span>: busybox<br>    <span class="hljs-attribute">command</span>: [<span class="hljs-string">"/bin/sh"</span>, <span class="hljs-string">"-c"</span>, <span class="hljs-string">"touch /workdir/faithful.txt"</span>]<br>    <span class="hljs-attribute">volumeMounts</span>:<br>    - <span class="hljs-attribute">name</span>: workdir<br>      <span class="hljs-attribute">mountPath</span>: /workdir<br></code></pre></div></td></tr></table></figure><p>考点：init Container。一开始审题不仔细，以为要用到 livenessProbes</p><p>参考：<a href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/" target="_blank" rel="noopener">init-containers</a></p><h2 id="第九题-9-Secret"><a href="#第九题-9-Secret" class="headerlink" title="第九题 (9%) Secret"></a>第九题 (9%) Secret</h2><p>Create a kubetnetes Secret as follows:</p><p>Name: super-secret</p><p>Credential: alice or username:bob</p><p>Create a Pod named pod-secrets-via-file using the redis image which mounts a secret named super-secret at /secrets</p><p>Create a second Pod named pod-secrets-via-env using the redis image,which exports credential/username as TOPSECRET/CREDENTIALS</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">生成secret参考命令</span><br><span class="hljs-string">kubectl</span> <span class="hljs-string">create</span> <span class="hljs-string">secret</span> <span class="hljs-string">generic</span> <span class="hljs-string">super-secret</span> <span class="hljs-string">--from-literal=username=bob</span>  <span class="hljs-string">--from-literal=credential=alice</span><br><span class="hljs-string">生成yaml文件的命令，再在此基础上改写(可以在https://kubernetes.io/docs/页面搜索框输入volumes查询example)</span><br><span class="hljs-string">kubectl</span> <span class="hljs-string">run</span> <span class="hljs-string">pod-secrets-via-file</span> <span class="hljs-string">--image=redis</span> <span class="hljs-string">--generator=run-pod/v1</span> <span class="hljs-string">--dry-run</span> <span class="hljs-string">-o</span> <span class="hljs-string">yaml</span> <span class="hljs-string">&gt;12-1.yml</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">creationTimestamp:</span> <span class="hljs-literal">null</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">run:</span> <span class="hljs-string">pod-secrets-via-file</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-secrets-via-file</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">super-secret</span><br>    <span class="hljs-attr">secret:</span><br>      <span class="hljs-attr">secretName:</span> <span class="hljs-string">super-secret</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">redis</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">pod-secrets-via-file</span><br>    <span class="hljs-attr">resources:</span> <span class="hljs-string">&#123;&#125;</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">super-secret</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/secrets</span><br>  <span class="hljs-attr">dnsPolicy:</span> <span class="hljs-string">ClusterFirst</span><br>  <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Always</span><br><span class="hljs-attr">status:</span> <span class="hljs-string">&#123;&#125;</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">creationTimestamp:</span> <span class="hljs-literal">null</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">run:</span> <span class="hljs-string">pod-secrets-via-env</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-secrets-via-env</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">super-secret</span><br>    <span class="hljs-attr">secret:</span><br>      <span class="hljs-attr">secretName:</span> <span class="hljs-string">super-secret</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">redis</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">pod-secrets-via-env</span><br>    <span class="hljs-attr">resources:</span> <span class="hljs-string">&#123;&#125;</span><br>    <span class="hljs-attr">env:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">CREDENTIALS</span><br>      <span class="hljs-attr">valueFrom:</span><br>        <span class="hljs-attr">secretKeyRef:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">super-secret</span><br>          <span class="hljs-attr">key:</span> <span class="hljs-string">username</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">TOPSECRET</span><br>      <span class="hljs-attr">valueFrom:</span><br>        <span class="hljs-attr">secretKeyRef:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">super-secret</span><br>          <span class="hljs-attr">key:</span> <span class="hljs-string">credential</span><br>  <span class="hljs-attr">dnsPolicy:</span> <span class="hljs-string">ClusterFirst</span><br>  <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Always</span><br><span class="hljs-attr">status:</span> <span class="hljs-string">&#123;&#125;</span><br></code></pre></div></td></tr></table></figure><p>参考：<a href="https://kubernetes.io/docs/concepts/configuration/secret/" target="_blank" rel="noopener">Secret</a></p><h2 id="第十题-4-Service"><a href="#第十题-4-Service" class="headerlink" title="第十题 (4%) Service"></a>第十题 (4%) Service</h2><p>创建和配置 front-end-service service, 以便可通过 NodePort 访问该 service 并将其路由到名为 front-end 的现有 Pod</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl expose pod front-end <span class="hljs-attribute">--name</span>=front-end-service <span class="hljs-attribute">--type</span>=<span class="hljs-string">'NodePort'</span> <span class="hljs-attribute">--port</span>=80<br></code></pre></div></td></tr></table></figure><p>考点：Service</p><p>参考：<a href="https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types" target="_blank" rel="noopener">publishing-services-service-types</a></p><h2 id="第十一题-4-多容器-Pod"><a href="#第十一题-4-多容器-Pod" class="headerlink" title="第十一题 (4%) 多容器 Pod"></a>第十一题 (4%) 多容器 Pod</h2><p>创建一个名为 kucc3 的 Pod，在 Pod 里面分别为以下每个 image 单独运行一个 app container（可能会有 1 ～ 4 个 images）:</p><p>nginx + redis + memcached + consul</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># 先用命令行创建一个示例</span><br><span class="hljs-string">kubectl</span> <span class="hljs-string">run</span> <span class="hljs-string">kucc3</span> <span class="hljs-string">--image=nginx</span> <span class="hljs-string">--image-pull-policy=IfNotPresent</span> <span class="hljs-string">--replicas=1</span> <span class="hljs-string">--generator=run-pod/v1</span> <span class="hljs-string">--dry-run</span> <span class="hljs-string">-o</span> <span class="hljs-string">yaml</span><br><span class="hljs-comment"># 而后修改示例</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">run:</span> <span class="hljs-string">kucc4</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kucc4</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">redis</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">redis</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">memcached</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">memcached</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">consul</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">consul</span><br><span class="hljs-attr">status:</span> <span class="hljs-string">&#123;&#125;</span><br></code></pre></div></td></tr></table></figure><p>考点：kubectl 命令熟悉程度、多个容器的 pod 的创建</p><p>参考：<a href="https://kubernetes.io/docs/reference/kubectl/cheatsheet/" target="_blank" rel="noopener">kubectl cheatsheet</a></p><h2 id="第十二题-3-Label"><a href="#第十二题-3-Label" class="headerlink" title="第十二题 (3%) Label"></a>第十二题 (3%) Label</h2><p>Create a file /opt/KUCC00302/kucc00302.txt that lists all pods that implement Service foo in Namespce production</p><p>The format of the file should be one pod name per line</p><figure class="highlight dart"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dart">[root<span class="hljs-meta">@vms</span>31 KUCC00302]# kubectl <span class="hljs-keyword">get</span> svc --<span class="hljs-keyword">show</span>-labels -n production<br>[root<span class="hljs-meta">@vms</span>31 KUCC00302]# kubectl <span class="hljs-keyword">get</span> pods -l name=haha -n production |grep -v NAME|awk <span class="hljs-string">'&#123;print <span class="hljs-subst">$1</span>&#125;'</span> &gt; /opt/KUCC00302/kucc00302.txt<br>[root<span class="hljs-meta">@vms</span>31 KUCC00302]# cat /opt/KUCC00302/kucc00302.txt<br>foo-fd6cbbd89-jdsdx<br>foo-fd6cbbd89-wrd6v<br></code></pre></div></td></tr></table></figure><h2 id="第十三题-2-Node-Selector"><a href="#第十三题-2-Node-Selector" class="headerlink" title="第十三题 (2%) Node Selector"></a>第十三题 (2%) Node Selector</h2><p>按如下要求调度一个 Pod：</p><p>名称：nginx-kucc2345<br>Image： nginx<br>Node Selector: disk=spinning</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">creationTimestamp:</span> <span class="hljs-literal">null</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">run:</span> <span class="hljs-string">nginx-kucc2345</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-kucc2345</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">nginx-kucc2345</span><br>  <span class="hljs-attr">strategy:</span> <span class="hljs-string">&#123;&#125;</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">creationTimestamp:</span> <span class="hljs-literal">null</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">nginx-kucc2345</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-kucc2345</span><br>        <span class="hljs-attr">resources:</span> <span class="hljs-string">&#123;&#125;</span><br>      <span class="hljs-attr">nodeSelector:</span><br>        <span class="hljs-attr">disk:</span> <span class="hljs-string">spinning</span><br><span class="hljs-attr">status:</span> <span class="hljs-string">&#123;&#125;</span><br></code></pre></div></td></tr></table></figure><p>考点：pod 的调度。</p><p>参考：<a href="https://kubernetes.io/docs/concepts/configuration/assign-pod-node/" target="_blank" rel="noopener">assign-pod-node</a></p><h2 id="第十四题-3-PV-hostPath"><a href="#第十四题-3-PV-hostPath" class="headerlink" title="第十四题 (3%) PV hostPath"></a>第十四题 (3%) PV hostPath</h2><p>创建名为 app-config 的 Persistent Volume，容量为 1Gi, 访问模式为 ReadWriteOnce。Volume 类型为 hostPath，位于 /srv/app-config。</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-symbol">apiVersion:</span> v1<br><span class="hljs-symbol">kind:</span> PersistentVolume<br><span class="hljs-symbol">metadata:</span><br><span class="hljs-symbol">  name:</span> app-config<br><span class="hljs-symbol">spec:</span><br><span class="hljs-symbol">  capacity:</span><br><span class="hljs-symbol">    storage:</span> <span class="hljs-number">1</span>Gi<br><span class="hljs-symbol">  accessModes:</span><br>    - ReadWriteOnce<br><span class="hljs-symbol">  hostPath:</span><br><span class="hljs-symbol">    path:</span> <span class="hljs-meta-keyword">/srv/</span>app-config<br></code></pre></div></td></tr></table></figure><p>考点：创建 PV<br>参考：<a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" target="_blank" rel="noopener">persistent volumes</a></p><h2 id="第十五题-4-集群故障排查"><a href="#第十五题-4-集群故障排查" class="headerlink" title="第十五题 (4%) 集群故障排查"></a>第十五题 (4%) 集群故障排查</h2><p>提供一个非完全正常运行的 Kubernetes Cluster, 在该 Cluster 中找出故障征兆。</p><p>确定 node 和出现故障的服务，采取措施修复故障服务，使 Cluster 恢复正常。确保所有更改永久有效。</p><p>提示：</p><p>可使用 ssh node-name 通过 ssh 命令连接到相应 node<br>可使用 sudo -i 命令在该 cluster 的任何 node 上获取更高权限</p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">情况一<br>kubectl get cs 能看到controller manager 没有启动<br>登陆到<span class="hljs-literal">master</span>上<br>找到相关服务重启<br>systemctl <span class="hljs-literal">start</span> kube-manager-controller.service<br></code></pre></div></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">情况二<br>kubectl <span class="hljs-keyword">get</span> node显示<span class="hljs-keyword">connection</span> refuse，估计是apiserver的故障。<br>具体配置文件参考 static pod 那一题,主要解题思路如下:<br><span class="hljs-number">1.</span>为什么api-<span class="hljs-keyword">server</span>没启动 (跟其他题的集群对比发现api-<span class="hljs-keyword">server</span>配置文件相同。但是不生效)<br><span class="hljs-number">2.</span>为什么kubelet没有拉起来api-<span class="hljs-keyword">server</span>  (跟其他题的集群对比 比如static pod 那一题，可以发现kubelet没有指定静态pod目录)<br><span class="hljs-number">3.</span>kubelet配置文件中加入 (<span class="hljs-comment">--pod-manifest-path=xxxxxxx)，重启kubelet systelctl  restart  kubelet</span><br></code></pre></div></td></tr></table></figure><p>参考：<a href="https://kubernetes.io/docs/tasks/debug-application-cluster/debug-cluster/" target="_blank" rel="noopener">Troubleshoot Clusters</a></p><h2 id="第十六题-4-节点故障排查"><a href="#第十六题-4-节点故障排查" class="headerlink" title="第十六题 (4%) 节点故障排查"></a>第十六题 (4%) 节点故障排查</h2><p>名为 wk8s-node-0 的 Kubernetes worker node 处于 NotReady 状态。</p><p>调查发生这种情况的原因，并采取相应措施将 Node 恢复为 Ready 状态，确保所做的任何更改永久有效。</p><p>提示：</p><p>可使用命令 ssh wk8s-node-0 连接到故障节点<br>可使用命令 sudo -i 在该节点上获取更高权限</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-comment">#查看集群状态</span><br>kubectl get nodes<br><span class="hljs-comment">#查看故障节点信息</span><br>kubectl describe node node1<br><br><span class="hljs-comment">#Message显示kubelet无法访问（记不清了）</span><br><span class="hljs-comment">#进入故障节点</span><br>ssh node1<br><br><span class="hljs-comment">#查看节点中的kubelet进程</span><br>ps -aux | grep kubelete<br><span class="hljs-comment">#没找到kubelet进程，查看kubelet服务状态</span><br>systemctl status kubelet.service<br><span class="hljs-comment">#kubelet服务没启动，启动服务并观察</span><br>systemctl start kubelet.service<br><span class="hljs-comment">#启动正常，enable服务</span><br>systemctl enable kubelet.service<br><br><span class="hljs-comment">#回到考试节点并查看状态</span><br><span class="hljs-keyword">exit</span><br><br>kubectl get nodes <span class="hljs-comment">#正常</span><br></code></pre></div></td></tr></table></figure><p>参考：<a href="https://kubernetes.io/docs/tasks/debug-application-cluster/debug-cluster/" target="_blank" rel="noopener">Troubleshoot Clusters</a></p><h2 id="第十七题-8-增加节点"><a href="#第十七题-8-增加节点" class="headerlink" title="第十七题 (8%) 增加节点"></a>第十七题 (8%) 增加节点</h2><p>在本任务中，将配置一个新 Node ik8s-node-0 并将其加入一个 Kubernetes Cluster, 方法如下：</p><p>配置 kubelet 以便自动轮换证书，且通过使用 RBAC 确保服务器和客户端的 CSRs 能够得到自动批准和签署<br>确保创建合适的 cluster-infok ConfigMap, 并在正确的 Namespace 中进行相应的配置，以便后续的 Nodes 能够轻松加入该集群<br>用于引导的 kubeconfig 应创建在新 Node 的 /etc/kubernetes/bootstrap-kubelet.conf 上(切勿在 Node 成功加入集群后移除此文件)<br>相应的集群级 CA 证书位于 Node 的 /etc/kubernetes/pki/ca.crt 上，应确保所有自动签发的证书都安装到 Node 的 /var/lib/kubelet/pki 目录上，并且成功引导后，将在 /etc/kubernetes/kubelet.conf 渲染 kubelet 的 kubeconfig 文件<br>使用额外的组引导尝试加入集群的 Nodes，组的名称应为 system:bootstrappers:cka:default-node-token<br>解决方案应在系统启动时随着 kubelet 的 systemd service unit 文件(可在 /etc/systemd/system/kubelet.service 中找到) 一起自动启动</p><p>要测试解决方案，应通过位于 /opt/dir/kube-flannel.yaml 的 spec 文件创建相应的资源。该过程将创建必要的资源和 kube-flannel-ds DaemonSet。应确保将此 DaemonSet 正确部署到集群的单个(应该是每个)Node。</p><p>提示：</p><p>对于此任务，未在 ik8s-master-0 上配置或运行 kubelet, 请勿尝试配置<br>您将使用 TLS 引导来完成此任务<br>可通过以下命令获取 Kubernetes API 服务器的 IP 地址： ssh ik8s-node-0 getent hosts ik8s-master-0<br>API 服务器正在侦听常用端口 6443/tcp，且只会处理 TLS 请求<br>kubelet 二进制文件已安装到 ik8s-node-0 的 /usr/bin/kubelet 上。执行此任务期间，无需将 kube-proxy 部署到集群<br>可以使用 ssh ik8s-node-0 来连接到 Worker Node<br>可以使用 ssh ik8s-master-0 来连接到 Master Node<br>无需进一步配置在 ik8s-master-0 上运行的 Control Plane 服务<br>可使用 sudo -i 在这两个 Nodes 上获取更高权限<br>已在 ik8s-node-0 上安装并运行 Docker</p><p><strong>另外:可能题目有另外一种说法,就是需要你去配置 worker 节点上 kube-proxy、kubelet 的 tls</strong></p><p>参考：<a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/" target="_blank" rel="noopener">TLS Bootstrapping</a></p><h2 id="第十八题-4-Drain"><a href="#第十八题-4-Drain" class="headerlink" title="第十八题 (4%) Drain"></a>第十八题 (4%) Drain</h2><p>将标签为 ek8s-node-1 的 Node 设置为不可用，并重新调度该 Node 上所有运行的 Pods。</p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">kubetl get <span class="hljs-keyword">node</span> <span class="hljs-title">--show-labels</span> |grep <span class="hljs-attr">name=</span>ek8s-<span class="hljs-keyword">node</span><span class="hljs-title">-1</span><br>kubectl drain ek8s-<span class="hljs-keyword">node</span><span class="hljs-title">-1</span><br><span class="hljs-comment">#如果直接drain会出错，需要添加--ignore-daemonsets --delete-local-data参数</span><br>kubectl drain <span class="hljs-keyword">node</span> <span class="hljs-title">node1</span>  --ignore-daemonsets --delete-local-data<br></code></pre></div></td></tr></table></figure><p><strong>另外:使用 cordon 可以先暂停调度</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">kubectl cordon</span><br></code></pre></div></td></tr></table></figure><p>考点：节点调度、维护</p><p>参考：<a href="https://kubernetes.io/docs/tasks/administer-cluster/safely-drain-node/" target="_blank" rel="noopener"> Safely Drain a Node while Respecting Application SLOs </a></p><h2 id="第十九题-7-Etcd"><a href="#第十九题-7-Etcd" class="headerlink" title="第十九题 (7%) Etcd"></a>第十九题 (7%) Etcd</h2><p>为在 <a href="https://127.0.0.1:2379" target="_blank" rel="noopener">https://127.0.0.1:2379</a> 运行的 etcd 实例创建快照，并将快照保存至文件路径 /data/backup/etcd-snapshot.db。</p><p>Etcd 实例运行的 etcd 版本为 3.3.10</p><p>以下 TLS 证书密钥用于通过 etcdctl 连接服务器：</p><p>CA 证书：/opt/dir/ca.crt<br>客户端证书：/opt/dir/etcd-client.crt<br>客户端密钥：/opt/dir/etcd-client.key</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">ETCDCTL_API</span>=3<br>etcdctl help  再etcdctl snapshot save --help<br>etcdctl <span class="hljs-attribute">--endpoints</span>=127.0.0.1:2379 <span class="hljs-attribute">--cacert</span>=/opt/dir/ca.crt <span class="hljs-attribute">--cert</span>=//opt/dir/etcd-client.crt <span class="hljs-attribute">--key</span>=/opt/dir/etcd-client.key snapshot save /data/backup/etcd-snapshot.db<br></code></pre></div></td></tr></table></figure><p>参考：<a href="https://kubernetes.io/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster" target="_blank" rel="noopener">backing up an etcd cluster</a></p><h2 id="第二十题-7-DNS"><a href="#第二十题-7-DNS" class="headerlink" title="第二十题 (7%) DNS"></a>第二十题 (7%) DNS</h2><p>按如下要求创建一个 Deployment：</p><p>名称：nginx-random<br>通过 Service 暴露：nginx-random<br>确保 Service 和 Pod 可通过各自的 DNS 记录访问<br>在此 Deployment 中运行的任何 Pod 内的 Container 都应使用 nginx image<br>接下来，使用实用工具 nslookup 查询该 Service 和 Pod 的 DNS 记录，并将输出结果分别写入 /opt/dir/service.dns 和 /opt/dir/Pod.dns</p><p>确保在任何测试中使用 busybox</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">run</span> nginx-dns <span class="hljs-attribute">--image</span>=nginx<br>kubectl expose deployment nginx-dns <span class="hljs-attribute">--port</span>=80<br>kubectl <span class="hljs-builtin-name">get</span> pods - o wide 获取pod的IP<br>kubectl <span class="hljs-builtin-name">run</span> busybox -it --rm <span class="hljs-attribute">--image</span>=busybox:1.28 sh<br>　　nslookup nginx-dns<br>　　nslookup 获取pod的IP<br></code></pre></div></td></tr></table></figure><p>考点：网络相关，DNS 解析</p><p>参考：<a href="https://kubernetes.io/docs/tasks/administer-cluster/dns-debugging-resolution/" target="_blank" rel="noopener">Debugging DNS Resolution</a></p><h2 id="第二十一题-2-CPU"><a href="#第二十一题-2-CPU" class="headerlink" title="第二十一题 (2%) CPU"></a>第二十一题 (2%) CPU</h2><p>通过 Pod Label name=cpu-user，找到运行时占用大量 CPU 的 Pod，并将占用 CPU 最高的 Pod 名称写入文件 /opt/dir/1234.txt (已存在)。</p><figure class="highlight coq"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coq">kubectl <span class="hljs-built_in">top</span> pod |<span class="hljs-type">grep</span> -iv name|<span class="hljs-type">sort</span> -k <span class="hljs-number">2</span> -n<br></code></pre></div></td></tr></table></figure><p><strong>列出 Service 名为 test 下的 pod 并找出使用 CPU 使用率最高的一个，将 pod 名称写入文件中</strong></p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros"><span class="hljs-comment">#使用-o wide 获取service test的SELECTOR</span><br>kubectl <span class="hljs-builtin-name">get</span> svc test -o wide<br><span class="hljs-comment">##获取结果我就随便造了</span><br>NAME <span class="hljs-built_in"> TYPE </span>       CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE       SELECTOR<br>test  ClusterIP   None         &lt;none&gt;        3306/TCP   50d       <span class="hljs-attribute">app</span>=wordpress,tier=mysql<br><br><span class="hljs-comment">#获取对应SELECTOR的pod使用率，找到最大那个写入文件中</span><br>kubectl top test -l <span class="hljs-string">'app=wordpress,tier=mysql'</span><br></code></pre></div></td></tr></table></figure><p>考点：获取 service selector，kubectl top 监控 pod 资源</p><p>参考：<a href="https://kubernetes.io/docs/tasks/debug-application-cluster/resource-usage-monitoring" target="_blank" rel="noopener">Tools for Monitoring Resources</a></p><h2 id="第二十二题-2-Taint"><a href="#第二十二题-2-Taint" class="headerlink" title="第二十二题 (2%) Taint"></a>第二十二题 (2%) Taint</h2><p>检查有多少 Nodes 已准备就绪(不包括被打上 Taint: NoSchedule 的节点)，并将数量写入 /opt/dir/nodes.txt。</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">kubectl <span class="hljs-built_in">get</span> nodes --show-labels|<span class="hljs-keyword">grep</span> -<span class="hljs-keyword">vi</span> schedule |<span class="hljs-keyword">grep</span> -<span class="hljs-keyword">vi</span> <span class="hljs-keyword">version</span> |<span class="hljs-keyword">grep</span> -i ready |wc -<span class="hljs-keyword">l</span><br><br><br>#CheatSheet方法，应该还能优化JSONPATH<br>JSONPATH=<span class="hljs-string">'&#123;range .items[*]&#125;&#123;@.metadata.name&#125;:&#123;range @.status.conditions[*]&#125;&#123;@.type&#125;=&#123;@.status&#125;;&#123;end&#125;&#123;end&#125;'</span> \<br> &amp;&amp; kubectl <span class="hljs-built_in">get</span> nodes -<span class="hljs-keyword">o</span> jsonpath=<span class="hljs-string">"$JSONPATH"</span> | <span class="hljs-keyword">grep</span> <span class="hljs-string">"Ready=True"</span><br></code></pre></div></td></tr></table></figure><p>考点：kubectl 命令熟悉程度</p><p>参考：<a href="https://kubernetes.io/docs/reference/kubectl/cheatsheet/" target="_blank" rel="noopener">kubectl cheatsheet</a></p><h2 id="第二十三题-1-Scale"><a href="#第二十三题-1-Scale" class="headerlink" title="第二十三题 (1%) Scale"></a>第二十三题 (1%) Scale</h2><p>Scale the deployment webserver to 6 pods</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">[<span class="hljs-symbol">root@</span>vms31 opt]# kubectl <span class="hljs-keyword">get</span> deployments.<br>NAME        DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE<br>nginx-app   <span class="hljs-number">3</span>         <span class="hljs-number">3</span>         <span class="hljs-number">3</span>            <span class="hljs-number">3</span>           <span class="hljs-number">11</span>h<br>webserver   <span class="hljs-number">1</span>         <span class="hljs-number">1</span>         <span class="hljs-number">1</span>            <span class="hljs-number">1</span>           <span class="hljs-number">174</span>d<br>[<span class="hljs-symbol">root@</span>vms31 opt]# kubectl scale --replicas=<span class="hljs-number">6</span> deployment/webserver<br>deployment.extensions/webserver scaled<br>[<span class="hljs-symbol">root@</span>vms31 opt]# kubectl <span class="hljs-keyword">get</span> deployments.<br>NAME        DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE<br>nginx-app   <span class="hljs-number">3</span>         <span class="hljs-number">3</span>         <span class="hljs-number">3</span>            <span class="hljs-number">3</span>           <span class="hljs-number">11</span>h<br>webserver   <span class="hljs-number">6</span>         <span class="hljs-number">6</span>         <span class="hljs-number">6</span>            <span class="hljs-number">1</span>           <span class="hljs-number">174</span>d<br></code></pre></div></td></tr></table></figure><p>考点：deployment 的 Scaling，搜索 Scaling</p><p>参考：<a href="https://kubernetes.io/docs/tasks/run-application/run-stateless-application-deployment/#scaling-the-application-by-increasing-the-replica-count" target="_blank" rel="noopener">Scaling the application by increasing the replica count</a></p><h2 id="第二十四题-4-Static-Pod"><a href="#第二十四题-4-Static-Pod" class="headerlink" title="第二十四题 (4%) Static Pod"></a>第二十四题 (4%) Static Pod</h2><p>configure the kubelet systemed managed service, on the node labelled with name=wk8s-node-1,to launch a pod containing a single container of image nginx named</p><p>myservice automatically.Any spec file requried should be placed in the /etc/kuberneteds/mainfests directory on the node</p><p>Hints:</p><p>You can ssh to the failed node using $ ssh wk8s-node-0</p><p>You can assume elevated privileges on the node with the following command $ sudo -i</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">vi /etc/systemd/system/kubelet.service<br>添加下面参数<br><span class="hljs-attribute">--pod-manifest-path</span>=/etc/kubernetes/manifests<br>使用下面的参考命令生成pod文件<br>kubectl <span class="hljs-builtin-name">run</span> myservice <span class="hljs-attribute">--image</span>=nginx <span class="hljs-attribute">--generator</span>=run-pod/v1 --dry-<span class="hljs-builtin-name">run</span> -o yaml &gt; /etc/kubernetes/manifests/24.yml<br>重启服务<br>systemctl start kubelet<br></code></pre></div></td></tr></table></figure><h1 id="题库二"><a href="#题库二" class="headerlink" title="题库二"></a>题库二</h1><h2 id="第二十五题：-Ingress"><a href="#第二十五题：-Ingress" class="headerlink" title="第二十五题： Ingress"></a>第二十五题： Ingress</h2><p>部署 ingress controller，创建 ingress，域名为***，使得 curl 该域名，返回 200 ok</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># 部署ingres controller</span><br><span class="hljs-string">kubectl</span> <span class="hljs-string">apply</span> <span class="hljs-string">-f</span> <span class="hljs-string">https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/mandatory.yaml</span><br><br><span class="hljs-comment">#创建规则</span><br><span class="hljs-string">[root@dce-bj-master-21</span> <span class="hljs-string">ingress]#</span> <span class="hljs-string">cat</span> <span class="hljs-string">ingress-rule.yml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">extensions/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">a2048</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">dce.daocloud.io/app:</span> <span class="hljs-string">dao-2048</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-number">2048.</span><span class="hljs-string">fuck.you</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/1</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">serviceName:</span> <span class="hljs-string">dao-2048</span><br>          <span class="hljs-attr">servicePort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/2</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">serviceName:</span> <span class="hljs-string">dao-2049</span><br>          <span class="hljs-attr">servicePort:</span> <span class="hljs-number">80</span><br></code></pre></div></td></tr></table></figure><h2 id="第二十六题：Job"><a href="#第二十六题：Job" class="headerlink" title="第二十六题：Job"></a>第二十六题：Job</h2><p>创建一个固定结束次数的并行 Job，共 2 个 pod，运行 45 completion，Job pod 打印“Beijing”。镜像自选</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">cat</span> <span class="hljs-string">job.yaml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">busybox</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">parallelism:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">completions:</span> <span class="hljs-number">45</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">busybox</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>        <span class="hljs-attr">command:</span> <span class="hljs-string">["echo",</span> <span class="hljs-string">"Beijing"</span><span class="hljs-string">]</span><br>      <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span><br><span class="hljs-string">[root@conn01</span> <span class="hljs-string">~]#</span> <span class="hljs-string">kubectl</span> <span class="hljs-string">describe</span> <span class="hljs-string">job</span> <span class="hljs-string">busybox</span><br><span class="hljs-string">……</span><br><span class="hljs-attr">Pods Statuses:</span>  <span class="hljs-number">0</span> <span class="hljs-string">Running</span> <span class="hljs-string">/</span> <span class="hljs-number">45</span> <span class="hljs-string">Succeeded</span> <span class="hljs-string">/</span> <span class="hljs-number">0</span> <span class="hljs-string">Failed</span><br><span class="hljs-string">……</span><br><span class="hljs-string">[root@conn01</span> <span class="hljs-string">~]#</span> <span class="hljs-string">kubectl</span> <span class="hljs-string">logs</span>  <span class="hljs-string">busybox-cj86j</span><br><span class="hljs-string">Beijing</span><br></code></pre></div></td></tr></table></figure><h2 id="第二十七题：Network"><a href="#第二十七题：Network" class="headerlink" title="第二十七题：Network"></a>第二十七题：Network</h2><p>namespace secure 中存在一个 redis 的 pod，配置该 namespace 的 network policy，拒绝其它 namespace 中的 pod 的访问，指定某一个 namespace 中的 pod 可以访问 redis pod 的 6379 端口。集群的 k8s 版本为 1.6.2。参考：<a href="https://v1-6.docs.kubernetes.io/docs/concepts/services-networking/network-policies/" target="_blank" rel="noopener">https://v1-6.docs.kubernetes.io/docs/concepts/services-networking/network-policies/</a></p><p><strong>创建 NameSpace 的 Policy</strong></p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-symbol">kind:</span> NetworkPolicy<br><span class="hljs-symbol">apiVersion:</span> networking.k8s.io/v1<br><span class="hljs-symbol">metadata:</span><br><span class="hljs-symbol">  namespace:</span> secure<br><span class="hljs-symbol">  name:</span> deny-other-namespaces<br><span class="hljs-symbol">spec:</span><br><span class="hljs-symbol">  podSelector:</span> &#123;&#125;<br><span class="hljs-symbol">  policyTypes:</span><br>  - Ingress<br></code></pre></div></td></tr></table></figure><p><strong>创建 POD 和 POD 的 Policy</strong></p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">NetworkPolicy</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">test-network-policy</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">secure</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">podSelector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">role:</span> <span class="hljs-string">redis</span><br>  <span class="hljs-attr">policyTypes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Ingress</span><br>  <span class="hljs-attr">ingress:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">from:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">namespaceSelector:</span><br>        <span class="hljs-attr">matchLabels:</span><br>          <span class="hljs-attr">project:</span> <span class="hljs-string">myproject</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">podSelector:</span><br>        <span class="hljs-attr">matchLabels:</span><br>          <span class="hljs-attr">role:</span> <span class="hljs-string">frontend</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br></code></pre></div></td></tr></table></figure><h2 id="第二十八题：Annotation"><a href="#第二十八题：Annotation" class="headerlink" title="第二十八题：Annotation"></a>第二十八题：Annotation</h2><p>创建一个 deployment，该 deployment 具有 app=***的 annotation，将 deployment 的 yaml 文件保存至指定目录</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">kubectl annotate deploy <span class="hljs-built_in">test</span>-alpine app=<span class="hljs-string">'ckaexam'</span><br></code></pre></div></td></tr></table></figure><h2 id="第二十九题：RBAC"><a href="#第二十九题：RBAC" class="headerlink" title="第二十九题：RBAC"></a>第二十九题：RBAC</h2><p>使用 rbac 资源，包括 role、rolebinding 等，具体可参考官方文档</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">读取ns default下的 Pod 的权限和列出 Pod 的权限<br>kind: Role<br>apiVersion: rbac.authorization.k8s.io/v1<br>metadata:<br>  namespace: default<br>  name: pod-reader<br>rules:<br>- apiGroups: [<span class="hljs-string">""</span>] #<span class="hljs-string">""</span> indicates the core API group<br>  resources: [<span class="hljs-string">"pods"</span>]<br>  verbs: [<span class="hljs-string">"get"</span>, <span class="hljs-string">"watch"</span>, <span class="hljs-string">"list"</span>]<br><br>给用户jane读取ns default下的 Pod 的权限和列出 Pod 的权限<br>kind: RoleBinding<br>apiVersion: rbac.authorization.k8s.io/v1<br>metadata:<br>  name: read-pods<br>  namespace: default<br>subjects:<br>- kind: User<br>  name: jane<br>  apiGroup: rbac.authorization.k8s.io<br>roleRef:<br>  kind: Role<br>  name: pod-reader<br>  apiGroup: rbac.authorization.k8s.io<br></code></pre></div></td></tr></table></figure><h2 id="第三十题：Network"><a href="#第三十题：Network" class="headerlink" title="第三十题：Network"></a>第三十题：Network</h2><p>登陆另一集群，该集群未配置网络，选择 calico 配置集群网络。创建 pod，配置 network policy。可参考 k8s 官网 network policy</p><p><strong>参考:</strong></p><p><a href="http://dwiki.daocloud.io/pages/viewpage.action?pageId=13060400" target="_blank" rel="noopener">http://dwiki.daocloud.io/pages/viewpage.action?pageId=13060400</a></p><p><a href="https://blog.csdn.net/deerjoe/article/details/86300826" target="_blank" rel="noopener">https://blog.csdn.net/deerjoe/article/details/86300826</a></p><p><a href="https://www.cncf.io/certification/cka/faq/" target="_blank" rel="noopener">https://www.cncf.io/certification/cka/faq/</a></p><p><a href="https://www.cnblogs.com/mustark/articles/11133539.html" target="_blank" rel="noopener">https://www.cnblogs.com/mustark/articles/11133539.html</a> (最全)</p>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CKA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派zerow使用</title>
    <link href="/2019/11/15/%E6%A0%91%E8%8E%93%E6%B4%BEzerow%E4%BD%BF%E7%94%A8/"/>
    <url>/2019/11/15/%E6%A0%91%E8%8E%93%E6%B4%BEzerow%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>树莓派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>zero_w</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>怎么写好一个技术方案</title>
    <link href="/2019/11/11/%E6%80%8E%E4%B9%88%E5%86%99%E5%A5%BD%E4%B8%80%E4%B8%AA%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"/>
    <url>/2019/11/11/%E6%80%8E%E4%B9%88%E5%86%99%E5%A5%BD%E4%B8%80%E4%B8%AA%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="怎么写好一个技术方案"><a href="#怎么写好一个技术方案" class="headerlink" title="怎么写好一个技术方案"></a>怎么写好一个技术方案</h2><blockquote><p>本文作为运维或开发面临转型,或者其他种种原因需要写技术方案时的一个初级版分解。</p></blockquote><hr><h3 id="三大忌讳"><a href="#三大忌讳" class="headerlink" title="三大忌讳"></a>三大忌讳</h3><blockquote><p>切勿不清楚方案目的就开始写方案<br>切勿一上来就直接写技术内容<br>切勿思路不清晰就开始写方案</p></blockquote><h3 id="正文内容"><a href="#正文内容" class="headerlink" title="正文内容"></a>正文内容</h3><p>这里拿日志方案作为案例</p><blockquote><p>目的：<br>日志方案能够提供什么样的能力？<br>—切勿一上来就直接写技术内容–</p></blockquote><p>业务层面：</p><blockquote><ol><li>有哪些日志？ 主机日志、平台日志、pod 日志、应用日志</li><li>这些日志在哪里？ 主机日志：监控系统里面？自己要搭一个监控系统去获取？ 平台日志：DCE 的平台日志在哪里？pod 日志：怎么获取？（pod 什么时候启动的、什么时候消亡、什么时候重启） 应用日志：业务交易日志</li><li>在不同的场景下，这些日志从哪里来的？ 主机日志：自行产生，是否有监控系统 平台日志：DCE 给的 pod 日志：promethues？ 应用日志：应用自行产生</li><li>我能通过这些日志得到什么？ 主机日志：留给 IaaS 去做。主机日志可以帮助 PaaS 排错，规避风险，做容量规划 平台日志：监控平台状态 pod 日志：监控 pod、容器状态（CPU、内存、存储）-&gt;是否需要扩容 应用日志：应用交易质量分析预测</li><li>日志生命周期是什么？（日志怎么产生的、日志怎么消费的、日志怎么存储的、日志怎么备份的、日志怎么从备份中恢复）。</li><li>日志产生 日志存储 日志消费（采集-分析-报表）日志备份 日志恢复</li></ol></blockquote><hr><p>技术层面：</p><blockquote><ol><li>架构 -&gt; 技术选型 -&gt; 常用解决方案(ELK/Splunk) -&gt; 对比</li><li>你推荐哪个方案（框架选型、ELK？EFK？）？为什么？</li><li>部署架构 -&gt; ELK，需要多少资源，这些资源能处理多少量的日志？</li></ol></blockquote><hr><p>其他一些问题：</p><blockquote><ol><li>应用日志打日志规范</li><li>备份日志规范</li><li>其他一些很细节问题</li><li>…..</li></ol></blockquote><hr><p>写方案的套路过程：</p><blockquote><p>Why -&gt; 我为什么要做（业务目的是什么？）这个阶段不要想任何的技术实现和工具<br>How -&gt; 我怎么做这个事情（业务处理逻辑、这个事情里面，有哪些事情。日志收集、分析，etc…）<br>|||<br>（这个阶段才需要考虑技术实现）<br>What -&gt; 我用什么做，以及客户会得到什么？（日志预测分析系统，它是用什么什么做的，规模有多大，能处理多大的业务量）</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>方案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>怎么优雅快速激活windows10</title>
    <link href="/2019/11/04/%E6%80%8E%E4%B9%88%E4%BC%98%E9%9B%85%E5%BF%AB%E9%80%9F%E6%BF%80%E6%B4%BBwindows10/"/>
    <url>/2019/11/04/%E6%80%8E%E4%B9%88%E4%BC%98%E9%9B%85%E5%BF%AB%E9%80%9F%E6%BF%80%E6%B4%BBwindows10/</url>
    
    <content type="html"><![CDATA[<h2 id="安装windows激活问题"><a href="#安装windows激活问题" class="headerlink" title="安装windows激活问题"></a>安装windows激活问题</h2><blockquote><p>每次装windows系统最烦的就是激活,当年小白时候  激活下了四五个软件，什么小马激活啊 旋风激活 等等<br>今天介绍一个方便的激活方法，不需要下软件 直接激活的方法</p></blockquote><h3 id="KMS"><a href="#KMS" class="headerlink" title="KMS"></a>KMS</h3><blockquote><p>Key Management Service（简称:KMS），这个功能是在Windows Vista之后的产品中的一种新型产品激活机制，目的是为了Microsoft更好的遏制非法软件授权行为 (但是激活更鸡儿方便了！！！)</p></blockquote><h3 id="KMS使用方法"><a href="#KMS使用方法" class="headerlink" title="KMS使用方法"></a>KMS使用方法</h3><blockquote><ol><li>寻找可用的kms服务器<br>本人自己搭建了一个kms服务器地址为 ss.jxhs.me (docker run -itd -p 1688:1688 luodaoyi/kms-server )<br>目前互联网中可用的kms服务器<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">zh</span><span class="hljs-selector-class">.us</span><span class="hljs-selector-class">.to</span> 有效<br><span class="hljs-selector-tag">kms</span><span class="hljs-selector-class">.03k</span><span class="hljs-selector-class">.org</span> 有效<br><span class="hljs-selector-tag">kms</span><span class="hljs-selector-class">.chinancce</span><span class="hljs-selector-class">.com</span> 有效<br><span class="hljs-selector-tag">kms</span><span class="hljs-selector-class">.shuax</span><span class="hljs-selector-class">.com</span> 有效<br><span class="hljs-selector-tag">kms</span><span class="hljs-selector-class">.dwhd</span><span class="hljs-selector-class">.org</span> 有效<br><span class="hljs-selector-tag">kms</span><span class="hljs-selector-class">.luody</span><span class="hljs-selector-class">.info</span> 有效<br><span class="hljs-selector-tag">kms</span><span class="hljs-selector-class">.digiboy</span><span class="hljs-selector-class">.ir</span> 有效<br><span class="hljs-selector-tag">kms</span><span class="hljs-selector-class">.lotro</span><span class="hljs-selector-class">.cc</span> 有效<br><span class="hljs-selector-tag">ss</span><span class="hljs-selector-class">.yechiu</span><span class="hljs-selector-class">.xin</span> 有效<br><span class="hljs-selector-tag">www</span><span class="hljs-selector-class">.zgbs</span><span class="hljs-selector-class">.cc</span> 有效<br><span class="hljs-selector-tag">cy2617</span><span class="hljs-selector-class">.jios</span><span class="hljs-selector-class">.org</span> 有效<br></code></pre></div></td></tr></table></figure></li><li>“以管理员身份”打开“MSDOS”窗口，输出命令：slmgr.vbs /upk 按回车进行确定，显示“已成功卸载了产品密钥”<br><img src="https://i.loli.net/2019/11/05/suZXGyC9D3Rb2W7.png" srcset="/img/loading.gif" alt="cmd"><br><img src="https://i.loli.net/2019/11/05/wZJRd7PyqkmX19K.png" srcset="/img/loading.gif" alt="delete"></li><li>输入命令：slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX        (任意一个win10激活密钥,不行就换)<br><img src="https://i.loli.net/2019/11/05/HghASl1XGvW6Msa.png" srcset="/img/loading.gif" alt="slmg"></li><li>继续输入命令：slmgr /skms ss.jxhs.me<br><img src="https://i.loli.net/2019/11/05/doB1CQUSN2E3VFq.png" srcset="/img/loading.gif" alt="ss.jxhs.me"></li><li>接下来输入命令：slmgr /ato     窗口提示：“成功的激活了产品”；<br><img src="https://i.loli.net/2019/11/05/WGA2ejbaQNMiqX1.png" srcset="/img/loading.gif" alt="激活"><br>就这么几步就完事了</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>科学上网之-自己动手丰衣足食</title>
    <link href="/2019/11/02/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E4%B9%8B-%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E4%B8%B0%E8%A1%A3%E8%B6%B3%E9%A3%9F/"/>
    <url>/2019/11/02/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E4%B9%8B-%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E4%B8%B0%E8%A1%A3%E8%B6%B3%E9%A3%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="自建ss-ssr教程很简单，整个教程分三步："><a href="#自建ss-ssr教程很简单，整个教程分三步：" class="headerlink" title="自建ss/ssr教程很简单，整个教程分三步："></a>自建ss/ssr教程很简单，整个教程分三步：</h2><blockquote><p>第一步：购买VPS服务器</p><p>第二步：一键部署VPS服务器</p><p>第三步：一键加速VPS服务器</p></blockquote><h3 id="第一步-购买服务器"><a href="#第一步-购买服务器" class="headerlink" title="第一步:购买服务器"></a>第一步:购买服务器</h3><blockquote><p>购买一个非大陆的服务器(目前全世界只有朝鲜和其他国家坚持封杀google)<br>比如搬瓦工 或者阿里云香港 都行<br>阿里云香港的 阿里云的推荐轻量服务器 贼鸡儿便宜 24块钱一个月…<br><img src="https://i.loli.net/2019/11/02/u4CcOfZRkwqthHi.png" srcset="/img/loading.gif" alt="阿里云轻量服务器"><br>好了 这里其他的就不说了 买centos7的服务器就完事了</p></blockquote><h3 id="第二步-安装ss服务端"><a href="#第二步-安装ss服务端" class="headerlink" title="第二步:安装ss服务端"></a>第二步:安装ss服务端</h3><blockquote><p>yum -y install wget<br>wget –no-check-certificate <a href="https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh" target="_blank" rel="noopener">https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh</a><br>chmod +x shadowsocksR.sh<br>./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log<br><img src="https://i.loli.net/2019/11/02/d9ADGxQ4B7TzVXN.png" srcset="/img/loading.gif" alt="安装"><br>如上图出现管理界面后，输入数字1来安装SSR服务端。<br><img src="https://i.loli.net/2019/11/02/sg1YX9zLcrtPRhU.png" srcset="/img/loading.gif" alt="设置端口"><br>根据上图提示，依次输入自己想设置的端口和密码 (密码建议用复杂点的字母组合，端口号为40-65535之间的数字)，回车键用于确认<br><img src="https://i.loli.net/2019/11/02/6IwaMfy9UsqoGYA.png" srcset="/img/loading.gif" alt="加密方式"><br>如上图，选择想设置的加密方式，比如10，按回车键确认<br><img src="https://i.loli.net/2019/11/02/VwO49t6hcrgEdsL.png" srcset="/img/loading.gif" alt="下载相关文件"><br>提示你下载文件，输入：y<br><img src="https://i.loli.net/2019/11/02/stL3oluRCArhyeV.png" srcset="/img/loading.gif" alt="安装完成"><br>耐心等待一会，出现上面的界面即部署完成：</p></blockquote><hr><h3 id="第三步-安装加速器"><a href="#第三步-安装加速器" class="headerlink" title="第三步:安装加速器"></a>第三步:安装加速器</h3><blockquote><p>centos6不支持bbr加速 只能用破解版锐速加速</p><p>yum -y install wget</p><p>wget –no-check-certificate <a href="https://github.com/teddysun/across/raw/master/&gt;" target="_blank" rel="noopener">https://github.com/teddysun/across/raw/master/&gt;</a> bbr.sh</p><p>chmod +x bbr.sh</p><p>./bbr.sh</p></blockquote><p>把上面整个代码复制后粘贴进去，不动的时候按回车，然后耐心等待，最后重启vps服务器即可。<br>安装完成以后重启<br>服务器重启成功并重新连接服务器后，输入命令lsmod | grep bbr 如果出现tcp_bbr字样表示bbr已安装并启动成功。如图：<br><img src="https://i.loli.net/2019/11/02/dWR1oeF6Mk4L35x.png" srcset="/img/loading.gif" alt="bbr"></p><h3 id="为中华之崛起而翻墙"><a href="#为中华之崛起而翻墙" class="headerlink" title="为中华之崛起而翻墙 :-)"></a>为中华之崛起而翻墙 :-)</h3>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用client-go包访问KubernetesCRD</title>
    <link href="/2019/10/27/%E4%BD%BF%E7%94%A8client-go%E5%8C%85%E8%AE%BF%E9%97%AEKubernetesCRD/"/>
    <url>/2019/10/27/%E4%BD%BF%E7%94%A8client-go%E5%8C%85%E8%AE%BF%E9%97%AEKubernetesCRD/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用动态存储卷StorageClass使用nfs</title>
    <link href="/2019/10/27/%E5%88%A9%E7%94%A8%E5%8A%A8%E6%80%81%E5%AD%98%E5%82%A8%E5%8D%B7StorageClass%E4%BD%BF%E7%94%A8nfs/"/>
    <url>/2019/10/27/%E5%88%A9%E7%94%A8%E5%8A%A8%E6%80%81%E5%AD%98%E5%82%A8%E5%8D%B7StorageClass%E4%BD%BF%E7%94%A8nfs/</url>
    
    <content type="html"><![CDATA[<p>之前我们部署了PV 和 PVC 的使用方法，但是前面的 PV 都是静态的，什么意思？就是我要使用的一个 PVC 的话就必须手动去创建一个 PV，我们也说过这种方式在很大程度上并不能满足我们的需求，比如我们有一个应用需要对存储的并发度要求比较高，而另外一个应用对读写速度又要求比较高，特别是对于 StatefulSet 类型的应用简单的来使用静态的 PV 就很不合适了，这种情况下我们就需要用到动态 PV，也就是我们今天要讲解的 StorageClass。</p><p>我们这里演示一下NFS的动态PV创建</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>要使用 StorageClass，我们就得安装对应的自动配置程序，比如我们这里存储后端使用的是 nfs，那么我们就需要使用到一个 nfs-client 的自动配置程序，我们也叫它 Provisioner，这个程序使用我们已经配置好的 nfs 服务器，来自动创建持久卷，也就是自动帮我们创建 PV。</p><p>自动创建的 PV 以${namespace}-${pvcName}-${pvName}这样的命名格式创建在 NFS 服务器上的共享数据目录中<br>而当这个 PV 被回收后会以archieved-${namespace}-${pvcName}-${pvName}这样的命名格式存在 NFS 服务器上。</p><blockquote><p>kubernetes本身支持的动态PV创建不包括nfs，所以需要使用额外插件实现。nfs-client</p></blockquote><hr><p>第一步：配置 Deployment，将里面的对应的参数替换成我们自己的 nfs 配置（nfs-client.yaml）<br>第二步：将环境变量 NFS_SERVER 和 NFS_PATH 替换，当然也包括下面的 nfs 配置，我们可以看到我们这里使用了一个名为 nfs-client-provisioner 的serviceAccount，所以我们也需要创建一个 sa，然后绑定上对应的权限：（nfs-client-sa.yaml）<br>第三步：nfs-client 的 Deployment 声明完成后，我们就可以来创建一个StorageClass对象了：（nfs-client-class.yaml）</p><blockquote><p>我们整合三个配置，如下</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-provisioner</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-provisioner-runner</span><br><span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> <span class="hljs-string">[""]</span><br>    <span class="hljs-attr">resources:</span> <span class="hljs-string">["persistentvolumes"]</span><br>    <span class="hljs-attr">verbs:</span> <span class="hljs-string">["get",</span> <span class="hljs-string">"list"</span><span class="hljs-string">,</span> <span class="hljs-string">"watch"</span><span class="hljs-string">,</span> <span class="hljs-string">"create"</span><span class="hljs-string">,</span> <span class="hljs-string">"delete"</span><span class="hljs-string">]</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> <span class="hljs-string">[""]</span><br>    <span class="hljs-attr">resources:</span> <span class="hljs-string">["persistentvolumeclaims"]</span><br>    <span class="hljs-attr">verbs:</span> <span class="hljs-string">["get",</span> <span class="hljs-string">"list"</span><span class="hljs-string">,</span> <span class="hljs-string">"watch"</span><span class="hljs-string">,</span> <span class="hljs-string">"update"</span><span class="hljs-string">]</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> <span class="hljs-string">["storage.k8s.io"]</span><br>    <span class="hljs-attr">resources:</span> <span class="hljs-string">["storageclasses"]</span><br>    <span class="hljs-attr">verbs:</span> <span class="hljs-string">["get",</span> <span class="hljs-string">"list"</span><span class="hljs-string">,</span> <span class="hljs-string">"watch"</span><span class="hljs-string">]</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> <span class="hljs-string">[""]</span><br>    <span class="hljs-attr">resources:</span> <span class="hljs-string">["events"]</span><br>    <span class="hljs-attr">verbs:</span> <span class="hljs-string">["list",</span> <span class="hljs-string">"watch"</span><span class="hljs-string">,</span> <span class="hljs-string">"create"</span><span class="hljs-string">,</span> <span class="hljs-string">"update"</span><span class="hljs-string">,</span> <span class="hljs-string">"patch"</span><span class="hljs-string">]</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">run-nfs-client-provisioner</span><br><span class="hljs-attr">subjects:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-provisioner</span><br>    <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br><span class="hljs-attr">roleRef:</span><br>  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-provisioner-runner</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-provisioner</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nfs-client-provisioner</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">strategy:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">Recreate</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nfs-client-provisioner</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">serviceAccount:</span> <span class="hljs-string">nfs-client-provisioner</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-provisioner</span><br>          <span class="hljs-attr">image:</span> <span class="hljs-string">jmgao1983/nfs-client-provisioner</span><br>          <span class="hljs-attr">volumeMounts:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-root</span><br>              <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/persistentvolumes</span><br>          <span class="hljs-attr">resources:</span><br>            <span class="hljs-attr">requests:</span><br>              <span class="hljs-attr">cpu:</span> <span class="hljs-string">"0.4"</span><br>              <span class="hljs-attr">memory:</span> <span class="hljs-string">"1Gi"</span><br>            <span class="hljs-attr">limits:</span><br>              <span class="hljs-attr">cpu:</span> <span class="hljs-string">"1"</span><br>              <span class="hljs-attr">memory:</span> <span class="hljs-string">"1Gi"</span><br>          <span class="hljs-attr">env:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">PROVISIONER_NAME</span><br>              <span class="hljs-attr">value:</span> <span class="hljs-string">fuseim.pri/ifs2</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">NFS_SERVER</span><br>              <span class="hljs-attr">value:</span> <span class="hljs-number">10.6</span><span class="hljs-number">.204</span><span class="hljs-number">.1</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">NFS_PATH</span><br>              <span class="hljs-attr">value:</span> <span class="hljs-string">/data/nfs</span><br>      <span class="hljs-attr">volumes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-root</span><br>          <span class="hljs-attr">nfs:</span><br>            <span class="hljs-attr">server:</span> <span class="hljs-number">10.6</span><span class="hljs-number">.204</span><span class="hljs-number">.1</span><br>            <span class="hljs-attr">path:</span> <span class="hljs-string">/data/nfs</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">storage.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StorageClass</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-storage</span><br><span class="hljs-attr">provisioner:</span> <span class="hljs-string">fuseim.pri/ifs2</span><br></code></pre></div></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>查看创建好的storageclass<br><img src="/img/newimg/006tNbRwgy1ga9zbr3jiwj30ls050js9.jpg" srcset="/img/loading.gif" alt="storageclass"></p><p>创建pvc,查看是否自动创建相应的pv</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-symbol">apiVersion:</span> v1<br><span class="hljs-symbol">kind:</span> PersistentVolumeClaim<br><span class="hljs-symbol">metadata:</span><br><span class="hljs-symbol">  name:</span> nfs-pvc001<br><span class="hljs-symbol">  namespace:</span> default<br><span class="hljs-symbol">spec:</span><br><span class="hljs-symbol">  storageClassName:</span> nfs-storage  <span class="hljs-meta"># 匹配pvc名</span><br><span class="hljs-symbol">  accessModes:</span>  <br>  - ReadWriteMany<br><span class="hljs-symbol">  resources:</span> <br><span class="hljs-symbol">    requests:</span><br><span class="hljs-symbol">      storage:</span> <span class="hljs-number">500</span>Mi  <span class="hljs-meta"># 定义要求有多大空间</span><br></code></pre></div></td></tr></table></figure><p>执行可以发现，创建pvc请求以后，pvc已经绑定上自动创建的pv中。<br><img src="/img/newimg/006tNbRwgy1ga9zf0kl7aj31yw0deqjn.jpg" srcset="/img/loading.gif" alt="bond"></p>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s,nfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用nfs作为k8s持久化存储</title>
    <link href="/2019/10/25/%E7%94%A8nfs%E4%BD%9C%E4%B8%BAk8s%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/"/>
    <url>/2019/10/25/%E7%94%A8nfs%E4%BD%9C%E4%B8%BAk8s%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="kubernetes部署NFS持久存储"><a href="#kubernetes部署NFS持久存储" class="headerlink" title="kubernetes部署NFS持久存储"></a>kubernetes部署NFS持久存储</h2><h3 id="NFS简介"><a href="#NFS简介" class="headerlink" title="NFS简介"></a>NFS简介</h3><blockquote><p>NFS是网络文件系统Network File System的缩写，NFS服务器可以让PC将网络中的NFS服务器共享的目录挂载到本地的文件系统中，而在本地的系统中来看，那个远程主机的目录就好像是自己的一个磁盘分区一样。</p><figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel">kubernetes使用NFS共享存储有两种方式：<br>手动方式静态创建所需要的<span class="hljs-built_in">PV</span>和PVC。<br>通过创建PVC动态地创建对应<span class="hljs-built_in">PV</span>，无需手动创建<span class="hljs-built_in">PV</span>。<br>这条博客是写的静态创建方法<br></code></pre></div></td></tr></table></figure><p>可以发现k8s中的Volume（无论何种类型）和使用它的Pod都是一种静态绑定关系，在Pod定义文件中，同时定义了它使用的Volume。在这种情况下，Volume是Pod的附属品，我们无法像创建其他资源（例如Pod，Node，Deployment等等）一样创建一个Volume。</p></blockquote><p>因此Kubernetes提出了PersistentVolume（PV）的概念。PersistentVolume和Volume一样，代表了集群中的一块存储区域，然而Kubernetes将PersistentVolume抽象成了一种集群资源，类似于集群中的Node对象，这意味着我们可以使用Kubernetes API来创建PersistentVolume对象。PV与Volume最大的不同是PV拥有着独立于Pod的生命周期。</p><p>而PersistentVolumeClaim（PVC）代表了用户对PV资源的请求。用户需要使用PV资源时，只需要创建一个PVC对象（包括指定使用何种存储资源，使用多少GB，以何种模式使用PV等信息），Kubernetes会自动为我们分配我们所需的PV。如果把PersistentVolume类比成集群中的Node，那么PersistentVolumeClaim就相当于集群中的Pod，Kubernetes为Pod分配可用的Node，为PersistentVolumeClaim分配可用的PersistentVolume。</p><h3 id="搭建nfs服务器"><a href="#搭建nfs服务器" class="headerlink" title="搭建nfs服务器"></a>搭建nfs服务器</h3><p>这里作为测试，临时在master节点上部署NFS服务器。</p><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">#master节点安装nfs</span><br><span class="hljs-attr">yum</span> <span class="hljs-string">-y install nfs-utils</span><br><br><span class="hljs-comment">#创建nfs目录</span><br><span class="hljs-attr">mkdir</span> <span class="hljs-string">-p /data/nfs/</span><br><br><span class="hljs-comment">#修改权限</span><br><span class="hljs-attr">chmod</span> <span class="hljs-string">-R 777 /data/nfs</span><br><br><span class="hljs-comment">#编辑export文件</span><br><span class="hljs-attr">vim</span> <span class="hljs-string">/etc/exports</span><br><span class="hljs-meta">/data/nfs</span> <span class="hljs-string">*(rw,no_root_squash,sync)</span><br><br><span class="hljs-comment">#配置生效</span><br><span class="hljs-attr">exportfs</span> <span class="hljs-string">-r</span><br><span class="hljs-comment">#查看生效</span><br><span class="hljs-attr">exportfs</span><br><br><span class="hljs-comment">#启动rpcbind、nfs服务</span><br><span class="hljs-attr">systemctl</span> <span class="hljs-string">restart rpcbind &amp;&amp; systemctl enable rpcbind</span><br><span class="hljs-attr">systemctl</span> <span class="hljs-string">restart nfs &amp;&amp; systemctl enable nfs</span><br><br><span class="hljs-comment">#查看 RPC 服务的注册状况</span><br><span class="hljs-attr">rpcinfo</span> <span class="hljs-string">-p localhost</span><br><br><span class="hljs-comment">#showmount测试</span><br><span class="hljs-attr">showmount</span> <span class="hljs-string">-e 10.7.150.112</span><br><br><span class="hljs-comment">#所有node节点安装客户端</span><br><span class="hljs-attr">yum</span> <span class="hljs-string">-y install nfs-utils</span><br><span class="hljs-attr">systemctl</span> <span class="hljs-string">start nfs &amp;&amp; systemctl enable nfs</span><br></code></pre></div></td></tr></table></figure><blockquote><p>作为准备工作，我们已经在 k8s-master 节点上搭建了一个 NFS 服务器，目录为 /data/nfs.</p></blockquote><h3 id="静态申请PV卷"><a href="#静态申请PV卷" class="headerlink" title="静态申请PV卷"></a>静态申请PV卷</h3><h4 id="添加pv卷对应目录-作为挂载点"><a href="#添加pv卷对应目录-作为挂载点" class="headerlink" title="添加pv卷对应目录,作为挂载点"></a>添加pv卷对应目录,作为挂载点</h4><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-meta">#创建pv卷对应的目录</span><br><span class="hljs-title">mkdir</span> -p /nfs/<span class="hljs-class"><span class="hljs-keyword">data</span>/pv001</span><br><br><span class="hljs-meta">#配置exportrs</span><br><span class="hljs-title">vim</span> /etc/exports<br>/nfs/<span class="hljs-class"><span class="hljs-keyword">data</span> *(<span class="hljs-title">rw</span>,<span class="hljs-title">no_root_squash</span>,<span class="hljs-title">sync</span>)</span><br>/nfs/<span class="hljs-class"><span class="hljs-keyword">data</span>/pv001 *(<span class="hljs-title">rw</span>,<span class="hljs-title">no_root_squash</span>,<span class="hljs-title">sync</span>)</span><br><br><span class="hljs-meta">#配置生效</span><br><span class="hljs-title">exportfs</span> -r<br><span class="hljs-meta">#重启rpcbind、nfs服务</span><br><span class="hljs-title">systemctl</span> restart rpcbind &amp;&amp; systemctl restart nfs<br></code></pre></div></td></tr></table></figure><h4 id="创建PV"><a href="#创建PV" class="headerlink" title="创建PV"></a>创建PV</h4><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">`</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolume</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-pv</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">pv:</span> <span class="hljs-string">nfs-pv</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">capacity:</span><br>    <span class="hljs-attr">storage:</span> <span class="hljs-string">1Gi</span><br>  <span class="hljs-attr">accessModes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span><br>  <span class="hljs-attr">persistentVolumeReclaimPolicy:</span> <span class="hljs-string">Recycle</span><br>  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">nfs</span><br>  <span class="hljs-attr">nfs:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/nfs/data/pv</span><br>    <span class="hljs-attr">server:</span> <span class="hljs-number">10.7</span><span class="hljs-number">.150</span><span class="hljs-number">.112</span><br><span class="hljs-string">`</span><br></code></pre></div></td></tr></table></figure><hr><figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel">`配置说明`：<br>capacity 指定 <span class="hljs-built_in">PV</span> 的容量为 <span class="hljs-number">1</span>G。<br>accessModes 指定访问模式为 ReadWriteOnce，支持的访问模式有：<br>ReadWriteOnce – <span class="hljs-built_in">PV</span> 能以 read-write 模式 mount 到单个节点。<br>ReadOnlyMany – <span class="hljs-built_in">PV</span> 能以 read-only 模式 mount 到多个节点。<br>ReadWriteMany – <span class="hljs-built_in">PV</span> 能以 read-write 模式 mount 到多个节点。<br>persistentVolumeReclaimPolicy 指定当 <span class="hljs-built_in">PV</span> 的回收策略为 Recycle，支持的策略有：<br>Retain – 需要管理员手工回收。<br>Recycle – 清除 <span class="hljs-built_in">PV</span> 中的数据，效果相当于执行 rm -rf /thevolume/*。<br>Delete – 删除 Storage Provider 上的对应存储资源，例如 AWS EBS、GCE PD、Azure<br>Disk、OpenStack Cinder Volume 等。<br>storageClassName 指定 <span class="hljs-built_in">PV</span> 的 class 为 nfs。相当于为 <span class="hljs-built_in">PV</span> 设置了一个分类，PVC 可以指定 class 申请相应 class 的 <span class="hljs-built_in">PV</span>。<br>指定 <span class="hljs-built_in">PV</span> 在 NFS 服务器上对应的目录。<br></code></pre></div></td></tr></table></figure><p><img src="/img/newimg/006y8mN6gy1g8ctzzzc76j30wm03kaaq.jpg" srcset="/img/loading.gif" alt="create PV"></p><blockquote><p>STATUS 为 Available，表示 pv就绪，可以被 PVC 申请。</p></blockquote><h4 id="创建PVC"><a href="#创建PVC" class="headerlink" title="创建PVC"></a>创建PVC</h4><p>接下来创建一个名为pvc的PVC，配置文件 pvc.yaml</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-symbol">apiVersion:</span> v1<br><span class="hljs-symbol">kind:</span> PersistentVolumeClaim<br><span class="hljs-symbol">metadata:</span><br><span class="hljs-symbol">  name:</span> nfs-pvc<br><span class="hljs-symbol">spec:</span><br><span class="hljs-symbol">  accessModes:</span><br>    - ReadWriteOnce<br><span class="hljs-symbol">  resources:</span><br><span class="hljs-symbol">    requests:</span><br><span class="hljs-symbol">      storage:</span> <span class="hljs-number">1</span>Gi<br><span class="hljs-symbol">  storageClassName:</span> nfs<br><span class="hljs-symbol">  selector:</span><br><span class="hljs-symbol">    matchLabels:</span><br><span class="hljs-symbol">      pv:</span> nfs-pv<br></code></pre></div></td></tr></table></figure><p><img src="/img/newimg/006y8mN6gy1g8cu33t8lsj30xo06kmyk.jpg" srcset="/img/loading.gif" alt="Bound PVC"></p><blockquote><p>从 kubectl get pvc 和 kubectl get pv 的输出可以看到pvc绑定成功，注意pvc绑定到对应pv通过labels标签方式实现，也可以不指定，将随机绑定到pv。</p></blockquote><hr><p>接下来就可以在 Pod 中使用存储了，Pod 配置文件 pod.yaml</p><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-attribute">kind</span>: Pod<br><span class="hljs-attribute">apiVersion</span>: v1<br><span class="hljs-attribute">metadata</span>:<br>  <span class="hljs-attribute">name</span>: nfs-pod001<br><span class="hljs-attribute">spec</span>:<br>  <span class="hljs-attribute">containers</span>:<br>    - <span class="hljs-attribute">name</span>: myfrontend<br>      <span class="hljs-attribute">image</span>: nginx<br>      <span class="hljs-attribute">volumeMounts</span>:<br>      - <span class="hljs-attribute">mountPath</span>: <span class="hljs-string">"/var/www/html"</span><br>        <span class="hljs-attribute">name</span>: nfs-pv<br>  <span class="hljs-attribute">volumes</span>:<br>    - <span class="hljs-attribute">name</span>: nfs-pv<br>      <span class="hljs-attribute">persistentVolumeClaim</span>:<br>        <span class="hljs-attribute">claimName</span>: nfs-pvc<br></code></pre></div></td></tr></table></figure><blockquote><p>与使用普通 Volume 的格式类似，在 volumes 中通过 persistentVolumeClaim 指定使用nfs-pvc 申请的 Volume</p></blockquote><p><img src="/img/newimg/006y8mN6gy1g8cu7x6628j30go03tt97.jpg" srcset="/img/loading.gif" alt="create pod"></p><p>验证PV是否可用<br><img src="/img/newimg/006y8mN6gy1g8cu8qrjnpj30pg02yjrt.jpg" srcset="/img/loading.gif" alt="file"><br>进入pod查看情况<br><img src="/img/newimg/006y8mN6gy1g8cu9hb48qj30u0092abz.jpg" srcset="/img/loading.gif" alt="exec pod"></p><h4 id="删除pv"><a href="#删除pv" class="headerlink" title="删除pv"></a>删除pv</h4><p>删除pod，pv和pvc不会被删除，nfs存储的数据不会被删除。<br><img src="/img/newimg/006y8mN6gy1g8cub06m8qj30hd03iq3d.jpg" srcset="/img/loading.gif" alt="del pod "><br>继续删除pvc，pv将被释放，处于 Available 可用状态，并且nfs存储中的数据被删除。<br><img src="/img/newimg/006y8mN6gy1g8cucndzf7j30us05175e.jpg" srcset="/img/loading.gif" alt="del pvc "><br>继续删除pv<br><img src="/img/newimg/006y8mN6gy1g8cud8vkzpj30gf026dg2.jpg" srcset="/img/loading.gif" alt="del pv"></p>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s,nfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo换电脑怎么继续写作</title>
    <link href="/2019/10/25/hexo%E6%8D%A2%E7%94%B5%E8%84%91%E6%80%8E%E4%B9%88%E7%BB%A7%E7%BB%AD%E5%86%99%E4%BD%9C/"/>
    <url>/2019/10/25/hexo%E6%8D%A2%E7%94%B5%E8%84%91%E6%80%8E%E4%B9%88%E7%BB%A7%E7%BB%AD%E5%86%99%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>惭愧 – 博客写了俩月才想到这个话题，换电脑了咋继续写博客。</p><hr><h3 id="首先说说我写博客用的东西："><a href="#首先说说我写博客用的东西：" class="headerlink" title="首先说说我写博客用的东西："></a>首先说说我写博客用的东西：</h3><blockquote><ol><li>博客使用hexo，使用3-hexo主题</li><li>我把博客代码跟编译出来的静态页面分为两个仓库。写完以后分别提交。<br><img src="/img/newimg/006y8mN6gy1g8aut185bdj309d026dft.jpg" srcset="/img/loading.gif" alt="git仓库"></li></ol></blockquote><h3 id="正文来了"><a href="#正文来了" class="headerlink" title="正文来了"></a>正文来了</h3><blockquote><ol><li>走了的好多弯路，一开始博客的图片用的都是本地图片，第一是加载慢。并且换电脑以后 用hexo g &amp;&amp; hexo s  居然显示不了图片。</li><li>然后图片就换了图床—(这里推荐一个mac下的图床工具ipic,免费 好用)利用的是新浪的图床  也不知道能用多久。。打算自己用oss搭建一个图床<br><img src="/img/newimg/006y8mN6gy1g8avadnznpj306205z756.jpg" srcset="/img/loading.gif" alt="图床软件"></li></ol></blockquote><hr><h3 id="真的正文"><a href="#真的正文" class="headerlink" title="真的正文"></a>真的正文</h3><blockquote><ol><li>安装必要软件<br>git  nodejs  </li><li>github免密</li><li>拷贝之前的电脑的以下文件(git clone也行 但是一般比较慢)<br>_config.yml  package.json   scaffolds/    source/    themes/</li><li>在新的电脑上执行  npm install hexo-cli -g</li><li>进入新电脑中想放博客代码的目录，把步骤三中拷贝的文件放入其中</li><li>执行以下命令</li></ol></blockquote><hr><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span><br>npm <span class="hljs-keyword">install</span> hexo-deployer-git <span class="hljs-comment">--save  // 文章部署到 git 的模块</span><br>(下面为选择安装)<br>npm <span class="hljs-keyword">install</span> hexo-generator-feed <span class="hljs-comment">--save  // 建立 RSS 订阅</span><br>npm <span class="hljs-keyword">install</span> hexo-generator-sitemap <span class="hljs-comment">--save // 建立站点地图</span><br></code></pre></div></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>这时候使用 hexo s 基本可以看到你新添加的文章了。</p><figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c">部署发布文章<br>hexo clean   <span class="hljs-comment">// 清除缓存 网页正常情况下可以忽略此条命令</span><br>hexo g       <span class="hljs-comment">// 生成静态网页</span><br>hexo d       <span class="hljs-comment">// 开始部署</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运维神器tmux</title>
    <link href="/2019/10/24/%E8%BF%90%E7%BB%B4%E7%A5%9E%E5%99%A8tmux/"/>
    <url>/2019/10/24/%E8%BF%90%E7%BB%B4%E7%A5%9E%E5%99%A8tmux/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Tmux-是什么？"><a href="#一、Tmux-是什么？" class="headerlink" title="一、Tmux 是什么？"></a>一、Tmux 是什么？</h2><hr><h3 id="1-1-会话与进程"><a href="#1-1-会话与进程" class="headerlink" title="1.1 会话与进程"></a>1.1 会话与进程</h3><blockquote><p>命令行的典型使用方式是，打开一个终端窗口（terminal window，以下简称”窗口”），在里面输入命令。用户与计算机的这种临时的交互，称为一次”会话”（session） 。<br>会话的一个重要特点是，窗口与其中启动的进程是连在一起的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完。<br>一个典型的例子就是，SSH 登录远程计算机，打开一个远程窗口执行命令。这时，网络突然断线，再次登录的时候，是找不回上一次执行的命令的。因为上一次 SSH 会话已经终止了，里面的进程也随之消失了。<br>为了解决这个问题，会话与窗口可以”解绑”：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话”绑定”其他窗口。</p></blockquote><h2 id="1-2-Tmux-的作用"><a href="#1-2-Tmux-的作用" class="headerlink" title="1.2 Tmux 的作用"></a>1.2 Tmux 的作用</h2><blockquote><p>Tmux 就是会话与窗口的”解绑”工具，将它们彻底分离。</p><figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c">它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。<br>它可以让新窗口<span class="hljs-string">"接入"</span>已经存在的会话。<br>它允许每个会话有多个连接窗口，因此可以多人实时共享会话。<br>它还支持窗口任意的垂直和水平拆分。<br></code></pre></div></td></tr></table></figure><p>类似的终端复用器还有 GNU Screen。Tmux 与它功能相似，但是更易用，也更强大。</p></blockquote><p><img src="/img/newimg/006y8mN6gy1g8ax01tp5ej31zz0u07tv.jpg" srcset="/img/loading.gif" alt="tmux"></p><h2 id="二、基本用法"><a href="#二、基本用法" class="headerlink" title="二、基本用法"></a>二、基本用法</h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h3><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-comment"># Ubuntu 或 Debian</span><br>$ sudo apt-get <span class="hljs-keyword">install </span>tmux<br><br><span class="hljs-comment"># CentOS 或 Fedora</span><br>$ sudo yum <span class="hljs-keyword">install </span>tmux<br><br><span class="hljs-comment"># Mac</span><br>$ <span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>tmux<br></code></pre></div></td></tr></table></figure><h3 id="2-2-启动与退出"><a href="#2-2-启动与退出" class="headerlink" title="2.2 启动与退出"></a>2.2 启动与退出</h3><p>安装完成后，键入<code>tmux</code>命令，就进入了 Tmux 窗口。</p><figure class="highlight elixir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>tmux<br></code></pre></div></td></tr></table></figure><p>上面命令会启动 Tmux 窗口，底部有一个状态栏。状态栏的左侧是窗口信息（编号和名称），右侧是系统信息。<br><img src="/img/newimg/006y8mN6gy1g8axbkbbqgj30ke0dvt94.jpg" srcset="/img/loading.gif" alt="tmux run"><br>按下<code>Ctrl+d</code>或者显式输入<code>exit</code>命令，就可以退出 Tmux 窗口。</p><h3 id="2-3-前缀键"><a href="#2-3-前缀键" class="headerlink" title="2.3 前缀键"></a>2.3 前缀键</h3><p>Tmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是<code>Ctrl+b</code>，即先按下<code>Ctrl+b</code>，快捷键才会生效。<br>举例来说，帮助命令的快捷键是<code>Ctrl+b ?</code>。它的用法是，在 Tmux 窗口中，先按下<code>Ctrl+b</code>，再按下?，就会显示帮助信息。<br>然后，按下 ESC 键或<code>q</code>键，就可以退出帮助。</p><h2 id="三、会话管理"><a href="#三、会话管理" class="headerlink" title="三、会话管理"></a>三、会话管理</h2><h3 id="3-1-新建会话"><a href="#3-1-新建会话" class="headerlink" title="3.1 新建会话"></a>3.1 新建会话</h3><p>第一个启动的 Tmux 窗口，编号是0，第二个窗口的编号是1，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。<br>使用编号区分会话，不太直观，更好的方法是为会话起名。</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">$ tmux <span class="hljs-built_in">new</span> -s &lt;<span class="hljs-keyword">session</span>-<span class="hljs-type">name</span>&gt;<br></code></pre></div></td></tr></table></figure><p>上面命令新建一个指定名称的会话。</p><h3 id="3-2-分离会话"><a href="#3-2-分离会话" class="headerlink" title="3.2 分离会话"></a>3.2 分离会话</h3><p>在 Tmux 窗口中，按下<code>Ctrl+b d</code>或者输入<code>tmux detach</code>命令，就会将当前会话与窗口分离。</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino">$ tmux <span class="hljs-built_in">detach</span><br></code></pre></div></td></tr></table></figure><p>上面命令执行后，就会退出当前 Tmux 窗口，但是会话和里面的进程仍然在后台运行。<br><code>tmux ls</code>命令可以查看当前所有的 Tmux 会话。</p><figure class="highlight elixir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>tmux ls<br><span class="hljs-comment"># or</span><br><span class="hljs-variable">$ </span>tmux list-session<br></code></pre></div></td></tr></table></figure><h3 id="3-3-接入会话"><a href="#3-3-接入会话" class="headerlink" title="3.3 接入会话"></a>3.3 接入会话</h3><p><code>tmux attach</code>命令用于重新接入某个已存在的会话。</p><figure class="highlight elixir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elixir"><br><span class="hljs-comment"># 使用会话编号</span><br><span class="hljs-variable">$ </span>tmux attach -t 0<br><br><span class="hljs-comment"># 使用会话名称</span><br><span class="hljs-variable">$ </span>tmux attach -t &lt;session-name&gt;<br></code></pre></div></td></tr></table></figure><h3 id="3-4-杀死会话"><a href="#3-4-杀死会话" class="headerlink" title="3.4 杀死会话"></a>3.4 杀死会话</h3><p><code>tmux kill-session</code>命令用于杀死某个会话。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><br><span class="hljs-comment"># 使用会话编号</span><br>$ tmux <span class="hljs-keyword">kill</span>-<span class="hljs-keyword">session</span> -t <span class="hljs-number">0</span><br><br><span class="hljs-comment"># 使用会话名称</span><br>$ tmux <span class="hljs-keyword">kill</span>-<span class="hljs-keyword">session</span> -t &lt;<span class="hljs-keyword">session</span>-<span class="hljs-keyword">name</span>&gt;<br></code></pre></div></td></tr></table></figure><h3 id="3-5-切换会话"><a href="#3-5-切换会话" class="headerlink" title="3.5 切换会话"></a>3.5 切换会话</h3><p><code>tmux switch</code>命令用于切换会话。</p><figure class="highlight vala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vala"><br><span class="hljs-meta"># 使用会话编号</span><br>$ tmux <span class="hljs-keyword">switch</span> -t <span class="hljs-number">0</span><br><br><span class="hljs-meta"># 使用会话名称</span><br>$ tmux <span class="hljs-keyword">switch</span> -t &lt;session-name&gt;<br></code></pre></div></td></tr></table></figure><h3 id="3-6-重命名会话"><a href="#3-6-重命名会话" class="headerlink" title="3.6 重命名会话"></a>3.6 重命名会话</h3><p><code>tmux rename-session</code>命令用于重命名会话。</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">$ tmux <span class="hljs-keyword">rename</span>-<span class="hljs-keyword">session</span> -t <span class="hljs-number">0</span> &lt;<span class="hljs-built_in">new</span>-<span class="hljs-type">name</span>&gt;<br></code></pre></div></td></tr></table></figure><p>上面命令将0号会话重命名。</p><h3 id="3-7-会话快捷键"><a href="#3-7-会话快捷键" class="headerlink" title="3.7 会话快捷键"></a>3.7 会话快捷键</h3><p>下面是一些会话相关的快捷键。</p><figure class="highlight armasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">Ctrl</span>+<span class="hljs-keyword">b </span>d：分离当前会话。<br><span class="hljs-symbol">Ctrl</span>+<span class="hljs-keyword">b </span>s：列出所有会话。<br><span class="hljs-symbol">Ctrl</span>+<span class="hljs-keyword">b </span>$：重命名当前会话。<br></code></pre></div></td></tr></table></figure><h2 id="四、最简操作流程"><a href="#四、最简操作流程" class="headerlink" title="四、最简操作流程"></a>四、最简操作流程</h2><p>综上所述，以下是 Tmux 的最简操作流程。</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino">新建会话tmux <span class="hljs-keyword">new</span> -s my_session。<br>在 Tmux 窗口运行所需的程序。<br>按下快捷键Ctrl+b d将会话分离。<br>下次使用时，重新连接到会话tmux <span class="hljs-built_in">attach</span>-session -t my_session。<br></code></pre></div></td></tr></table></figure><h2 id="五、窗格操作"><a href="#五、窗格操作" class="headerlink" title="五、窗格操作"></a>五、窗格操作</h2><p>Tmux 可以将窗口分成多个窗格（pane），每个窗格运行不同的命令。以下命令都是在 Tmux 窗口中执行。</p><h3 id="5-1-划分窗格"><a href="#5-1-划分窗格" class="headerlink" title="5.1 划分窗格"></a>5.1 划分窗格</h3><p>tmux split-window命令用来划分窗格。</p><figure class="highlight coffeescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><br><span class="hljs-comment"># 划分上下两个窗格</span><br>$ tmux split-<span class="hljs-built_in">window</span><br><br><span class="hljs-comment"># 划分左右两个窗格</span><br>$ tmux split-<span class="hljs-built_in">window</span> -h<br></code></pre></div></td></tr></table></figure><p><img src="/img/newimg/006y8mN6gy1g8axhwysv1j30jc0bzq4q.jpg" srcset="/img/loading.gif" alt="tmux run1"></p><h3 id="5-2-移动光标"><a href="#5-2-移动光标" class="headerlink" title="5.2 移动光标"></a>5.2 移动光标</h3><p><code>tmux select-pane</code>命令用来移动光标位置。</p><figure class="highlight autoit"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs autoit"><span class="hljs-meta"># 光标切换到上方窗格</span><br>$ tmux <span class="hljs-keyword">select</span>-pane -U<br><br><span class="hljs-meta"># 光标切换到下方窗格</span><br>$ tmux <span class="hljs-keyword">select</span>-pane -D<br><br><span class="hljs-meta"># 光标切换到左边窗格</span><br>$ tmux <span class="hljs-keyword">select</span>-pane -L<br><br><span class="hljs-meta"># 光标切换到右边窗格</span><br>$ tmux <span class="hljs-keyword">select</span>-pane -R<br></code></pre></div></td></tr></table></figure><h3 id="5-3-交换窗格位置"><a href="#5-3-交换窗格位置" class="headerlink" title="5.3 交换窗格位置"></a>5.3 交换窗格位置</h3><p><code>tmux swap-pane</code>命令用来交换窗格位置。</p><figure class="highlight avrasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs avrasm"><span class="hljs-meta"># 当前窗格上移</span><br>$ tmux <span class="hljs-keyword">swap</span>-pane -U<br><br><span class="hljs-meta"># 当前窗格下移</span><br>$ tmux <span class="hljs-keyword">swap</span>-pane -D<br></code></pre></div></td></tr></table></figure><h3 id="5-4-窗格快捷键"><a href="#5-4-窗格快捷键" class="headerlink" title="5.4 窗格快捷键"></a>5.4 窗格快捷键</h3><p>下面是一些窗格操作的快捷键。</p><figure class="highlight dust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dust"><span class="xml">Ctrl+b %：划分左右两个窗格。</span><br><span class="xml">Ctrl+b "：划分上下两个窗格。</span><br><span class="xml">Ctrl+b <span class="hljs-tag">&lt;<span class="hljs-name">arrow</span> <span class="hljs-attr">key</span>&gt;</span>：光标切换到其他窗格。<span class="hljs-tag">&lt;<span class="hljs-name">arrow</span> <span class="hljs-attr">key</span>&gt;</span>是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键↓。</span><br><span class="xml">Ctrl+b ;：光标切换到上一个窗格。</span><br><span class="xml">Ctrl+b o：光标切换到下一个窗格。</span><br><span class="xml">Ctrl+b </span><span class="hljs-template-variable">&#123;：当前窗格左移。</span><br><span class="hljs-template-variable">Ctrl+b &#125;</span><span class="xml">：当前窗格右移。</span><br><span class="xml">Ctrl+b Ctrl+o：当前窗格上移。</span><br><span class="xml">Ctrl+b Alt+o：当前窗格下移。</span><br><span class="xml">Ctrl+b x：关闭当前窗格。</span><br><span class="xml">Ctrl+b !：将当前窗格拆分为一个独立窗口。</span><br><span class="xml">Ctrl+b z：当前窗格全屏显示，再使用一次会变回原来大小。</span><br><span class="xml">Ctrl+b Ctrl+<span class="hljs-tag">&lt;<span class="hljs-name">arrow</span> <span class="hljs-attr">key</span>&gt;</span>：按箭头方向调整窗格大小。</span><br><span class="xml">Ctrl+b q：显示窗格编号。</span><br></code></pre></div></td></tr></table></figure><h2 id="六、窗口管理"><a href="#六、窗口管理" class="headerlink" title="六、窗口管理"></a>六、窗口管理</h2><p>除了将一个窗口划分成多个窗格，Tmux 也允许新建多个窗口。</p><h3 id="6-1-新建窗口"><a href="#6-1-新建窗口" class="headerlink" title="6.1 新建窗口"></a>6.1 新建窗口</h3><p><code>tmux new-window</code>命令用来创建新窗口。</p><figure class="highlight smali"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs smali"><br>$ tmux new-window<br><br><span class="hljs-comment"># 新建一个指定名称的窗口</span><br>$ tmux<span class="hljs-built_in"> new-window </span>-n &lt;window-name&gt;<br></code></pre></div></td></tr></table></figure><h3 id="6-2-切换窗口"><a href="#6-2-切换窗口" class="headerlink" title="6.2 切换窗口"></a>6.2 切换窗口</h3><p><code>tmux select-window</code>命令用来切换窗口。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment"># 切换到指定编号的窗口</span><br>$ tmux <span class="hljs-keyword">select</span>-<span class="hljs-keyword">window</span> -t &lt;<span class="hljs-keyword">window</span>-<span class="hljs-built_in">number</span>&gt;<br><br><span class="hljs-comment"># 切换到指定名称的窗口</span><br>$ tmux <span class="hljs-keyword">select</span>-<span class="hljs-keyword">window</span> -t &lt;<span class="hljs-keyword">window</span>-<span class="hljs-keyword">name</span>&gt;<br></code></pre></div></td></tr></table></figure><h3 id="6-3-重命名窗口"><a href="#6-3-重命名窗口" class="headerlink" title="6.3 重命名窗口"></a>6.3 重命名窗口</h3><p><code>tmux rename-window</code>命令用于为当前窗口起名（或重命名）。</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">$ tmux <span class="hljs-keyword">rename</span>-<span class="hljs-keyword">window</span> &lt;<span class="hljs-built_in">new</span>-<span class="hljs-type">name</span>&gt;<br></code></pre></div></td></tr></table></figure><h3 id="6-4-窗口快捷键"><a href="#6-4-窗口快捷键" class="headerlink" title="6.4 窗口快捷键"></a>6.4 窗口快捷键</h3><p>下面是一些窗口操作的快捷键。</p><figure class="highlight armasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">Ctrl</span>+<span class="hljs-keyword">b </span>c：创建一个新窗口，状态栏会显示多个窗口的信息。<br><span class="hljs-symbol">Ctrl</span>+<span class="hljs-keyword">b </span>p：切换到上一个窗口（按照状态栏上的顺序）。<br><span class="hljs-symbol">Ctrl</span>+<span class="hljs-keyword">b </span>n：切换到下一个窗口。<br><span class="hljs-symbol">Ctrl</span>+<span class="hljs-keyword">b </span>&lt;number&gt;：切换到指定编号的窗口，其中的&lt;number&gt;是状态栏上的窗口编号。<br><span class="hljs-symbol">Ctrl</span>+<span class="hljs-keyword">b </span>w：从列表中选择窗口。<br><span class="hljs-symbol">Ctrl</span>+<span class="hljs-keyword">b </span>,：窗口重命名。<br></code></pre></div></td></tr></table></figure><h2 id="七、其他命令"><a href="#七、其他命令" class="headerlink" title="七、其他命令"></a>七、其他命令</h2><p>下面是一些其他命令。</p><figure class="highlight dsconfig"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dsconfig"><span class="hljs-comment"># 列出所有快捷键，及其对应的 Tmux 命令</span><br>$ <span class="hljs-string">tmux </span><span class="hljs-built_in">list-keys</span><br><span class="hljs-built_in"></span><br><span class="hljs-built_in">#</span> 列出所有 <span class="hljs-string">Tmux </span>命令及其参数<br>$ <span class="hljs-string">tmux </span><span class="hljs-built_in">list-commands</span><br><span class="hljs-built_in"></span><br><span class="hljs-built_in">#</span> 列出当前所有 <span class="hljs-string">Tmux </span>会话的信息<br>$ <span class="hljs-string">tmux </span><span class="hljs-string">info</span><br><span class="hljs-string"></span><br><span class="hljs-string">#</span> 重新加载当前的 <span class="hljs-string">Tmux </span>配置<br>$ <span class="hljs-string">tmux </span><span class="hljs-string">source-file </span>~/.<span class="hljs-string">tmux.</span><span class="hljs-string">conf</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>练习2年的git练习生</title>
    <link href="/2019/10/22/%E7%BB%83%E4%B9%A02%E5%B9%B4%E7%9A%84git%E7%BB%83%E4%B9%A0%E7%94%9F/"/>
    <url>/2019/10/22/%E7%BB%83%E4%B9%A02%E5%B9%B4%E7%9A%84git%E7%BB%83%E4%B9%A0%E7%94%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="分支操作："><a href="#分支操作：" class="headerlink" title="分支操作："></a>分支操作：</h2><blockquote><p>git branch 创建分支<br>git branch -b 创建并切换到新建的分支上<br>git checkout 切换分支<br>git branch 查看分支列表<br>git branch -v 查看所有分支的最后一次操作<br>git branch -vv 查看当前分支<br>git brabch -b 分支名 origin/分支名 创建远程分支到本地<br>git branch –merged 查看别的分支和当前分支合并过的分支<br>git branch –no-merged 查看未与当前分支合并的分支<br>git branch -d 分支名 删除本地分支<br>git branch -D 分支名 强行删除分支<br>git branch origin :分支名 删除远处仓库分支<br>git merge 分支名 合并分支到当前分支上</p></blockquote><h2 id="暂存操作："><a href="#暂存操作：" class="headerlink" title="暂存操作："></a>暂存操作：</h2><blockquote><p>git stash 暂存当前修改<br>git stash apply 恢复最近的一次暂存<br>git stash pop 恢复暂存并删除暂存记录<br>git stash list 查看暂存列表<br>git stash drop 暂存名(例：stash@{0}) 移除某次暂存<br>git stash clear 清除暂存</p></blockquote><h2 id="回退操作："><a href="#回退操作：" class="headerlink" title="回退操作："></a>回退操作：</h2><blockquote><p>git reset –hard HEAD^ 回退到上一个版本<br>git reset –hard ahdhs1(commit_id) 回退到某个版本<br>git checkout – file 撤销修改的文件(如果文件加入到了暂存区，则回退到暂存区的，如果文件加入到了版本库，则还原至加入版本库之后的状态)<br>git reset HEAD file 撤回暂存区的文件修改到工作区</p></blockquote><h2 id="标签操作："><a href="#标签操作：" class="headerlink" title="标签操作："></a>标签操作：</h2><blockquote><p>git tag 标签名 添加标签(默认对当前版本)<br>git tag 标签名 commit_id 对某一提交记录打标签<br>git tag -a 标签名 -m ‘描述’ 创建新标签并增加备注<br>git tag 列出所有标签列表<br>git show 标签名 查看标签信息<br>git tag -d 标签名 删除本地标签<br>git push origin 标签名 推送标签到远程仓库<br>git push origin –tags 推送所有标签到远程仓库<br>git push origin :refs/tags/标签名 从远程仓库中删除标签</p></blockquote><h2 id="常规操作："><a href="#常规操作：" class="headerlink" title="常规操作："></a>常规操作：</h2><blockquote><p>git push origin test 推送本地分支到远程仓库<br>git rm -r –cached 文件/文件夹名字 取消文件被版本控制<br>git reflog 获取执行过的命令<br>git log –graph 查看分支合并图<br>git merge –no-ff -m ‘合并描述’ 分支名 不使用 Fast forward 方式合并，采用这种方式合并可以看到合并记录<br>git check-ignore -v 文件名 查看忽略规则<br>git add -f 文件名 强制将文件提交</p></blockquote><h2 id="git-创建项目仓库："><a href="#git-创建项目仓库：" class="headerlink" title="git 创建项目仓库："></a>git 创建项目仓库：</h2><blockquote><p>git init 初始化<br>git remote add origin url 关联远程仓库<br>git pull<br>git fetch 获取远程仓库中所有的分支到本地<br>忽略已加入到版本库中的文件：<br>git update-index –assume-unchanged file 忽略单个文件<br>git rm -r –cached 文件/文件夹名字 (. 忽略全部文件)</p></blockquote><h2 id="取消忽略文件："><a href="#取消忽略文件：" class="headerlink" title="取消忽略文件："></a>取消忽略文件：</h2><blockquote><p>git update-index –no-assume-unchanged file</p></blockquote><h2 id="拉取、上传免密码："><a href="#拉取、上传免密码：" class="headerlink" title="拉取、上传免密码："></a>拉取、上传免密码：</h2><blockquote><p>git config –global credential.helper store</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动手实践podman</title>
    <link href="/2019/10/19/%E5%8A%A8%E6%89%8B%E5%AE%9E%E8%B7%B5podman/"/>
    <url>/2019/10/19/%E5%8A%A8%E6%89%8B%E5%AE%9E%E8%B7%B5podman/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>podman,docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ORI  or OCI ？</title>
    <link href="/2019/10/18/ORI-or-OCI-%EF%BC%9F/"/>
    <url>/2019/10/18/ORI-or-OCI-%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="在介绍-ORI-和-OCI-之前先介绍一些专有名词"><a href="#在介绍-ORI-和-OCI-之前先介绍一些专有名词" class="headerlink" title="在介绍 ORI 和 OCI 之前先介绍一些专有名词"></a>在介绍 ORI 和 OCI 之前先介绍一些专有名词</h3><ul><li>Runtime: 负责镜像管理以及 Pod 和容器的真正运行(例如 docker rkt))</li><li>Node: 每个节点都运行一个容器运行时，该运行时负责下载映像并运行容器。</li></ul><h3 id="当-Kubelet-想要创建一个容器的步骤"><a href="#当-Kubelet-想要创建一个容器的步骤" class="headerlink" title="当 Kubelet 想要创建一个容器的步骤"></a>当 Kubelet 想要创建一个容器的步骤</h3><blockquote><p>1.Kubelet 通过 CRI 接口(gRPC) 调用 dockershim, 请求创建一个容器. CRI 即容器运行时接口(Container Runtime Interface), 这一步中, Kubelet 可以视作一个简单的 CRI Client, 而 dockershim 就是接收请求的 Server. 目前 dockershim 的代码其实是内嵌在 Kubelet 中的, 所以接收调用的凑巧就是 Kubelet 进程;<br><br/><br>2.dockershim 收到请求后, 转化成 Docker Daemon 能听懂的请求, 发到 Docker Daemon 上请求创建一个容器;<br><br/><br>3.Docker Daemon 早在 1.12 版本中就已经将针对容器的操作移到另一个守护进程: containerd 中了, 因此 Docker Daemon 仍然不能帮我们创建容器, 而是要请求 containerd 创建一个容器;<br><br/><br>4.containerd 收到请求后, 并不会自己直接去操作容器, 而是创建一个叫做 containerd-shim 的进程, 让 containerd-shim 去操作容器. 这是因为容器进程需要一个父进程来做诸如收集状态, 维持 stdin 等 fd 打开等工作. 而假如这个父进程就是 containerd, 那每次 containerd 挂掉或升级, 整个宿主机上所有的容器都得退出了. 而引入了 containerd-shim 就规避了这个问题(containerd 和 shim 并不是父子进程关系);<br><br/> 5.我们知道创建容器需要做一些设置 namespaces 和 cgroups, 挂载 root filesystem 等等操作, 而这些事该怎么做已经有了公开的规范了, 那就是 OCI(Open Container Initiative, 开放容器标准). 它的一个参考实现叫做 runc. 于是, containerd-shim 在这一步需要调用 runc 这个命令行工具, 来启动容器;<br><br/><br>6.runc 启动完容器后本身会直接退出, containerd-shim 则会成为容器进程的父进程, 负责收集容器进程的状态, 上报给 containerd, 并在容器中 pid 为 1 的进程退出后接管容器中的子进程进行清理, 确保不会出现僵尸进程;<br><img src="/img/newimg/006y8mN6gy1g86s27c1gwj30u007lwex.jpg" srcset="/img/loading.gif" alt="kubelet执行过程"></p></blockquote><blockquote><p>这个过程乍一看像是在搞我们: Docker Daemon 和 dockershim 看上去就是两个不干活躺在中间划水的啊, Kubelet 为啥不直接调用 containerd 呢?</p></blockquote><blockquote><p>当然是可以的, 不过咱们先不提那个, 先看看为什么现在的架构如此繁冗.</p></blockquote><h3 id="容器历史小叙"><a href="#容器历史小叙" class="headerlink" title="容器历史小叙"></a>容器历史小叙</h3><blockquote><p>其实 k8s 最开始的 Runtime 架构远没这么复杂: kubelet 想要创建容器直接跟 Docker Daemon 说一声就行, 而那时也不存在 containerd, Docker Daemon 自己调一下 libcontainer 这个库把容器跑起来, 整个过程就搞完了.<br><br/><br>而熟悉容器和容器编排历史的读者老爷应该知道, 这之后就是容器圈的一系列政治斗争, 先是大佬们认为运行时标准不能被 Docker 一家公司控制, 于是就撺掇着搞了开放容器标准 OCI. Docker 则把 libcontainer 封装了一下, 变成 runC 捐献出来作为 OCI 的参考实现.<br><br/><br>再接下来就是 rkt 想从 docker 那边分一杯羹, 希望 k8s 原生支持 rkt 作为运行时, 而且 PR 还真的合进去了. 维护过一块业务同时接两个需求方的读者老爷应该都知道类似的事情有多坑, k8s 中负责维护 kubelet 的小组 sig-node 也是被狠狠坑了一把.<br><br/><br>大家一看这么搞可不行, 今天能有 rkt, 明天就能有更多幺蛾子出来, 这么搞下去我们小组也不用干活了, 整天搞兼容性的 bug 就够呛. 于是乎, k8s 1.5 推出了 CRI 机制, 即容器运行时接口(Container Runtime Interface), k8s 告诉大家, 你们想做 Runtime 可以啊, 我们也资瓷欢迎, 实现这个接口就成, 成功反客为主.<br><br/><br>不过 CRI 本身只是 k8s 推的一个标准, 当时的 k8s 尚未达到如今这般武林盟主的地位, 容器运行时当然不能说我跟 k8s 绑死了只提供 CRI 接口, 于是就有了 shim(垫片) 这个说法, 一个 shim 的职责就是作为 Adapter 将各种容器运行时本身的接口适配到 k8s 的 CRI 接口上.<br><br/><br>接下来就是 Docker 要搞 Swarm 进军 PaaS 市场, 于是做了个架构切分, 把容器操作都移动到一个单独的 Daemon 进程 containerd 中去, 让 Docker Daemon 专门负责上层的封装编排. 可惜 Swarm 在 k8s 面前实在是不够打, 惨败之后 Docker 公司就把 containerd 项目捐给 CNCF 缩回去安心搞 Docker 企业版了.<br><br/><br>最后就是我们在上一张图里看到的这一坨东西了, 尽管现在已经有 CRI-O, containerd-plugin 这样更精简轻量的 Runtime 架构, dockershim 这一套作为经受了最多生产环境考验的方案, 迄今为止仍是 k8s 默认的 runtime 实现.<br><br/><br>了解这些具体的架构有时能在 debug 时候帮我们一些忙, 但更重要的是它们能作为一个例子, 帮助我们更好地理解整个 k8s runtime 背后的设计逻辑, 我们这就言归正传.</p></blockquote><hr><h3 id="OCI-以及-CRI-是什么？"><a href="#OCI-以及-CRI-是什么？" class="headerlink" title="OCI 以及 CRI 是什么？"></a>OCI 以及 CRI 是什么？</h3><blockquote><p>OCI,也就是”开放容器标准”其实就是一坨文档, 其中主要规定了两点:</p><p>1.容器镜像要长啥样, 即 ImageSpec. 里面的大致规定就是你这个东西需要是一个压缩了的文件夹, 文件夹里以 xxx 结构放 xxx 文件;<br>容器要需要能接收哪些指令, 这些指令的行为是什么, 即 RuntimeSpec. 这里面的大致内容就是”容器”要能够执行 “create”, “start”, “stop”, “delete” 这些命令, 并且行为要规范.<br>是给容器运行时用的规范</p></blockquote><hr><blockquote><p>而 CRI 更简单, 单纯是一组 gRPC 接口, 扫一眼 kubelet/apis/cri/services.go 就能归纳出几套核心接口:</p><p>一套针对容器操作的接口, 包括创建,启停容器等等;<br>一套针对镜像操作的接口, 包括拉取镜像删除镜像等;<br>还有一套针对 PodSandbox (容器沙箱环境) 的操作接口;<br>是给 kubelet 用的兼容层接口</p></blockquote><h3 id="containerd-中的-ori-以及-oci-的应用"><a href="#containerd-中的-ori-以及-oci-的应用" class="headerlink" title="containerd 中的 ori 以及 oci 的应用"></a>containerd 中的 ori 以及 oci 的应用</h3><blockquote><p>containerd 1.0 中, 对 CRI 的适配通过一个单独的进程 CRI-containerd 来完成:<br><img src="/img/newimg/006y8mN6gy1g86skx5fp0j30u007o0t2.jpg" srcset="/img/loading.gif" alt="containerd 1.0"> <br/><br>containerd 1.1 中做的又更漂亮一点, 砍掉了 CRI-containerd 这个进程, 直接把适配逻辑作为插件放进了 containerd 主进程中:<br><img src="/img/newimg/006y8mN6gy1g86snalj4jj30u008dmxl.jpg" srcset="/img/loading.gif" alt="containerd 1.1"> <br/><br>但在 containerd 做这些事情之情, 社区就已经有了一个更为专注的 cri-runtime: CRI-O, 它非常纯粹, 就是兼容 CRI 和 OCI, 做一个 k8s 专用的运行时:<br><img src="/img/newimg/006y8mN6gy1g86snysq8uj30u008daag.jpg" srcset="/img/loading.gif" alt="cri-runtime: CRI-O"> <code>注 : podman 就是基于 OCI-O 开发</code></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>是时候替换你的docker了</title>
    <link href="/2019/10/14/%E6%98%AF%E6%97%B6%E5%80%99%E6%9B%BF%E6%8D%A2%E4%BD%A0%E7%9A%84docker%E4%BA%86/"/>
    <url>/2019/10/14/%E6%98%AF%E6%97%B6%E5%80%99%E6%9B%BF%E6%8D%A2%E4%BD%A0%E7%9A%84docker%E4%BA%86/</url>
    
    <content type="html"><![CDATA[<h2 id="罪恶的-docker"><a href="#罪恶的-docker" class="headerlink" title="罪恶的 docker"></a>罪恶的 docker</h2><p>还记得之前写过一篇关于<a href="http://www.jxhs.me/2019/07/28/docker%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8%E5%90%8Eagetty%E8%BF%9B%E7%A8%8Bcpu%E5%8D%A0%E7%94%A8%E7%8E%87100/">docker 启动时候宿主机 CPU 使用百分百的问题</a></p><h3 id="使用-docker-的时候常见疑问点"><a href="#使用-docker-的时候常见疑问点" class="headerlink" title="使用 docker 的时候常见疑问点"></a>使用 docker 的时候常见疑问点</h3><blockquote><p>单个过程可能是单个故障点。<br>该进程拥有所有子进程（正在运行的容器）。<br>如果发生故障，则存在孤儿容器。<br>构建容器导致安全漏洞。<br>所有 Docker 操作都必须由具有相同完全根权限的一个或多个用户执行。</p></blockquote><blockquote><p><img src="/img/newimg/006y8mN6gy1g864qjrpbdj30lk0ggt9a.jpg" srcset="/img/loading.gif" alt="docker架构"></p></blockquote><h3 id="常见尴尬场景："><a href="#常见尴尬场景：" class="headerlink" title="常见尴尬场景："></a>常见尴尬场景：</h3><blockquote><p>由于之前对 docker 的理解不深，所以上手就直接用了。慢慢发现有一些配置文件或者其他的需要更改的时候，必须先删除所有容器，然后重启守护程序……………..(那这样意义何在？)</p></blockquote><h3 id="衍生出来几个问题"><a href="#衍生出来几个问题" class="headerlink" title="衍生出来几个问题"></a>衍生出来几个问题</h3><blockquote><p>Docker 干嘛要配一个守护程序？<br>虽然我们把业务解耦到不同的容器中，但是由于这么多的容器底层都是同一个父进程–Docker-daemon,这相当于把鸡蛋分开到不同的篮子里，但是所有的篮子都在同一辆车上。</p></blockquote><h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><blockquote><p>Docker 是一个以 root 身份在你的系统上运行的守护程序，它利用 Linux 内核的功能来管理正在运行的容器。除了运行容器之外，它还可以轻松管理容器镜像 —— 与容器注册库交互、存储映像、管理容器版本等。它基本上支持运行单个容器所需的所有操作。</p><p>但即使 Docker 是管理 Linux 容器的一个非常方便的工具，它也有两个缺点：它是一个需要在你的系统上运行的守护进程，并且需要以 root 权限运行，这可能有一定的安全隐患。然而，Podman 在解决这两个问题。</p></blockquote><hr><h2 id="下面来介绍一下-podman"><a href="#下面来介绍一下-podman" class="headerlink" title="下面来介绍一下 podman"></a><center>下面来介绍一下 podman</center></h2><blockquote><p><img src="/img/newimg/006y8mN6gy1g864ql1251j30yv0afgne.jpg" srcset="/img/loading.gif" alt="podman logo"><br>Podman 是一个容器运行时环境，提供与 Docker 非常相似的功能。正如已经提示的那样，它不需要在你的系统上运行任何守护进程，并且它也可以在没有 root 权限的情况下运行。让我们看看使用 Podman 运行 Linux 容器的一些示例。<br><img src="/img/newimg/006y8mN6gy1g864qm0bjqj30fq0iaaao.jpg" srcset="/img/loading.gif" alt="podman run"><br>你会发现启动一个容器 并不需要先启动 docker 了。甚至没有 podman 的进程。使得容器就是容器 轻量级了很多。</p></blockquote><blockquote><p><img src="/img/newimg/006y8mN6gy1g864qo6razj31wq0e8gt1.jpg" srcset="/img/loading.gif" alt="podman架构"></p></blockquote><h2 id="课外讲讲发展史"><a href="#课外讲讲发展史" class="headerlink" title="课外讲讲发展史"></a>课外讲讲发展史</h2><h3 id="为什-docker-做的那么早，但是这么不尽人意呢？"><a href="#为什-docker-做的那么早，但是这么不尽人意呢？" class="headerlink" title="为什 docker 做的那么早，但是这么不尽人意呢？"></a>为什 docker 做的那么早，但是这么不尽人意呢？</h3><blockquote><p>一、缘起<br>1.1、鸿蒙<br>在上古时期，天地初开，一群称之为 “运维” 的人们每天在一种叫作 “服务器” 的神秘盒子中创造属于他们的世界；他们在这个世界中每日劳作，一遍又一遍的写入他们的历史，比如搭建一个 nginx、布署一个 java web 应用…</p><p>大多数人其实并没有那么聪明，他们所 “创造” 的事实上可能是有人已经创造过的东西，他们可能每天都在做着重复的劳动；久而久之，一些人厌倦了、疲惫了…又过了一段时间，一些功力深厚的老前辈创造了一些批量布署工具来帮助人们做一些重复性的劳动，这些工具被起名为 “Asible”、”Chef”、”Puppet” 等等…</p><p>而随着时代的发展，”世界” 变得越来越复杂，运维们需要处理的事情越来越多，比如各种网络、磁盘环境的隔离，各种应用服务的高可用…在时代的洪流下，运维们急需要一种简单高效的布署工具，既能有一定的隔离性，又能方便使用，并且最大程度降低重复劳动来提升效率。</p><p>1.2、创世<br>在时代洪流的冲击下，一位名为 “Solomon Hykes” 的人异军突起，他创造了一个称之为 Docker 的工具，Docker 被创造以后就以灭世之威向运维们展示了它的强大；一个战斗力只有 5 的运维只需要学习 Docker 很短时间就可以完成资深运维们才能完成的事情，在某些情况下以前需要 1 天才能完成的工作使用 Docker 后几分钟就可以完成；此时运维们已经意识到 “新的时代” 开启了，接下来 Docker 开源并被整个运维界人们使用，Docker 也不断地完善增加各种各样的功能，此后世界正式进入 “容器纪元”。</p></blockquote><hr><blockquote><p>二、纷争<br>2.1、发展<br>随着 Docker 的日益成熟，一些人开始在 Docker 之上创造更加强大的工具，一些人开始在 Docker 之下为其提供更稳定的运行环境…</p><p>其中一个叫作 Google 的公司在 Docker 之上创建了名为 “Kuberentes” 的工具，Kubernetes 操纵 Docker 完成更加复杂的任务；Kubernetes 的出现更加印证了 Docker 的强大，以及 “容器纪元” 的发展正确性。</p><p>2.2、野心<br>当然这是一个充满利益的世界，Google 公司创造 Kubernetes 是可以为他们带来利益的，比如他们可以让 Kubernetes 深度适配他们的云平台，以此来增加云平台的销量等；此时 Docker 创始人也成立了一个公司，提供 Docker 的付费服务以及深度定制等；不过值得一提的是 Docker 公司提供的付费服务始终没有 Kubernetes 为 Google 公司带来的利益高，所以在利益的驱使下，Docker 公司开始动起了歪心思: 创造一个 Kubernetes 的替代品，利用用户粘度复制 Kubernetes 的成功，从 Google 嘴里抢下这块蛋糕！此时 Docker 公司只想把蛋糕抢过来，但是他们根本没有在意到暗中一群人创造了一个叫 “rkt” 的东西也在妄图夺走他们嘴里的蛋糕。</p><p>2.3、冲突<br>在一段时间的沉默后，Docker 公司又创造了 “Swarm” 这个工具，妄图夺走 Google 公司利用 Kubernetes 赢来的蛋糕；当然，Google 这个公司极其庞大，人数众多，而且在这个社会有很大的影响地位…</p><p>终于，巨人苏醒了，Google 联合了 Redhat、Microsoft、IBM、Intel、Cisco 等公司决定对这个爱动歪脑筋的 Docker 公司进行制裁；当然制裁的手段不能过于暴力，那样会让别人落下把柄，成为别人的笑料，被人所不耻；最总他们决定制订规范，成立组织，明确规定 Docker 的角色，以及它应当拥有的能力，这些规范包括但不限于 CRI、CNI 等；自此之后各大公司宣布他们容器相关的工具只兼容 CRI 等相关标准，无论是 Docker 还是 rkt 等工具，只要实现了这些标准，就可以配合这些容器工具进行使用。</p></blockquote><hr><blockquote><p>三、成败<br>自此之后，Docker 跌下神坛，各路大神纷纷创造满足 CRI 等规范的工具用来取代 Docker，Docker 丢失了往日一家独大的场面，最终为了顺应时代发展，拆分自己成为模块化组件；这些模块化组件被放置在 mobyproject 中方便其他人重复利用。</p><p>时至今日，虽然 Docker 已经不负以前，但是仍然是容器化首选工具，因为 Docker 是一个完整的产品，它可以提供除了满足 CRI 等标准以外更加方便的功能；但是制裁并非没有结果，Google 公司借此创造了 cri-o 用来满足 CRI 标准，其他公司也相应创建了对应的 CRI 实现；为了进一步分化 Docker 势力，一个叫作 Podman 的工具被创建，它以 cri-o 为基础，兼容大部份 Docker 命令的方式开始抢夺 Dcoker 用户；到目前为止 Podman 已经可以在大部份功能上替代 Docker。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9月有感</title>
    <link href="/2019/09/12/9%E6%9C%88%E6%9C%89%E6%84%9F/"/>
    <url>/2019/09/12/9%E6%9C%88%E6%9C%89%E6%84%9F/</url>
    
    <content type="html"><![CDATA[<p>好快，2019年都到9月份了。<br>其实今年啥都没干，一点东西都没学，但是算是走出了一大步.</p><p>不幸的是爷爷9月10号去世了<br>我听到这个消息，居然内心没啥波澜…….<br>有时候对自己不可思议的冷静感觉到害怕<br>因为身患绝症，还有一些器官衰竭和腰间盘突出，看到爷爷难受的样子 我倒是觉得是解脱了<br>爷爷说 疼的一直不想活了 但是舍不得一家人<br>不知道奶奶后续在哪儿住，几个儿子都愿意接过去 但是奶奶说要陪着爷爷</p><p>生活还要前进 昨天看到祭司摸着小孩子的脸笑了笑 像看到了一个希望的种子。<br>接下来的日子里要加油了  好好生活 抓紧学习 把今年的补起来。</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu桌面版优化</title>
    <link href="/2019/08/11/Ubuntu%E6%A1%8C%E9%9D%A2%E7%89%88%E4%BC%98%E5%8C%96/"/>
    <url>/2019/08/11/Ubuntu%E6%A1%8C%E9%9D%A2%E7%89%88%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>完全转入 Ubuntu 也有一段时间了, 像我这种有着些微强迫症的人, 接触到新事物必定是先要优化 + 美化一番. 毕竟, 工具玩的顺手, 工作才更有激情.</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>ubuntu优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac brew 特别慢 解决方案 </title>
    <link href="/2019/08/09/Mac-brew-%E7%89%B9%E5%88%AB%E6%85%A2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2019/08/09/Mac-brew-%E7%89%B9%E5%88%AB%E6%85%A2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>更新一下,下面的方法都过时了。</p><p>直接一条命令耍完整个安装加换源。</p><ol><li>执行命令：</li></ol><p>/bin/zsh -c “$(curl -fsSL <a href="https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;" target="_blank" rel="noopener">https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</a></p><ol start="2"><li>输入编号选择下载源</li></ol><p><img src="/img/newimg/0081Kckwgy1glxqervyuxj30xx0e5gvz.jpg" srcset="/img/loading.gif" alt=""></p><p>众所周知，brew是mac下最好的下载软件工具，类似与yum、apt有过之而不及。(如果没听过，请关闭该网页)</p><p>接下来解决特别慢的问题。<br>1.按照常规安装安装好brew</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/ruby -e "$(curl -fsSL https:/</span><span class="hljs-regexp">/raw.githubusercontent.com/</span>Homebrew<span class="hljs-regexp">/install/m</span>aster<span class="hljs-regexp">/install)"</span><br></code></pre></div></td></tr></table></figure><p>2.替换brew.git:</p><figure class="highlight dsconfig"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dsconfig"><span class="hljs-string">cd </span><span class="hljs-string">"$(brew --repo)"</span><br><span class="hljs-string">git </span><span class="hljs-string">remote </span><span class="hljs-built_in">set-url</span> <span class="hljs-string">origin </span><span class="hljs-string">https:</span>//<span class="hljs-string">mirrors.</span><span class="hljs-string">ustc.</span><span class="hljs-string">edu.</span><span class="hljs-string">cn/</span><span class="hljs-string">brew.</span><span class="hljs-string">git</span><br></code></pre></div></td></tr></table></figure><p>3.替换homebrew-core.git:</p><figure class="highlight dsconfig"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dsconfig"><span class="hljs-string">cd </span><span class="hljs-string">"$(brew --repo)/Library/Taps/homebrew/homebrew-core"</span><br><span class="hljs-string">git </span><span class="hljs-string">remote </span><span class="hljs-built_in">set-url</span> <span class="hljs-string">origin </span><span class="hljs-string">https:</span>//<span class="hljs-string">mirrors.</span><span class="hljs-string">ustc.</span><span class="hljs-string">edu.</span><span class="hljs-string">cn/</span><span class="hljs-string">homebrew-core.</span><span class="hljs-string">git</span><br></code></pre></div></td></tr></table></figure><p>4.什么?你连安装第一步都卡?请关闭该网页！<br>5.开个玩笑,第一步执行卡可以换源下载brew</p><ul><li><p>获取 install 文件</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">curl -fsSL https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/Homebrew/i</span>nstall<span class="hljs-regexp">/master/i</span>nstall &gt;&gt; brew_install<br></code></pre></div></td></tr></table></figure><p>如果这个你访问不了,连手机热点 然后加hosts。稳稳的</p></li><li><p>更改脚本中的资源链接<br>换成清华大学的镜像，修改如下两句.</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">BREW_REPO = “https://github.com/Homebrew/brew“.<span class="hljs-keyword">freeze</span> <br>CORE_TAP_REPO = “https://github.com/Homebrew/homebrew-core“.<span class="hljs-keyword">freeze</span><br></code></pre></div></td></tr></table></figure><p>更改为这两句(或者你找的其他家的)</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">BREW_REPO = "https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git".<span class="hljs-keyword">freeze</span> <br>CORE_TAP_REPO = "https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git".<span class="hljs-keyword">freeze</span><br></code></pre></div></td></tr></table></figure></li><li><p>运行脚本</p><figure class="highlight armasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs armasm">/usr/<span class="hljs-keyword">bin/ruby </span><span class="hljs-keyword">brew_install</span><br></code></pre></div></td></tr></table></figure></li><li><p>可以愉快玩耍了</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx瑞士军刀-lua</title>
    <link href="/2019/08/06/nginx%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80-lua/"/>
    <url>/2019/08/06/nginx%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80-lua/</url>
    
    <content type="html"><![CDATA[<p>tets</p>]]></content>
    
    
    <categories>
      
      <category>nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈dockerd、contaierd、containerd-shim、runC之间的关系</title>
    <link href="/2019/08/05/%E6%B5%85%E8%B0%88dockerd%E3%80%81contaierd%E3%80%81containerd-shim%E3%80%81runC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <url>/2019/08/05/%E6%B5%85%E8%B0%88dockerd%E3%80%81contaierd%E3%80%81containerd-shim%E3%80%81runC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<p>“少啰嗦，先看东西”<br><img src="/img/newimg/006y8mN6gy1g864obry93j318c0ieaet.jpg" srcset="/img/loading.gif" alt="docker内部架构图"></p><h2 id="组件大纲"><a href="#组件大纲" class="headerlink" title="组件大纲"></a>组件大纲</h2><blockquote><p>1.docker<br>2.dockerd<br>3.containerd<br>4.containerd-shim<br>5.runC</p></blockquote><h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><blockquote><p>docker 的命令行工具，是给用户和 docker daemon 建立通信的客户端。</p></blockquote><h3 id="dockerd"><a href="#dockerd" class="headerlink" title="dockerd"></a>dockerd</h3><blockquote><p>dockerd 是 docker 架构中一个常驻在后台的系统进程，称为 docker daemon，dockerd 实际调用的还是 containerd 的 api 接口（rpc 方式实现）,docker daemon 的作用主要有以下两方面：</p><p>接收并处理 docker client 发送的请求<br>管理所有的 docker 容器</p><p>有了 containerd 之后，dockerd 可以独立升级，以此避免之前 dockerd 升级会导致所有容器不可用的问题。</p></blockquote><h3 id="containerd"><a href="#containerd" class="headerlink" title="containerd"></a>containerd</h3><blockquote><p>containerd 是 dockerd 和 runc 之间的一个中间交流组件，docker 对容器的管理和操作基本都是通过 containerd 完成的。containerd 的主要功能有：</p><p>容器生命周期管理<br>日志管理<br>镜像管理<br>存储管理<br>容器网络接口及网络管理</p></blockquote><h3 id="containerd-shim"><a href="#containerd-shim" class="headerlink" title="containerd-shim"></a>containerd-shim</h3><blockquote><p>containerd-shim 是一个真实运行容器的载体，每启动一个容器都会起一个新的 containerd-shim 的一个进程， 它直接通过指定的三个参数：容器 id，boundle 目录（containerd 对应某个容器生成的目录，一般位于：/var/run/docker/libcontainerd/containerID，其中包括了容器配置和标准输入、标准输出、标准错误三个管道文件），运行时二进制（默认为 runC）来调用 runc 的 api 创建一个容器，上面的 docker 进程图中可以直观的显示。其主要作用是：</p><p>它允许容器运行时(即 runC)在启动容器之后退出，简单说就是不必为每个容器一直运行一个容器运行时(runC)<br>即使在 containerd 和 dockerd 都挂掉的情况下，容器的标准 IO 和其它的文件描述符也都是可用的<br>向 containerd 报告容器的退出状态</p><p>有了它就可以在不中断容器运行的情况下升级或重启 dockerd，对于生产环境来说意义重大。<br>运行是二进制（默认为 runc）来调用 runc 的 api 创建一个容器（比如创建容器：最后拼装的命令如下：runc create 。。。。。）</p></blockquote><h3 id="runC"><a href="#runC" class="headerlink" title="runC"></a>runC</h3><blockquote><p>简单的说，runC 是一个命令行工具，用来运行按照 OCI 标准格式打包过的应用</p></blockquote><p>启动一个容器的过程如下：</p><blockquote><p>用户在命令行执行 <code>docker run -itd busybox</code> 由 docker client 通过 grpc 将指令传给 dockerd<br>docker daemon 请检查本机是否存在 docker 镜像文件，如果有继续往下执行<br>dockerd 会向 host os 请求创建容器<br>linux 会创建一个空的容器(cgroup namespace),并启动 containerd-shim 进程。<br>containerd-shim 拿到三个参数(容器 id，boundle 目录，运行时二进制文件 runc )来调用 runC 的 api<br>runC 提取镜像文件，生成容器配置文件，然后启动容器</p></blockquote><h3 id="最后插一张-docker-内部通信图"><a href="#最后插一张-docker-内部通信图" class="headerlink" title="最后插一张 docker 内部通信图"></a>最后插一张 docker 内部通信图</h3><blockquote><p><img src="/img/newimg/006y8mN6gy1g864od01lxj31560l2tbe.jpg" srcset="/img/loading.gif" alt="docker内部通信"></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kvm 虚拟机修改ip地址</title>
    <link href="/2019/07/31/kvm-%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BF%AE%E6%94%B9ip%E5%9C%B0%E5%9D%80/"/>
    <url>/2019/07/31/kvm-%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BF%AE%E6%94%B9ip%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<h2 id="KVM-虚拟化之-libguestfs-tools-工具常用命令介绍"><a href="#KVM-虚拟化之-libguestfs-tools-工具常用命令介绍" class="headerlink" title="KVM 虚拟化之 libguestfs-tools 工具常用命令介绍"></a>KVM 虚拟化之 libguestfs-tools 工具常用命令介绍</h2><blockquote><p>背景:由于 kvm 虚拟机没有图形化界面，导致模版克隆的虚拟机更改 ip 很不方便。需要一台台手动登陆去修改，而 libguestfs-tools 工具能做到给克隆出来的虚拟机更改 ip，写成脚本后非常方便使用。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">yum -y <span class="hljs-keyword">install</span> libguestfs-tools<br></code></pre></div></td></tr></table></figure></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote><p>libguestfs-tools 工具的部分命令使用方便，但是执行速度不是很快，下面只对一些常用命令进行介绍<br><img src="/img/newimg/006y8mN6gy1g864vcr9hlj31nw0aijyl.jpg" srcset="/img/loading.gif" alt="libguestfs-tools工具命令"><br>1.virt-df<br>介绍：类似于虚拟机本地“df”命令<br><img src="/img/newimg/006y8mN6gy1g8652z1kfsj31as05w0wp.jpg" srcset="/img/loading.gif" alt="virt-df"><br>2.virt-cat<br>介绍：类似于虚拟机本地“cat”命令<br><img src="/img/newimg/006y8mN6gy1g86537buvij31c604k0wa.jpg" srcset="/img/loading.gif" alt="virt-cat"><br>3.virt-edit<br>介绍：类似于虚拟机本地”vi”命令，使用这个命令需要关闭虚拟机<br><img src="/img/newimg/006y8mN6gy1g8653sy7d0j31b609waht.jpg" srcset="/img/loading.gif" alt="virt-edit"><br>4.virt-ls<br>介绍：类似于虚拟机本地”ls”命令<br><img src="/img/newimg/006y8mN6gy1g8653zq34qj30su0ac0vz.jpg" srcset="/img/loading.gif" alt="virt-ls"><br>5.virt-copy-out<br>介绍：复制虚拟机文件到宿主机本地磁盘，类似于本地”cp”命令<br><img src="/img/newimg/006y8mN6gy1g86547qc0qj313s04sgoa.jpg" srcset="/img/loading.gif" alt="virt-copy-out"><br>6.virt-copy-in<br>介绍：复制宿主机本地文件到虚拟机磁盘，类似于本地”cp”命令<br><img src="/img/newimg/006y8mN6gy1g8654erb43j314s08879p.jpg" srcset="/img/loading.gif" alt="virt-copy-in"></p></blockquote><h3 id="注意-virt-copy-in-以及-virt-edit-命令-需要关闭虚拟机才能执行"><a href="#注意-virt-copy-in-以及-virt-edit-命令-需要关闭虚拟机才能执行" class="headerlink" title="注意 virt-copy-in 以及 virt-edit 命令 需要关闭虚拟机才能执行"></a>注意 virt-copy-in 以及 virt-edit 命令 需要关闭虚拟机才能执行</h3><blockquote><p><img src="/img/newimg/006y8mN6gy1g8654nhqrwj31b607m45b.jpg" srcset="/img/loading.gif" alt="error"></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>虚拟化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5 分钟带你搞定 Redis 复制</title>
    <link href="/2019/07/30/5-%E5%88%86%E9%92%9F%E5%B8%A6%E4%BD%A0%E6%90%9E%E5%AE%9A-Redis-%E5%A4%8D%E5%88%B6/"/>
    <url>/2019/07/30/5-%E5%88%86%E9%92%9F%E5%B8%A6%E4%BD%A0%E6%90%9E%E5%AE%9A-Redis-%E5%A4%8D%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="本文大纲"><a href="#本文大纲" class="headerlink" title="本文大纲"></a>本文大纲</h2><p>1.复制过程</p><p>2.数据间的同步</p><p>3.全量复制</p><p>4.部分复制</p><p>5.心跳</p><p>6.异步复制</p><p>7.总结</p><h3 id="一、复制过程"><a href="#一、复制过程" class="headerlink" title="一、复制过程"></a>一、复制过程</h3><blockquote><p>Step 1：从节点执行 slaveof 命令。<br>Step 2：从节点只是保存了 slaveof 命令中主节点的信息，并没有立即发起复制。<br>Step 3：从节点内部的定时任务发现有主节点的信息，开始使用 socket 连接主节点。<br>Step 4：连接建立成功后，发送 ping 命令，希望得到 pong 命令响应，否则会进行重连。<br>Step 5：如果主节点设置了权限，那么就需要进行权限验证，如果验证失败，复制终止。<br>Step 6：权限验证通过后，进行数据同步，这是耗时最长的操作，主节点将把所有的数据全部发送给从节点。<br>Step 7：当主节点把当前的数据同步给从节点后，便完成了复制的建立流程。接下来，主节点就会持续的把写命令发送给从节点，保证主从数据一致性。<br><img src="/img/newimg/006y8mN6gy1g863xvzz0uj30ti0t0k3c.jpg" srcset="/img/loading.gif" alt="复制过程"></p></blockquote><h3 id="二、数据间的同步"><a href="#二、数据间的同步" class="headerlink" title="二、数据间的同步"></a>二、数据间的同步</h3><p>上面说的复制过程，其中有一个步骤是“同步数据集”，这个就是现在讲的“数据间的同步”。<br>redis 同步有 2 个命令：sync 和 psync，前者是 redis 2.8 之前的同步命令，后者是 redis 2.8 为了优化 sync 新设计的命令。我们会重点关注 2.8 的 psync 命令。</p><blockquote><p>1、psync 命令需要 3 个组件支持<br>主从节点各自复制偏移量<br>主节点复制积压缓冲区<br>主节点运行 ID<br>2、主从节点各自复制偏移量<br>参与复制的主从节点都会维护自身的复制偏移量。<br>主节点在处理完写入命令后，会把命令的字节长度做累加记录，统计信息在 info replication 中的 masterreploffset 指标中。<br>从节点每秒钟上报自身的的复制偏移量给主节点，因此主节点也会保存从节点的复制偏移量。<br>从节点在接收到主节点发送的命令后，也会累加自身的偏移量，统计信息在 info replication 中。<br>通过对比主从节点的复制偏移量，可以判断主从节点数据是否一致。<br>3、主节点复制积压缓冲区<br>复制积压缓冲区是一个保存在主节点的一个固定长度的先进先出的队列，默认大小 1MB。<br>这个队列在 slave 连接是创建。这时主节点响应写命令时，不但会把命令发送给从节点，也会写入复制缓冲区。<br>他的作用就是用于部分复制和复制命令丢失的数据补救。通过 info replication 可以看到相关信息。<br>4、主节点运行 ID<br>每个 redis 启动的时候，都会生成一个 40 位的运行 ID。<br>运行 ID 的主要作用是用来识别 Redis 节点。如果使用 ip+port 的方式，那么如果主节点重启修改了 RDB/AOF 数据，从节点再基于偏移量进行复制将是不安全的。所以，当运行 id 变化后，从节点将进行全量复制。也就是说，redis 重启后，默认从节点会进行全量复制。<br>5、如果在重启时不改变运行 ID 呢？<br>可以通过 debug reload 命令重新加载 RDB 并保持运行 ID 不变，从而有效的避免不必要的全量复制。<br>缺点是：debug reload 命令会阻塞当前 Redis 节点主线程，因此对于大数据量的主节点或者无法容忍阻塞的节点，需要谨慎使用。一般通过故障转移机制可以解决这个问题。<br>6、psync 命令的使用方式<br>命令格式为 psync{runId}{offset}<br>runId：从节点所复制主节点的运行 id<br>offset：当前从节点已复制的数据偏移量<br>7、psync 执行流程<br><img src="/img/newimg/006y8mN6gy1g864g77205j30o60gugqa.jpg" srcset="/img/loading.gif" alt="数据同步"></p></blockquote><h3 id="流程说明："><a href="#流程说明：" class="headerlink" title="流程说明："></a>流程说明：</h3><blockquote><p>从节点发送 psync 命令给主节点，runId 就是目标主节点的 ID，如果没有默认为 -1，offset 是从节点保存的复制偏移量，如果是第一次复制则为 -1.主节点会根据 runid 和 offset 决定返回结果：<br>如果回复 +FULLRESYNC {runId} {offset} ，那么从节点将触发全量复制流程。<br>如果回复 +CONTINUE，从节点将触发部分复制。<br>如果回复 +ERR，说明主节点不支持 2.8 的 psync 命令，将使用 sync 执行全量复制。<br>到这里，数据之间的同步就讲的差不多了，篇幅还是比较长的。主要是针对 psync 命令相关之间的介绍。</p></blockquote><h3 id="三、全量复制"><a href="#三、全量复制" class="headerlink" title="三、全量复制"></a>三、全量复制</h3><blockquote><p>全量复制是 Redis 最早支持的复制方式，也是主从第一次建立复制时必须经历的的阶段。触发全量复制的命令是 sync 和 psync。之前说过，这两个命令的分水岭版本是 2.8，redis 2.8 之前使用 sync 只能执行全量不同，2.8 之后同时支持全量同步和部分同步。<br><img src="/img/newimg/006y8mN6gy1g864i3kt7pj30tk0zu12k.jpg" srcset="/img/loading.gif" alt="全量复制"><br>流程如下：<br>Step 1：发送 psync 命令（spync ？-1）<br>Step 2：主节点根据命令返回 FULLRESYNC<br>Step 3：从节点记录主节点 ID 和 offset<br>Step 4：主节点 bgsave 并保存 RDB 到本地<br>Step 5：主节点发送 RBD 文件到从节点<br>Step 6：从节点收到 RDB 文件并加载到内存中<br>Step 7：主节点在从节点接受数据的期间，将新数据保存到“复制客户端缓冲区”，当从节点加载 RDB 完毕，再发送过去。（如果从节点花费时间过长，将导致缓冲区溢出，最后全量同步失败）<br>Step 8：从节点清空数据后加载 RDB 文件，如果 RDB 文件很大，这一步操作仍然耗时，如果此时客户端访问，将导致数据不一致，可以使用配置 slave-server-stale-data 关闭.<br>Step 9：从节点成功加载完 RBD 后，如果开启了 AOF，会立刻做 bgrewriteaof。<br>以上加粗的部分是整个全量同步耗时的地方。</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">注意：<br>如过 RDB 文件大于 <span class="hljs-number">6</span>GB，并且是千兆网卡，Redis 的默认超时机制（<span class="hljs-number">60</span> 秒），会导致全量复制失败。可以通过调大 repl-timeout 参数来解决此问题。<br>Redis 虽然支持无盘复制，即直接通过网络发送给从节点，但功能不是很完善，生产环境慎用。<br></code></pre></div></td></tr></table></figure><h3 id="四、部分复制"><a href="#四、部分复制" class="headerlink" title="四、部分复制"></a>四、部分复制</h3><p>当从节点正在复制主节点时，如果出现网络闪断和其他异常，从节点会让主节点补发丢失的命令数据，主节点只需要将复制缓冲区的数据发送到从节点就能够保证数据的一致性，相比较全量复制，成本小很多。</p><blockquote><p><img src="/img/newimg/006y8mN6gy1g864kqtqm2j30w40m6wmc.jpg" srcset="/img/loading.gif" alt="部分复制"><br>当从节点出现网络中断，超过了 repl-timeout 时间，主节点就会中断复制连接。<br>主节点会将请求的数据写入到“复制积压缓冲区”，默认 1MB。<br>当从节点恢复，重新连接上主节点，从节点会将 offset 和主节点 id 发送到主节点。<br>主节点校验后，如果偏移量的数后的数据在缓冲区中，就发送 cuntinue 响应 —— 表示可以进行部分复制。<br>主节点将缓冲区的数据发送到从节点，保证主从复制进行正常状态。</p></blockquote><h3 id="五、心跳"><a href="#五、心跳" class="headerlink" title="五、心跳"></a>五、心跳</h3><p>主从节点在建立复制后，他们之间维护着长连接并彼此发送心跳命令。</p><blockquote><p>心跳的关键机制如下：<br>中从都有心跳检测机制，各自模拟成对方的客户端进行通信，通过 client list 命令查看复制相关客户端信息，主节点的连接状态为 flags = M，从节点的连接状态是 flags = S。<br>主节点默认每隔 10 秒对从节点发送 ping 命令，可修改配置 repl-ping-slave-period 控制发送频率。<br>从节点在主线程每隔一秒发送 replconf ack{offset} 命令，给主节点上报自身当前的复制偏移量。<br>主节点收到 replconf 信息后，判断从节点超时时间，如果超过 repl-timeout 60 秒，则判断节点下线。<br><img src="/img/newimg/006y8mN6gy1g864ik5kdlj30jw0a2wi1.jpg" srcset="/img/loading.gif" alt="心跳"></p></blockquote><p>注意：</p><p>为了降低主从延迟，一般把 redis 主从节点部署在相同的机房/同城机房，避免网络延迟带来的网络分区造成的心跳中断等情况。</p><h3 id="六、异步复制"><a href="#六、异步复制" class="headerlink" title="六、异步复制"></a>六、异步复制</h3><p>主节点不但负责数据读写，还负责把写命令同步给从节点，写命令的发送过程是异步完成，也就是说主节点处理完写命令后立即返回客户度，并不等待从节点复制完成。</p><blockquote><p>异步复制的步骤很简单，如下：<br>Step 1：主节点接受处理命令。<br>Step 2：主节点处理完后返回响应结果 。<br>Step 3：对于修改命令，异步发送给从节点，从节点在主线程中执行复制的命令<br><img src="/img/newimg/006y8mN6gy1g864l736zwj30so0do77c.jpg" srcset="/img/loading.gif" alt="异步复制"></p></blockquote><h3 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h3><p>本文主要分析了 Redis 的复制原理，包括复制过程，数据之间的同步，全量复制的流程，部分复制的流程，心跳设计，异步复制流程。</p><blockquote><p>其中，可以看出，RDB 数据之间的同步非常耗时。所以，Redis 在 2.8 版本退出了类似增量复制的 psync 命令，当 Redis 主从直接发生了网络中断，不会进行全量复制，而是将数据放到缓冲区（默认 1MB）里，再通过主从之间各自维护复制 offset 来判断缓存区的数据是否溢出。如果没有溢出，只需要发送缓冲区数据即可，成本很小；反之，则要进行全量复制。因此控制缓冲区大小非常的重要。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes ingress之nginx-ingress</title>
    <link href="/2019/07/29/kubernetes-ingress%E4%B9%8Bnginx-ingress/"/>
    <url>/2019/07/29/kubernetes-ingress%E4%B9%8Bnginx-ingress/</url>
    
    <content type="html"><![CDATA[<h4 id="ingress-介绍"><a href="#ingress-介绍" class="headerlink" title="ingress 介绍"></a>ingress 介绍</h4><p>在 k8s 中 service 就有可以让 pod 的工作端口暴露出来的三种方式</p><p>ClusterIP、NodePort 与 LoadBalance，这几种方式都是在 service 的维度提供的，service 的作用体现在两个方面，对集群内部，它不断跟踪 pod 的变化，更新 endpoint 中对应 pod 的对象，提供了 ip 不断变化的 pod 的服务发现机制，对集群外部，他类似负载均衡器，可以在集群内外部对 pod 进行访问。但是，单独用 service 暴露服务的方式，在实际生产环境中不太合适：</p><blockquote><p>1 . ClusterIP 的方式只能在集群内部访问。<br>2 . NodePort 方式的话，测试环境使用还行，当有几十上百的服务在集群中运行时，NodePort 的端口管理是灾难。<br>3 . LoadBalance 方式受限于云平台，且通常在云平台部署 ELB 还需要额外的费用。</p></blockquote><p>所幸 k8s 还提供了一种集群维度暴露服务的方式，也就是 ingress。ingress 可以简单理解为 service 的 service，他通过独立的 ingress 对象来制定请求转发的规则，把请求路由到一个或多个 service 中。这样就把服务与请求规则解耦了，可以从业务维度统一考虑业务的暴露，而不用为每个 service 单独考虑。</p><p><img src="/img/newimg/006y8mN6gy1g8655gjrg7j30if0c50to.jpg" srcset="/img/loading.gif" alt="ingress工作流"></p><p>截至目前，nginx-ingress 已经能够完成 7/4 层的代理功能 (本文基于目前最新版本 ingress-nginx0.25.0)</p><h4 id="ingress-与-ingress-controller-组件介绍"><a href="#ingress-与-ingress-controller-组件介绍" class="headerlink" title="ingress 与 ingress-controller 组件介绍"></a>ingress 与 ingress-controller 组件介绍</h4><p>要理解 ingress，需要区分两个概念，ingress 和 ingress-controller：</p><ul><li>ingress 对象：<br>指的是 k8s 中的一个 api 对象，一般用 yaml 配置。作用是定义请求如何转发到 service 的规则，可以理解为配置模板。</li><li>ingress-controller：<br>具体实现反向代理及负载均衡的程序，对 ingress 定义的规则进行解析，根据配置的规则来实现请求转发。</li></ul><p>简单来说，ingress-controller 才是负责具体转发的组件，通过各种方式将它暴露在集群入口，外部对集群的请求流量会先到 ingress-controller，而 ingress 对象是用来告诉 ingress-controller 该如何转发请求，比如哪些域名哪些 path 要转发到哪些服务等等。</p><hr><p>ingress-controller</p><p>ingress-controller 并不是 k8s 自带的组件，实际上 ingress-controller 只是一个统称，用户可以选择不同的 ingress-controller 实现，目前，由 k8s 维护的 ingress-controller 只有 google 云的 GCE 与 ingress-nginx 两个，其他还有很多第三方维护的 ingress-controller，具体可以参考<a href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/#additional-controllers" target="_blank" rel="noopener">官方文档</a>。但是不管哪一种 ingress-controller，实现的机制都大同小异，只是在具体配置上有差异。一般来说，ingress-controller 的形式都是一个 pod，里面跑着 daemon 程序和反向代理程序。daemon 负责不断监控集群的变化，根据 ingress 对象生成配置并应用新配置到反向代理，比如 nginx-ingress 就是动态生成 nginx 配置，动态更新 upstream，并在需要的时候 reload 程序应用新配置。为了方便，后面的例子都以 k8s 官方维护的 nginx-ingress 为例。</p><hr><p>ingress</p><p>ingress 是一个 API 对象，和其他对象一样，通过 yaml 文件来配置。ingress 通过 http 或 https 暴露集群内部 service，给 service 提供外部 URL、负载均衡、SSL/TLS 能力以及基于 host 的方向代理。ingress 要依靠 ingress-controller 来具体实现以上功能。</p><h4 id="ingress-工作原理"><a href="#ingress-工作原理" class="headerlink" title="ingress 工作原理"></a>ingress 工作原理</h4><p><img src="/img/newimg/006y8mN6gy1g8655gep4oj30o10bu418.jpg" srcset="/img/loading.gif" alt="工作原理"></p><p>Nginx <code>注意 新版本已经将nginx替换为OpenResty</code> 对后端运行的服务（Service1、Service2）提供反向代理，在配置文件中配置了域名与后端服务 Endpoints 的对应关系。客户端通过使用 DNS 服务或者直接配置本地的 hosts 文件，将域名都映射到 Nginx 代理服务器。当客户端访问 service1.com 时，浏览器会把包含域名的请求发送给 nginx 服务器，nginx 服务器根据传来的域名，选择对应的 Service，这里就是选择 Service 1 后端服务，然后根据一定的负载均衡策略，选择 Service1 中的某个容器接收来自客户端的请求并作出响应。过程很简单，nginx 在整个过程中仿佛是一台根据域名进行请求转发的“路由器”，这也就是 7 层代理的整体工作流程了！</p><blockquote><p>1.ingress controller 通过和 kubernetes api 交互，动态的去感知集群中 ingress 规则变化.</p><p>2.然后读取它，按照自定义的规则，规则就是写明了哪个域名对应哪个 service，生成一段 nginx 配置.</p><p>3.再写到 nginx-ingress-control 的 pod 里，这个 Ingress controller 的 pod 里运行着一个 Nginx 服务，控制器会把生成的 nginx 配置写入/etc/nginx.conf 文件中.</p><p>4.然后 reload 一下使配置生效。以此达到域名分配置和动态更新的问题。(目前最新版本的 ingress-nginx-controller，用 lua 实现了当 upstream 变化时不用 reload，大大减少了生产环境中由于服务的重启、升级引起的 IP 变化导致的 nginx reload)</p></blockquote><p><code>关于lua和nginx会专门在其他专栏讲解</code></p><h4 id="nginx-ingress-工作流程分析"><a href="#nginx-ingress-工作流程分析" class="headerlink" title="nginx-ingress 工作流程分析"></a>nginx-ingress 工作流程分析</h4><p>首先，上一张 Controller 整体工作模式架构图</p><p><img src="/img/newimg/006y8mN6gy1g8655g8a6kj30nu0abmz3.jpg" srcset="/img/loading.gif" alt="ingress Controller 架构图"></p><blockquote><p>不考虑 nginx 状态收集等附件功能，nginx-ingress 模块在运行时主要包括三个主体：NginxController、Store、SyncQueue. 其中，Store 主要负责从 kubernetes APIServer 收集运行时信息，感知各类资源（如 ingress、service 等）的变化，并及时将更新事件消息（event）写入一个环形管道；SyncQueue 协程定期扫描 syncQueue 队列，发现有任务就执行更新操作，即借助 Store 完成最新运行数据的拉取，然后根据一定的规则产生新的 nginx 配置，（有些更新必须 reload，就本地写入新配置，执行 reload），然后执行动态更新操作，即构造 POST 数据，向本地 Nginx Lua 服务模块发送 post 请求，实现配置更新；NginxController 作为中间的联系者，监听 updateChannel，一旦收到配置更新事件，就向同步队列 syncQueue 里写入一个更新请求。</p></blockquote><h3 id="二-Ingress-Nginx-的工作模式"><a href="#二-Ingress-Nginx-的工作模式" class="headerlink" title="二.Ingress-Nginx 的工作模式"></a>二.Ingress-Nginx 的工作模式</h3><p>ingress 的部署，需要考虑两个方面：</p><ol><li>ingress-controller 是作为 pod 来运行的，以什么方式部署比较好</li><li>ingress 解决了把如何请求路由到集群内部，那它自己怎么暴露给外部比较好</li></ol><p>下面列举一些目前常见的部署和暴露方式，具体使用哪种方式还是得根据实际需求来考虑决定。</p><h4 id="Deployment-LoadBalancer-模式的-Service"><a href="#Deployment-LoadBalancer-模式的-Service" class="headerlink" title="Deployment+LoadBalancer 模式的 Service"></a>Deployment+LoadBalancer 模式的 Service</h4><blockquote><p>如果要把 ingress 部署在公有云，那用这种方式比较合适。用 Deployment 部署 ingress-controller，创建一个 type 为 LoadBalancer 的 service 关联这组 pod。大部分公有云，都会为 LoadBalancer 的 service 自动创建一个负载均衡器，通常还绑定了公网地址。只要把域名解析指向该地址，就实现了集群服务的对外暴露。</p></blockquote><h4 id="Deployment-NodePort-模式的-Service"><a href="#Deployment-NodePort-模式的-Service" class="headerlink" title="Deployment+NodePort 模式的 Service"></a>Deployment+NodePort 模式的 Service</h4><blockquote><p>同样用 deployment 模式部署 ingress-controller，并创建对应的服务，但是 type 为 NodePort。这样，ingress 就会暴露在集群节点 ip 的特定端口上。由于 nodeport 暴露的端口是随机端口，一般会在前面再搭建一套负载均衡器来转发请求。该方式一般用于宿主机是相对固定的环境 ip 地址不变的场景。<br>NodePort 方式暴露 ingress 虽然简单方便，但是 NodePort 多了一层 NAT，在请求量级很大时可能对性能会有一定影响。</p></blockquote><h4 id="DaemonSet-HostNetwork-nodeSelector"><a href="#DaemonSet-HostNetwork-nodeSelector" class="headerlink" title="DaemonSet+HostNetwork+nodeSelector"></a>DaemonSet+HostNetwork+nodeSelector</h4><blockquote><p>用 DaemonSet 结合 nodeselector 来部署 ingress-controller 到特定的 node 上，然后使用 HostNetwork 直接把该 pod 与宿主机 node 的网络打通，直接使用宿主机的 80/433 端口就能访问服务。这时，ingress-controller 所在的 node 机器就很类似传统架构的边缘节点，比如机房入口的 nginx 服务器。该方式整个请求链路最简单，性能相对 NodePort 模式更好。缺点是由于直接利用宿主机节点的网络和端口，一个 node 只能部署一个 ingress-controller pod。比较适合大并发的生产环境使用。</p></blockquote><h3 id="三-Ingress-Nginx-的部署"><a href="#三-Ingress-Nginx-的部署" class="headerlink" title="三. Ingress-Nginx 的部署"></a>三. Ingress-Nginx 的部署</h3><p>首先看看官方 github 的 yaml 文件</p><p><img src="/img/newimg/006y8mN6gy1g8655g1yw3j30tc0cvq56.jpg" srcset="/img/loading.gif" alt="ingress-nginx-github"></p><p>其实 图中的 mandatory.yaml 文件已经整合其他文件的作用包括 rbac 租户 权限 configmap 以及 nginx-ingress-controller 的部署</p><p><code>本文部署用的第三种方式部署 DaemonSet+HostNetwork+nodeSelector</code></p><p>由于默认不是用的 hostnetwork 以及 nodeSelector ，需要下载官方 yaml 修改部分</p><p><code>https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/mandatory.yaml</code></p><p>修改前:</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-ingress-controller</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">ingress-nginx</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">ingress-nginx</span><br>    <span class="hljs-attr">app.kubernetes.io/part-of:</span> <span class="hljs-string">ingress-nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">ingress-nginx</span><br>      <span class="hljs-attr">app.kubernetes.io/part-of:</span> <span class="hljs-string">ingress-nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">ingress-nginx</span><br>        <span class="hljs-attr">app.kubernetes.io/part-of:</span> <span class="hljs-string">ingress-nginx</span><br>      <span class="hljs-attr">annotations:</span><br>        <span class="hljs-attr">prometheus.io/port:</span> <span class="hljs-string">"10254"</span><br>        <span class="hljs-attr">prometheus.io/scrape:</span> <span class="hljs-string">"true"</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">nginx-ingress-serviceaccount</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-ingress-controller</span><br>          <span class="hljs-attr">image:</span> <span class="hljs-string">quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.25.0</span><br>          <span class="hljs-attr">args:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">/nginx-ingress-controller</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">--configmap=$(POD_NAMESPACE)/nginx-configuration</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">--tcp-services-configmap=$(POD_NAMESPACE)/tcp-services</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">--udp-services-configmap=$(POD_NAMESPACE)/udp-services</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">--publish-service=$(POD_NAMESPACE)/ingress-nginx</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">--annotations-prefix=nginx.ingress.kubernetes.io</span><br>          <span class="hljs-attr">securityContext:</span><br>            <span class="hljs-attr">allowPrivilegeEscalation:</span> <span class="hljs-literal">true</span><br>            <span class="hljs-attr">capabilities:</span><br>              <span class="hljs-attr">drop:</span><br>                <span class="hljs-bullet">-</span> <span class="hljs-string">ALL</span><br>              <span class="hljs-attr">add:</span><br>                <span class="hljs-bullet">-</span> <span class="hljs-string">NET_BIND_SERVICE</span><br>            <span class="hljs-comment"># www-data -&gt; 33</span><br>            <span class="hljs-attr">runAsUser:</span> <span class="hljs-number">33</span><br>          <span class="hljs-attr">env:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">POD_NAME</span><br>              <span class="hljs-attr">valueFrom:</span><br>                <span class="hljs-attr">fieldRef:</span><br>                  <span class="hljs-attr">fieldPath:</span> <span class="hljs-string">metadata.name</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">POD_NAMESPACE</span><br>              <span class="hljs-attr">valueFrom:</span><br>                <span class="hljs-attr">fieldRef:</span><br>                  <span class="hljs-attr">fieldPath:</span> <span class="hljs-string">metadata.namespace</span><br>          <span class="hljs-attr">ports:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>              <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">https</span><br>              <span class="hljs-attr">containerPort:</span> <span class="hljs-number">443</span><br>          <span class="hljs-attr">livenessProbe:</span><br>            <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span><br>            <span class="hljs-attr">httpGet:</span><br>              <span class="hljs-attr">path:</span> <span class="hljs-string">/healthz</span><br>              <span class="hljs-attr">port:</span> <span class="hljs-number">10254</span><br>              <span class="hljs-attr">scheme:</span> <span class="hljs-string">HTTP</span><br>            <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">10</span><br>            <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span><br>            <span class="hljs-attr">successThreshold:</span> <span class="hljs-number">1</span><br>            <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">10</span><br>          <span class="hljs-attr">readinessProbe:</span><br>            <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span><br>            <span class="hljs-attr">httpGet:</span><br>              <span class="hljs-attr">path:</span> <span class="hljs-string">/healthz</span><br>              <span class="hljs-attr">port:</span> <span class="hljs-number">10254</span><br>              <span class="hljs-attr">scheme:</span> <span class="hljs-string">HTTP</span><br>            <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span><br>            <span class="hljs-attr">successThreshold:</span> <span class="hljs-number">1</span><br>            <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">10</span><br></code></pre></div></td></tr></table></figure><p>修改后：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># 修改api版本及kind</span><br><span class="hljs-comment"># apiVersion: apps/v1</span><br><span class="hljs-comment"># kind: Deployment</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">extensions/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">DaemonSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-ingress-controller</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">ingress-nginx</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">ingress-nginx</span><br>    <span class="hljs-attr">app.kubernetes.io/part-of:</span> <span class="hljs-string">ingress-nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-comment"># 删除Replicas</span><br>  <span class="hljs-comment"># replicas: 1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">ingress-nginx</span><br>      <span class="hljs-attr">app.kubernetes.io/part-of:</span> <span class="hljs-string">ingress-nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">ingress-nginx</span><br>        <span class="hljs-attr">app.kubernetes.io/part-of:</span> <span class="hljs-string">ingress-nginx</span><br>      <span class="hljs-attr">annotations:</span><br>        <span class="hljs-attr">prometheus.io/port:</span> <span class="hljs-string">"10254"</span><br>        <span class="hljs-attr">prometheus.io/scrape:</span> <span class="hljs-string">"true"</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">nginx-ingress-serviceaccount</span><br>      <span class="hljs-comment"># 选择对应标签的node</span><br>      <span class="hljs-attr">nodeSelector:</span><br>        <span class="hljs-attr">isIngress:</span> <span class="hljs-string">"true"</span><br>      <span class="hljs-comment"># 使用hostNetwork暴露服务</span><br>      <span class="hljs-attr">hostNetwork:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-ingress-controller</span><br>          <span class="hljs-attr">image:</span> <span class="hljs-string">quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.25.0</span><br>          <span class="hljs-attr">args:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">/nginx-ingress-controller</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">--configmap=$(POD_NAMESPACE)/nginx-configuration</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">--tcp-services-configmap=$(POD_NAMESPACE)/tcp-services</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">--udp-services-configmap=$(POD_NAMESPACE)/udp-services</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">--publish-service=$(POD_NAMESPACE)/ingress-nginx</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">--annotations-prefix=nginx.ingress.kubernetes.io</span><br>          <span class="hljs-attr">securityContext:</span><br>            <span class="hljs-attr">allowPrivilegeEscalation:</span> <span class="hljs-literal">true</span><br>            <span class="hljs-attr">capabilities:</span><br>              <span class="hljs-attr">drop:</span><br>                <span class="hljs-bullet">-</span> <span class="hljs-string">ALL</span><br>              <span class="hljs-attr">add:</span><br>                <span class="hljs-bullet">-</span> <span class="hljs-string">NET_BIND_SERVICE</span><br>            <span class="hljs-comment"># www-data -&gt; 33</span><br>            <span class="hljs-attr">runAsUser:</span> <span class="hljs-number">33</span><br>          <span class="hljs-attr">env:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">POD_NAME</span><br>              <span class="hljs-attr">valueFrom:</span><br>                <span class="hljs-attr">fieldRef:</span><br>                  <span class="hljs-attr">fieldPath:</span> <span class="hljs-string">metadata.name</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">POD_NAMESPACE</span><br>              <span class="hljs-attr">valueFrom:</span><br>                <span class="hljs-attr">fieldRef:</span><br>                  <span class="hljs-attr">fieldPath:</span> <span class="hljs-string">metadata.namespace</span><br>          <span class="hljs-attr">ports:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>              <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">https</span><br>              <span class="hljs-attr">containerPort:</span> <span class="hljs-number">443</span><br>          <span class="hljs-attr">livenessProbe:</span><br>            <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span><br>            <span class="hljs-attr">httpGet:</span><br>              <span class="hljs-attr">path:</span> <span class="hljs-string">/healthz</span><br>              <span class="hljs-attr">port:</span> <span class="hljs-number">10254</span><br>              <span class="hljs-attr">scheme:</span> <span class="hljs-string">HTTP</span><br>            <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">10</span><br>            <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span><br>            <span class="hljs-attr">successThreshold:</span> <span class="hljs-number">1</span><br>            <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">10</span><br>          <span class="hljs-attr">readinessProbe:</span><br>            <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span><br>            <span class="hljs-attr">httpGet:</span><br>              <span class="hljs-attr">path:</span> <span class="hljs-string">/healthz</span><br>              <span class="hljs-attr">port:</span> <span class="hljs-number">10254</span><br>              <span class="hljs-attr">scheme:</span> <span class="hljs-string">HTTP</span><br>            <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span><br>            <span class="hljs-attr">successThreshold:</span> <span class="hljs-number">1</span><br>            <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">10</span><br></code></pre></div></td></tr></table></figure><p>并且给某节点打上标签 我这里是给 node1 节点</p><p><code>kubectl label node node-1 isIngress=&quot;true&quot;</code></p><p><img src="/img/newimg/006y8mN6gy1g8655fwsw1j31bk02jmxp.jpg" srcset="/img/loading.gif" alt="打标签"></p><p>修改完后执行 apply,并检查服务</p><p><code>kubectl apply -f mandatory.yaml</code></p><p><img src="/img/newimg/006y8mN6gy1g8655fqx9lj30va034mxn.jpg" srcset="/img/loading.gif" alt="部署后查看"></p><p>可以看到，nginx-controller 的 pod 已经部署在在 node-1 上了</p><p>由于配置了 hostnetwork，nginx 已经在 node 主机本地监听 80/443/8181 端口。其中 8181 是 nginx-controller 默认配置的一个 default backend。这样，只要访问 node 主机有公网 IP，就可以直接映射域名来对外网暴露服务了。如果要 nginx 高可用的话，可以在多个 node<br>上部署，并在前面再搭建一套 LVS+keepalive 做负载均衡。用 hostnetwork 的另一个好处是，如果 lvs 用 DR 模式的话，是不支持端口映射的，这时候如果用 nodeport，暴露非标准的端口，管理起来会很麻烦。</p><p><img src="/img/newimg/006y8mN6gy1g8655e31s3j31ez0qywla.jpg" srcset="/img/loading.gif" alt="查看监听端口"></p><h4 id="配置-ingress-资源"><a href="#配置-ingress-资源" class="headerlink" title="配置 ingress 资源"></a>配置 ingress 资源</h4><p>部署完 ingress-controller，接下来就按照测试的需求来创建 ingress 资源。</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">extensions/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ingress-test</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-attr">kubernetes.io/ingress.class:</span> <span class="hljs-string">"nginx"</span><br>    <span class="hljs-comment"># 开启use-regex，启用path的正则匹配</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/use-regex:</span> <span class="hljs-string">"true"</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>    <span class="hljs-comment"># 定义域名</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">test.ingress.com</span><br>      <span class="hljs-attr">http:</span><br>        <span class="hljs-attr">paths:</span><br>          <span class="hljs-comment"># 不同path转发到不同端口</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/ip</span><br>            <span class="hljs-attr">backend:</span><br>              <span class="hljs-attr">serviceName:</span> <span class="hljs-string">s1</span><br>              <span class="hljs-attr">servicePort:</span> <span class="hljs-number">8000</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/host</span><br>            <span class="hljs-attr">backend:</span><br>              <span class="hljs-attr">serviceName:</span> <span class="hljs-string">s2</span><br>              <span class="hljs-attr">servicePort:</span> <span class="hljs-number">8000</span><br></code></pre></div></td></tr></table></figure><p>部署资源</p><p><code>$ kubectl apply -f ingresstest.yaml</code></p><p>其中 service s1 s2 是我自己定义的两个 flask 容器的 service 端口为 8000</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicationController</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">s1</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">s1</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">s1</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">s1</span><br>          <span class="hljs-attr">image:</span> <span class="hljs-string">jxhs/s2:v3</span><br>          <span class="hljs-attr">ports:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">s1</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">8000</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8000</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">s1</span><br></code></pre></div></td></tr></table></figure><h4 id="测试访问"><a href="#测试访问" class="headerlink" title="测试访问"></a>测试访问</h4><p>部署好以后，做一条本地 host 来模拟解析 test.ingress.com 到 node1 的 ip 地址。测试访问</p><p><img src="/img/newimg/006y8mN6gy1g8655dvbukj30ab03l0sn.jpg" srcset="/img/loading.gif" alt="访问图1"></p><p><img src="/img/newimg/006y8mN6gy1g8655dpg0gj30by03bjrb.jpg" srcset="/img/loading.gif" alt="访问图2"></p><p>上面测试的例子是非常简单的，实际 ingress-nginx 的有非常多的配置.后面会介绍一些关于 ingress 源码、ssl 和四层负载均衡方面的东西</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><ul><li>ingress 是 k8s 集群的请求入口，可以理解为对多个 service 的再次抽象</li><li>通常说的 ingress 一般包括 ingress 资源对象及 ingress-controller 两部分组成</li><li>ingress-controller 有多种实现，社区原生的是 ingress-nginx，根据具体需求选择</li><li>ingress 自身的暴露有多种方式，需要根据基础环境及业务类型选择合适的方式</li></ul><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><blockquote><p><a href="https://github.com/kubernetes/ingress-nginx" target="_blank" rel="noopener">https://github.com/kubernetes/ingress-nginx</a></p><p><a href="https://segmentfault.com/a/1190000019908991" target="_blank" rel="noopener">https://segmentfault.com/a/1190000019908991</a></p><p><a href="https://www.cnblogs.com/k-free-bolg/p/11169111.html" target="_blank" rel="noopener">https://www.cnblogs.com/k-free-bolg/p/11169111.html</a></p><p><a href="https://blog.csdn.net/shida_csdn/article/details/84032019" target="_blank" rel="noopener">https://blog.csdn.net/shida_csdn/article/details/84032019</a></p><p><a href="https://cloud.tencent.com/developer/article/1475537" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1475537</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker运行容器后agetty进程cpu占用率100%</title>
    <link href="/2019/07/28/docker%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8%E5%90%8Eagetty%E8%BF%9B%E7%A8%8Bcpu%E5%8D%A0%E7%94%A8%E7%8E%87100/"/>
    <url>/2019/07/28/docker%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8%E5%90%8Eagetty%E8%BF%9B%E7%A8%8Bcpu%E5%8D%A0%E7%94%A8%E7%8E%87100/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近在使用 docker 容器的时候，发现宿主机的 agetty 进程 cpu 占用率达到 100%。<br><img src="/img/newimg/006y8mN6gy1g864u6hjoxj31k00ikjwt.jpg" srcset="/img/loading.gif" alt="负载图"></p></blockquote><p>在 Google 上搜了下，引起这个问题的原因是在使用”docker run”运行容器时使用了 “/sbin/init”和”–privileged”参数。</p><p>使用/sbin/init 启动容器并加上–privileged 参数，相当于 docker 容器获得了宿主机的全权委托权限。这时 docker 容器内部的 init 与宿主机的 init 产生了混淆。</p><h3 id="引用-google-到的一段话："><a href="#引用-google-到的一段话：" class="headerlink" title="引用 google 到的一段话："></a>引用 google 到的一段话：</h3><blockquote><p>I’ve done all my testing on them without using –privileged, especially since that’s so dangerous (effectively, you’re telling this second init process on your system that it’s cool to go ahead and manage your system resources, and then giving it access to them as well). I always think of –privileged as a hammer to be used very sparingly.</p></blockquote><hr><p>出于对安全的考虑，在启动容器时，docker 容器里的系统只具有一些普通的 linux 权限，并不具有真正 root 用户的所有权限。而–privileged=true 参数可以让 docker 容器具有 linux root 用户的所有权限。</p><p>为了解决这个问题，docker 后来的版本中 docker run 增加了两个选项参数”–cap-add”和”–cap-drop”。</p><p>–cap-add : 获取 default 之外的 linux 的权限</p><p>–cap-drop: 放弃 default linux 权限</p><blockquote><p>所以，在运行容器时，可以不用–privileged 参数的尽量不用，用–cap-add 参数替代。如果必须使用–privileged=true 参数的，可以通过在宿主机和容器中执行以下命令将 agetty 关闭。<br>shell&gt; systemctl stop <a href="mailto:getty@tty1.service">getty@tty1.service</a><br>shell&gt; systemctl mask <a href="mailto:getty@tty1.service">getty@tty1.service</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>性能判断专栏</title>
    <link href="/2019/07/25/%E6%80%A7%E8%83%BD%E5%88%A4%E6%96%AD%E4%B8%93%E6%A0%8F/"/>
    <url>/2019/07/25/%E6%80%A7%E8%83%BD%E5%88%A4%E6%96%AD%E4%B8%93%E6%A0%8F/</url>
    
    <content type="html"><![CDATA[<center>CPU篇</center><p><img src="/img/newimg/006y8mN6gy1g864s0sbkyj30uq0u0jue.jpg" srcset="/img/loading.gif" alt="分析点"><br><img src="/img/newimg/006y8mN6gy1g864rszm30j30u0192the.jpg" srcset="/img/loading.gif" alt="分析过程"></p><center>内存篇</center><p><img src="/img/newimg/006y8mN6gy1g864s8jvmrj30u00xe79o.jpg" srcset="/img/loading.gif" alt="分析点"><br><img src="/img/newimg/006y8mN6gy1g864sdr3iyj30u013wdmf.jpg" srcset="/img/loading.gif" alt="分析过程"></p><center>IO篇</center><p><img src="/img/newimg/006y8mN6gy1g864t245r7j30u016fqb6.jpg" srcset="/img/loading.gif" alt="分析点"><br><img src="/img/newimg/006y8mN6gy1g864sqvhstj30u0178qa8.jpg" srcset="/img/loading.gif" alt="分析过程"></p><center>网络篇</center><p><img src="/img/newimg/006y8mN6gy1g864ti88l9j31hw0u0q7j.jpg" srcset="/img/loading.gif" alt="分析点"><br><img src="/img/newimg/006y8mN6gy1g864sqvhstj30u0178qa8.jpg" srcset="/img/loading.gif" alt="分析过程"></p><center>终极篇</center><p><img src="/img/newimg/006y8mN6gy1g864to8c1zj316v0u04nr.jpg" srcset="/img/loading.gif" alt="分析点"></p>]]></content>
    
    
    <categories>
      
      <category>系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统负载</title>
    <link href="/2019/07/22/%E7%B3%BB%E7%BB%9F%E8%B4%9F%E8%BD%BD/"/>
    <url>/2019/07/22/%E7%B3%BB%E7%BB%9F%E8%B4%9F%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="负载变高有三个原因："><a href="#负载变高有三个原因：" class="headerlink" title="负载变高有三个原因："></a>负载变高有三个原因：</h2><blockquote><p>1.CPU 密集型进程，使用大量 CPU 会知道平均负载升高。<br>2.I/O 密集型进程，等到 I/O 也会导致平均负载升高，但是 CPU 使用率不一定很高。 3.大量等待 CPU 的进程调度也会导致平均负载升高，此时 CPU 使用率也会比较高。</p></blockquote><center> iostat mpstat pidstat vmstat perf top</center><h3 id="mpstat"><a href="#mpstat" class="headerlink" title="mpstat"></a>mpstat</h3><blockquote><p>mpstat -P ALL 5<br>作用查看 cpu 每个 cpu 使用情况</p></blockquote><h3 id="pidstat"><a href="#pidstat" class="headerlink" title="pidstat"></a>pidstat</h3><blockquote><p>pidstat -u 5 1<br>实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标</p></blockquote><h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h3><blockquote><p>vmstat 1<br>查看 系统内存和上下文切换以及切换类型的工具</p></blockquote><blockquote><p>举例：<br>发现系统负载变高时候 1.使用 mpstat -P ALL 5<br>发现是使用率为百分之百 但是 iowait 为 0 说明此时真的有程序使用了百分之百的 CPU，这次负载升高就是此原因</p></blockquote><blockquote><p>2.使用 mpstat -P ALL 5<br>发现系统 CPU 使用率只有百分之 20 多 但是 系统的 iowait 达到了百分之 70 多 这说明这次负载升高是由于 iowait 引起的<br>然后使用 pidstat -u 5 1</p></blockquote><h2 id="CPU-性能"><a href="#CPU-性能" class="headerlink" title="CPU 性能"></a>CPU 性能</h2><blockquote><p>1.多任务竞争 CPU，cpu 变换任务的时候进行 CPU 上下文切换(context switch)。CPU 执行任务有 4 种方式：进程、线程、或者硬件通过触发信号导致中断的调用。<br>2、当切换任务的时候，需要记录任务当前的状态和获取下一任务的信息和地址(指针)，这就是上下文的内容。因此，上下文是指某一时间点 CPU 寄存器(CPU register)和程序计数器(PC)的内容, 广义上还包括内存中进程的虚拟地址映射信息.<br>3、上下文切换的过程：<br>(1)记录当前任务的上下文(即寄存器和计算器等所有的状态)；<br>(2)找到新任务的上下文并加载；<br>(3)切换到新任务的程序计算器位置，恢复其任务。<br>4、根据任务的执行形式，相应的下上文切换，有进程上下文切换、线程上下文切换、以及中断上下文切换三类。<br>5、进程和线程的区别：<br>进程是资源分配和执行的基本单位；线程是任务调度和运行的基本单位。线程没有资源，进程给指针提供虚拟内存、栈、变量等共享资源，而线程可以共享进程的资源。<br>6、进程上下文切换：是指从一个进程切换到另一个进程。<br>(1)进程运行态为内核运行态和进程运行态。内核空间态资源包括内核的堆栈、寄存器等；用户空间态资源包括虚拟内存、栈、变量、正文、数据等<br>(2)系统调用(软中断)在内核态完成的，需要进行 2 次 CPU 上下文切换(用户空间–&gt;内核空间–&gt;用户空间)，不涉及用户态资源，也不会切换进程<br>(3)进程是由内核来管理和调度的，进程的切换只能发生在内核态。所以，进程的上下文不仅包括了用户空间的资源，也包括内核空间资源。<br>(4)进程的上下文切换过程：<br>(a)接收到切换信号，挂起进程，记录当前进程的虚拟内存、栈等资源存储;<br>(b)将这个进程在 CPU 中的上下文状态存储于起来;<br>(c)然后在内存中检索下一个进程的上下文;<br>(d)并将其加载到 CPU 的寄存器中恢复;<br>(e)还需要刷新进程的虚拟内存和用户栈;<br>(f)最后跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程。<br>(5)、下列将会触发进程上下文切换的场景：<br>(a)、根据调度策略，将 CPU 时间划片为对应的时间片，当时间片耗尽，当前进程必须挂起。<br>(b)、资源不足的，在获取到足够资源之前进程挂起。<br>(c)、进程 sleep 挂起进程。<br>(d)、高优先级进程导致当前进度挂起<br>(e)、硬件中断，导致当前进程挂起<br>7、线程上下文切换：<br>(1)、不通进程之间的线程上下文切换，其过程和进程上下文切换大致相同。<br>(2)、进程内部的线程进上下文切换。不需要切换进程的用户资源，只需要切换线程私有的数据和寄存器等。这会比进程上下文进程切换消耗的资源少，所以多线程相比多进程的优势。<br>8、中断上下文切换<br>快速响应硬件的事件，中断处理会打断进程的正常调度和执行。同一 CPU 内，硬件中断优先级高于进程。切换过程类似于系统调用的时候，不涉及到用户运行态资源。但大量的中断上下文切换同样可能引发性能问题。</p></blockquote><h3 id="排查-cpu-负载"><a href="#排查-cpu-负载" class="headerlink" title="排查 cpu 负载"></a>排查 cpu 负载</h3><blockquote><p>1.用户 CPU 和 Nice CPU 高，说明用户态进程占用了较多的 CPU，所以应该着重排查进程的性能问题。<br>2.系统 CPU 高，说明内核态占用了较多的 CPU，所以应该着重排查内核线程或者系统调用的性能问题。<br>3.I/O 等待 CPU 高，说明等待 I/O 的时间比较长，所以应该着重排查系统存储是不是出现了 I/O 问题。<br>4.软中断和硬中断高，说明软中断或硬中断的处理程序占用了较多的 CPU，所以应该着重排查内核中的中断服务程序。</p></blockquote><h2 id="排查方法"><a href="#排查方法" class="headerlink" title="排查方法"></a>排查方法</h2><blockquote><p>如果应用方说系统负载卡 1.首先看看系统平均负载，1 分钟 5 分钟 15 分钟 查看趋势 2.如果平均负载高，先判断是 io 导致，还是 cpu 导致或者是中断导致<br>用 top 查看 看看哪个方面的比较高 或者 mpstat -p ALL 5<br>如果是 io 导致:<br>用 iotop iostat 判断是哪个程序 io 比较频繁，或者读写次数特别多，从而进一步分析<br>如果是 cpu 比较高导致:<br>用 ps -ef 或者 top -U 或者 pidstat 查看哪个进程导致的 cpu 较高，从而进一步分析<br>如果是中断高可以看到<br>如果只看到负载高 但是看不到其他的任何异常，那么用神器 perf top (perf record -g [and] perf report)</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>负载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题专栏</title>
    <link href="/2019/07/19/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    <url>/2019/07/19/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%93%E6%A0%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="2019年最新总结，阿里，腾讯，百度，美团，头条等技术面试题目，以及答案，专家出题人分析汇总。持续更新中。"><a href="#2019年最新总结，阿里，腾讯，百度，美团，头条等技术面试题目，以及答案，专家出题人分析汇总。持续更新中。" class="headerlink" title="2019年最新总结，阿里，腾讯，百度，美团，头条等技术面试题目，以及答案，专家出题人分析汇总。持续更新中。"></a>2019年最新总结，阿里，腾讯，百度，美团，头条等技术面试题目，以及答案，专家出题人分析汇总。持续更新中。</h2><ul><li><a href="#1">阿里篇</a></li><li><a href="#2">华为篇</a></li><li><a href="#3">百度篇</a></li><li><a href="#4">腾讯篇</a></li><li><a href="#5">美团篇</a></li><li><a href="#6">头条篇</a></li><li><a href="#7">滴滴篇</a></li><li><a href="#8">京东篇</a></li><li><a href="#9">MySQL篇</a></li><li><a href="#10">Redis篇</a></li><li><a href="#11">MongDB篇</a></li><li><a href="#12">Zookeeper篇</a></li><li><a href="#13">Nginx篇</a></li><li><a href="#14">算法篇</a></li><li><a href="#15">内存篇</a></li><li><a href="#16">cpu篇</a></li><li><a href="#17">磁盘篇</a></li><li><a href="#18">网络通信篇</a></li><li><a href="#19">安全篇</a></li><li><a href="#20">并发篇</a></li></ul><h3 id="1">阿里篇</h3> <hr><h5 id="1-1-1-如何实现一个高效的单向链表逆序输出？"><a href="#1-1-1-如何实现一个高效的单向链表逆序输出？" class="headerlink" title="1.1.1 如何实现一个高效的单向链表逆序输出？"></a>1.1.1 如何实现一个高效的单向链表逆序输出？</h5><h5 id="1-1-2-已知sqrt-2-约等于1-414，要求不用数学库，求sqrt-2-精确到小数点后10位"><a href="#1-1-2-已知sqrt-2-约等于1-414，要求不用数学库，求sqrt-2-精确到小数点后10位" class="headerlink" title="1.1.2 已知sqrt(2)约等于1.414，要求不用数学库，求sqrt(2)精确到小数点后10位"></a>1.1.2 已知sqrt(2)约等于1.414，要求不用数学库，求sqrt(2)精确到小数点后10位</h5><h5 id="1-1-3-给定一个二叉搜索树-BST-，找到树中第-K-小的节点"><a href="#1-1-3-给定一个二叉搜索树-BST-，找到树中第-K-小的节点" class="headerlink" title="1.1.3 给定一个二叉搜索树(BST)，找到树中第 K 小的节点"></a>1.1.3 给定一个二叉搜索树(BST)，找到树中第 K 小的节点</h5><h5 id="1-1-4-LRU缓存机制"><a href="#1-1-4-LRU缓存机制" class="headerlink" title="1.1.4 LRU缓存机制"></a>1.1.4 LRU缓存机制</h5><h5 id="1-1-5-关于epoll和select的区别，以下哪些说法是正确的"><a href="#1-1-5-关于epoll和select的区别，以下哪些说法是正确的" class="headerlink" title="1.1.5 关于epoll和select的区别，以下哪些说法是正确的"></a>1.1.5 关于epoll和select的区别，以下哪些说法是正确的</h5><h5 id="1-1-6-从innodb的索引结构分析，为什么索引的-key-长度不能太长"><a href="#1-1-6-从innodb的索引结构分析，为什么索引的-key-长度不能太长" class="headerlink" title="1.1.6 从innodb的索引结构分析，为什么索引的 key 长度不能太长"></a>1.1.6 从innodb的索引结构分析，为什么索引的 key 长度不能太长</h5><h5 id="1-1-7-MySQL的数据如何恢复到任意时间点？"><a href="#1-1-7-MySQL的数据如何恢复到任意时间点？" class="headerlink" title="1.1.7 MySQL的数据如何恢复到任意时间点？"></a>1.1.7 MySQL的数据如何恢复到任意时间点？</h5><h5 id="1-1-8-NFS-和-SMB-是最常见的两种-NAS（Network-Attached-Storage）协议，当把一个文件系统同时通过-NFS-和-SMB-协议共享给多个主机访问时，以下哪些说法是错误的"><a href="#1-1-8-NFS-和-SMB-是最常见的两种-NAS（Network-Attached-Storage）协议，当把一个文件系统同时通过-NFS-和-SMB-协议共享给多个主机访问时，以下哪些说法是错误的" class="headerlink" title="1.1.8 NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的"></a>1.1.8 NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的</h5><h5 id="1-1-9-输入-ping-IP-后敲回车，发包前会发生什么？"><a href="#1-1-9-输入-ping-IP-后敲回车，发包前会发生什么？" class="headerlink" title="1.1.9 输入 ping IP 后敲回车，发包前会发生什么？"></a>1.1.9 输入 ping IP 后敲回车，发包前会发生什么？</h5><h5 id="1-2-0-请解释下为什么鹿晗发布恋情的时候，微博系统会崩溃，如何解决？"><a href="#1-2-0-请解释下为什么鹿晗发布恋情的时候，微博系统会崩溃，如何解决？" class="headerlink" title="1.2.0 请解释下为什么鹿晗发布恋情的时候，微博系统会崩溃，如何解决？"></a>1.2.0 请解释下为什么鹿晗发布恋情的时候，微博系统会崩溃，如何解决？</h5><h5 id="1-2-1-现有一批邮件需要发送给订阅顾客，且有一个集群（集群的节点数不定，会动态扩容缩容）来负责具体的邮件发送任务，如何让系统尽快地完成发送？"><a href="#1-2-1-现有一批邮件需要发送给订阅顾客，且有一个集群（集群的节点数不定，会动态扩容缩容）来负责具体的邮件发送任务，如何让系统尽快地完成发送？" class="headerlink" title="1.2.1 现有一批邮件需要发送给订阅顾客，且有一个集群（集群的节点数不定，会动态扩容缩容）来负责具体的邮件发送任务，如何让系统尽快地完成发送？"></a>1.2.1 现有一批邮件需要发送给订阅顾客，且有一个集群（集群的节点数不定，会动态扩容缩容）来负责具体的邮件发送任务，如何让系统尽快地完成发送？</h5><h5 id="1-2-2-有一批气象观测站，现需要获取这些站点的观测数据，并存储到-Hive-中。但是气象局只提供了-api-查询，每次只能查询单个观测点。那么如果能够方便快速地获取到所有的观测点的数据？"><a href="#1-2-2-有一批气象观测站，现需要获取这些站点的观测数据，并存储到-Hive-中。但是气象局只提供了-api-查询，每次只能查询单个观测点。那么如果能够方便快速地获取到所有的观测点的数据？" class="headerlink" title="1.2.2 有一批气象观测站，现需要获取这些站点的观测数据，并存储到 Hive 中。但是气象局只提供了 api 查询，每次只能查询单个观测点。那么如果能够方便快速地获取到所有的观测点的数据？"></a>1.2.2 有一批气象观测站，现需要获取这些站点的观测数据，并存储到 Hive 中。但是气象局只提供了 api 查询，每次只能查询单个观测点。那么如果能够方便快速地获取到所有的观测点的数据？</h5><h5 id="1-2-3-如何实现两金额数据相加（最多小数点两位）"><a href="#1-2-3-如何实现两金额数据相加（最多小数点两位）" class="headerlink" title="1.2.3 如何实现两金额数据相加（最多小数点两位）"></a>1.2.3 如何实现两金额数据相加（最多小数点两位）</h5><h5 id="1-2-4-关于并行计算的一些基础开放问题"><a href="#1-2-4-关于并行计算的一些基础开放问题" class="headerlink" title="1.2.4 关于并行计算的一些基础开放问题"></a>1.2.4 关于并行计算的一些基础开放问题</h5><h5 id="1-2-5-请计算XILINX公司VU9P芯片的算力相当于多少TOPS，给出计算过程与公式"><a href="#1-2-5-请计算XILINX公司VU9P芯片的算力相当于多少TOPS，给出计算过程与公式" class="headerlink" title="1.2.5 请计算XILINX公司VU9P芯片的算力相当于多少TOPS，给出计算过程与公式"></a>1.2.5 请计算XILINX公司VU9P芯片的算力相当于多少TOPS，给出计算过程与公式</h5><h5 id="1-2-6-一颗现代处理器，每秒大概可以执行多少条简单的MOV指令，有哪些主要的影响因素"><a href="#1-2-6-一颗现代处理器，每秒大概可以执行多少条简单的MOV指令，有哪些主要的影响因素" class="headerlink" title="1.2.6 一颗现代处理器，每秒大概可以执行多少条简单的MOV指令，有哪些主要的影响因素"></a>1.2.6 一颗现代处理器，每秒大概可以执行多少条简单的MOV指令，有哪些主要的影响因素</h5><h5 id="1-2-7-请分析-MaxCompute-产品与分布式技术的关系、当前大数据计算平台类产品的市场现状和发展趋势"><a href="#1-2-7-请分析-MaxCompute-产品与分布式技术的关系、当前大数据计算平台类产品的市场现状和发展趋势" class="headerlink" title="1.2.7 请分析 MaxCompute 产品与分布式技术的关系、当前大数据计算平台类产品的市场现状和发展趋势"></a>1.2.7 请分析 MaxCompute 产品与分布式技术的关系、当前大数据计算平台类产品的市场现状和发展趋势</h5><h5 id="1-2-8-对大数据平台中的元数据管理是怎么理解的，元数据收集管理体系是怎么样的，会对大数据应用有什么样的影响"><a href="#1-2-8-对大数据平台中的元数据管理是怎么理解的，元数据收集管理体系是怎么样的，会对大数据应用有什么样的影响" class="headerlink" title="1.2.8 对大数据平台中的元数据管理是怎么理解的，元数据收集管理体系是怎么样的，会对大数据应用有什么样的影响"></a>1.2.8 对大数据平台中的元数据管理是怎么理解的，元数据收集管理体系是怎么样的，会对大数据应用有什么样的影响</h5><h5 id="1-2-9-你理解常见如阿里，和友商大数据平台的技术体系差异以及发展趋势和技术瓶颈，在存储和计算两个方面进行概述"><a href="#1-2-9-你理解常见如阿里，和友商大数据平台的技术体系差异以及发展趋势和技术瓶颈，在存储和计算两个方面进行概述" class="headerlink" title="1.2.9 你理解常见如阿里，和友商大数据平台的技术体系差异以及发展趋势和技术瓶颈，在存储和计算两个方面进行概述"></a>1.2.9 你理解常见如阿里，和友商大数据平台的技术体系差异以及发展趋势和技术瓶颈，在存储和计算两个方面进行概述</h5><h5 id="1-3-0-在云计算大数据处理场景中，每天运行着成千上万的任务，每个任务都要进行-IO-读写。存储系统为了更好的服务，经常会保证高优先级的任务优先执行。当多个作业或用户访问存储系统时-如何保证优先级和公平性"><a href="#1-3-0-在云计算大数据处理场景中，每天运行着成千上万的任务，每个任务都要进行-IO-读写。存储系统为了更好的服务，经常会保证高优先级的任务优先执行。当多个作业或用户访问存储系统时-如何保证优先级和公平性" class="headerlink" title="1.3.0 在云计算大数据处理场景中，每天运行着成千上万的任务，每个任务都要进行 IO 读写。存储系统为了更好的服务，经常会保证高优先级的任务优先执行。当多个作业或用户访问存储系统时,如何保证优先级和公平性"></a>1.3.0 在云计算大数据处理场景中，每天运行着成千上万的任务，每个任务都要进行 IO 读写。存储系统为了更好的服务，经常会保证高优先级的任务优先执行。当多个作业或用户访问存储系统时,如何保证优先级和公平性</h5><h5 id="1-3-1-最大频率栈"><a href="#1-3-1-最大频率栈" class="headerlink" title="1.3.1 最大频率栈"></a>1.3.1 最大频率栈</h5><h5 id="1-3-2-给定一个链表，删除链表的倒数第N个节点，并且返回链表的头结点"><a href="#1-3-2-给定一个链表，删除链表的倒数第N个节点，并且返回链表的头结点" class="headerlink" title="1.3.2 给定一个链表，删除链表的倒数第N个节点，并且返回链表的头结点"></a>1.3.2 给定一个链表，删除链表的倒数第N个节点，并且返回链表的头结点</h5><h5 id="1-3-3-如果让你设计一个通用的、支持各种数据库秒级备份和恢复的系统，你会如何设计"><a href="#1-3-3-如果让你设计一个通用的、支持各种数据库秒级备份和恢复的系统，你会如何设计" class="headerlink" title="1.3.3 如果让你设计一个通用的、支持各种数据库秒级备份和恢复的系统，你会如何设计"></a>1.3.3 如果让你设计一个通用的、支持各种数据库秒级备份和恢复的系统，你会如何设计</h5><h5 id="1-3-4-如果让你来设计一个支持数据库、NOSQL-和大数据之间数据实时流动的数据流及处理的系统，你会考虑哪些问题？如何设计？"><a href="#1-3-4-如果让你来设计一个支持数据库、NOSQL-和大数据之间数据实时流动的数据流及处理的系统，你会考虑哪些问题？如何设计？" class="headerlink" title="1.3.4 如果让你来设计一个支持数据库、NOSQL 和大数据之间数据实时流动的数据流及处理的系统，你会考虑哪些问题？如何设计？"></a>1.3.4 如果让你来设计一个支持数据库、NOSQL 和大数据之间数据实时流动的数据流及处理的系统，你会考虑哪些问题？如何设计？</h5><h5 id="1-3-5-给定一个整数数组和一个整数，返回两个数组的索引，这两个索引指向的数字的加和等于指定的整数。需要最优的算法，分析算法的空间和时间复杂度"><a href="#1-3-5-给定一个整数数组和一个整数，返回两个数组的索引，这两个索引指向的数字的加和等于指定的整数。需要最优的算法，分析算法的空间和时间复杂度" class="headerlink" title="1.3.5 给定一个整数数组和一个整数，返回两个数组的索引，这两个索引指向的数字的加和等于指定的整数。需要最优的算法，分析算法的空间和时间复杂度"></a>1.3.5 给定一个整数数组和一个整数，返回两个数组的索引，这两个索引指向的数字的加和等于指定的整数。需要最优的算法，分析算法的空间和时间复杂度</h5><h5 id="1-3-6-假如给你一个新产品，你将从哪些方面来保障它的质量？"><a href="#1-3-6-假如给你一个新产品，你将从哪些方面来保障它的质量？" class="headerlink" title="1.3.6 假如给你一个新产品，你将从哪些方面来保障它的质量？"></a>1.3.6 假如给你一个新产品，你将从哪些方面来保障它的质量？</h5><h5 id="1-3-7-请评估一下程序的执行结果？"><a href="#1-3-7-请评估一下程序的执行结果？" class="headerlink" title="1.3.7 请评估一下程序的执行结果？"></a>1.3.7 请评估一下程序的执行结果？</h5><br><h3 id="2">华为篇</h3> <hr><h5 id="2-1-0-static有什么用途？（请至少说明两种）"><a href="#2-1-0-static有什么用途？（请至少说明两种）" class="headerlink" title="2.1.0 static有什么用途？（请至少说明两种）"></a>2.1.0 static有什么用途？（请至少说明两种）</h5><h6 id="2-1-1-引用与指针有什么区别？"><a href="#2-1-1-引用与指针有什么区别？" class="headerlink" title="2.1.1 引用与指针有什么区别？"></a>2.1.1 引用与指针有什么区别？</h6><h5 id="2-1-2-描述实时系统的基本特性"><a href="#2-1-2-描述实时系统的基本特性" class="headerlink" title="2.1.2 描述实时系统的基本特性"></a>2.1.2 描述实时系统的基本特性</h5><h5 id="2-1-3-全局变量和局部变量在内存中是否有区别？如果有，是什么区别？"><a href="#2-1-3-全局变量和局部变量在内存中是否有区别？如果有，是什么区别？" class="headerlink" title="2.1.3 全局变量和局部变量在内存中是否有区别？如果有，是什么区别？"></a>2.1.3 全局变量和局部变量在内存中是否有区别？如果有，是什么区别？</h5><h5 id="2-1-4-什么是平衡二叉树？"><a href="#2-1-4-什么是平衡二叉树？" class="headerlink" title="2.1.4 什么是平衡二叉树？"></a>2.1.4 什么是平衡二叉树？</h5><h5 id="2-1-5-堆栈溢出一般是由什么原因导致的？"><a href="#2-1-5-堆栈溢出一般是由什么原因导致的？" class="headerlink" title="2.1.5 堆栈溢出一般是由什么原因导致的？"></a>2.1.5 堆栈溢出一般是由什么原因导致的？</h5><h5 id="2-1-6-什么函数不能声明为虚函数？"><a href="#2-1-6-什么函数不能声明为虚函数？" class="headerlink" title="2.1.6 什么函数不能声明为虚函数？"></a>2.1.6 什么函数不能声明为虚函数？</h5><h5 id="2-1-7-冒泡排序算法的时间复杂度是什么？"><a href="#2-1-7-冒泡排序算法的时间复杂度是什么？" class="headerlink" title="2.1.7 冒泡排序算法的时间复杂度是什么？"></a>2.1.7 冒泡排序算法的时间复杂度是什么？</h5><h5 id="2-1-8-写出float-x-与“零值”比较的if语句"><a href="#2-1-8-写出float-x-与“零值”比较的if语句" class="headerlink" title="2.1.8 写出float x 与“零值”比较的if语句"></a>2.1.8 写出float x 与“零值”比较的if语句</h5><h5 id="2-1-9-Internet采用哪种网络协议？该协议的主要层次结构？"><a href="#2-1-9-Internet采用哪种网络协议？该协议的主要层次结构？" class="headerlink" title="2.1.9 Internet采用哪种网络协议？该协议的主要层次结构？"></a>2.1.9 Internet采用哪种网络协议？该协议的主要层次结构？</h5><h5 id="2-2-0-Internet物理地址和IP地址转换采用什么协议？"><a href="#2-2-0-Internet物理地址和IP地址转换采用什么协议？" class="headerlink" title="2.2.0 Internet物理地址和IP地址转换采用什么协议？"></a>2.2.0 Internet物理地址和IP地址转换采用什么协议？</h5><h5 id="2-2-1-IP地址的编码分为哪俩部分？"><a href="#2-2-1-IP地址的编码分为哪俩部分？" class="headerlink" title="2.2.1 IP地址的编码分为哪俩部分？"></a>2.2.1 IP地址的编码分为哪俩部分？</h5><h5 id="2-2-2-用户输入M-N值，从1至N开始顺序循环数数，每数到M输出该数值，直至全部输出。写出C程序。"><a href="#2-2-2-用户输入M-N值，从1至N开始顺序循环数数，每数到M输出该数值，直至全部输出。写出C程序。" class="headerlink" title="2.2.2 用户输入M,N值，从1至N开始顺序循环数数，每数到M输出该数值，直至全部输出。写出C程序。"></a>2.2.2 用户输入M,N值，从1至N开始顺序循环数数，每数到M输出该数值，直至全部输出。写出C程序。</h5><h5 id="2-2-3-不能做switch-的参数类型是"><a href="#2-2-3-不能做switch-的参数类型是" class="headerlink" title="2.2.3 不能做switch()的参数类型是"></a>2.2.3 不能做switch()的参数类型是</h5><h5 id="2-2-4-int-A-nSize-，其中隐藏着若干0，其余非0整数，写一个函数int-Func-int-A-int-nSize-，使A把0移至后面，非0整数移至数组前面并保持有序，返回值为原数据中第一个元素为0的下标。"><a href="#2-2-4-int-A-nSize-，其中隐藏着若干0，其余非0整数，写一个函数int-Func-int-A-int-nSize-，使A把0移至后面，非0整数移至数组前面并保持有序，返回值为原数据中第一个元素为0的下标。" class="headerlink" title="2.2.4 int A[nSize]，其中隐藏着若干0，其余非0整数，写一个函数int Func(int* A, int nSize)，使A把0移至后面，非0整数移至数组前面并保持有序，返回值为原数据中第一个元素为0的下标。"></a>2.2.4 int A[nSize]，其中隐藏着若干0，其余非0整数，写一个函数int Func(int* A, int nSize)，使A把0移至后面，非0整数移至数组前面并保持有序，返回值为原数据中第一个元素为0的下标。</h5><h5 id="2-2-5-写一个程序-要求功能：求出用1，2，5这三个数不同个数组合的和为100的组合个数"><a href="#2-2-5-写一个程序-要求功能：求出用1，2，5这三个数不同个数组合的和为100的组合个数" class="headerlink" title="2.2.5 写一个程序, 要求功能：求出用1，2，5这三个数不同个数组合的和为100的组合个数"></a>2.2.5 写一个程序, 要求功能：求出用1，2，5这三个数不同个数组合的和为100的组合个数</h5><h5 id="2-2-6-实现一个函数，把一个字符串中的字符从小写转为大写"><a href="#2-2-6-实现一个函数，把一个字符串中的字符从小写转为大写" class="headerlink" title="2.2.6 实现一个函数，把一个字符串中的字符从小写转为大写"></a>2.2.6 实现一个函数，把一个字符串中的字符从小写转为大写</h5><h5 id="2-2-7-随机输入一个数，判断它是不是对称数（回文数）（如3，121，12321，45254）。不能用字符串库函数"><a href="#2-2-7-随机输入一个数，判断它是不是对称数（回文数）（如3，121，12321，45254）。不能用字符串库函数" class="headerlink" title="2.2.7 随机输入一个数，判断它是不是对称数（回文数）（如3，121，12321，45254）。不能用字符串库函数"></a>2.2.7 随机输入一个数，判断它是不是对称数（回文数）（如3，121，12321，45254）。不能用字符串库函数</h5><h5 id="2-2-8-求2-2000的所有素数-有足够的内存-要求尽量快"><a href="#2-2-8-求2-2000的所有素数-有足够的内存-要求尽量快" class="headerlink" title="2.2.8 求2~2000的所有素数.有足够的内存,要求尽量快"></a>2.2.8 求2~2000的所有素数.有足够的内存,要求尽量快</h5><h5 id="2-2-9-A-B-C-D四个进程，A向buf里面写数据，B-C-D向buf里面读数据，当A写完，且B，C，D都读一次后，A才能再写。用P，V操作实现。"><a href="#2-2-9-A-B-C-D四个进程，A向buf里面写数据，B-C-D向buf里面读数据，当A写完，且B，C，D都读一次后，A才能再写。用P，V操作实现。" class="headerlink" title="2.2.9 A,B,C,D四个进程，A向buf里面写数据，B,C,D向buf里面读数据，当A写完，且B，C，D都读一次后，A才能再写。用P，V操作实现。"></a>2.2.9 A,B,C,D四个进程，A向buf里面写数据，B,C,D向buf里面读数据，当A写完，且B，C，D都读一次后，A才能再写。用P，V操作实现。</h5><h5 id="2-3-0-将单向链表reverse，如ABCD变成DCBA，只能搜索链表一次。"><a href="#2-3-0-将单向链表reverse，如ABCD变成DCBA，只能搜索链表一次。" class="headerlink" title="2.3.0 将单向链表reverse，如ABCD变成DCBA，只能搜索链表一次。"></a>2.3.0 将单向链表reverse，如ABCD变成DCBA，只能搜索链表一次。</h5><h5 id="2-3-1-将二叉树的两个孩子换位置，即左变右，右变左。不能用递规。"><a href="#2-3-1-将二叉树的两个孩子换位置，即左变右，右变左。不能用递规。" class="headerlink" title="2.3.1 将二叉树的两个孩子换位置，即左变右，右变左。不能用递规。"></a>2.3.1 将二叉树的两个孩子换位置，即左变右，右变左。不能用递规。</h5><h5 id="2-3-2-以下属于物理层的设备是？"><a href="#2-3-2-以下属于物理层的设备是？" class="headerlink" title="2.3.2 以下属于物理层的设备是？"></a>2.3.2 以下属于物理层的设备是？</h5><h5 id="2-3-3-在以太网中，是根据（）地址来区分不同的设备的？"><a href="#2-3-3-在以太网中，是根据（）地址来区分不同的设备的？" class="headerlink" title="2.3.3 在以太网中，是根据（）地址来区分不同的设备的？"></a>2.3.3 在以太网中，是根据（）地址来区分不同的设备的？</h5><h5 id="2-3-4-以下为传输层协议的是？"><a href="#2-3-4-以下为传输层协议的是？" class="headerlink" title="2.3.4 以下为传输层协议的是？"></a>2.3.4 以下为传输层协议的是？</h5><h5 id="2-3-5-以下对MAC地址描述正确的是？"><a href="#2-3-5-以下对MAC地址描述正确的是？" class="headerlink" title="2.3.5 以下对MAC地址描述正确的是？"></a>2.3.5 以下对MAC地址描述正确的是？</h5><h5 id="2-3-6-以下属于数据链路层功能的是？"><a href="#2-3-6-以下属于数据链路层功能的是？" class="headerlink" title="2.3.6 以下属于数据链路层功能的是？"></a>2.3.6 以下属于数据链路层功能的是？</h5><h5 id="2-3-7-IEEE802-3u标准是指？"><a href="#2-3-7-IEEE802-3u标准是指？" class="headerlink" title="2.3.7 IEEE802.3u标准是指？"></a>2.3.7 IEEE802.3u标准是指？</h5><h5 id="2-3-8-如果要将两计算机通过双绞线直接连接，正确的线序是？"><a href="#2-3-8-如果要将两计算机通过双绞线直接连接，正确的线序是？" class="headerlink" title="2.3.8 如果要将两计算机通过双绞线直接连接，正确的线序是？"></a>2.3.8 如果要将两计算机通过双绞线直接连接，正确的线序是？</h5><h5 id="2-3-9-在V-35和V-24规程中，控制信号RTS表示？"><a href="#2-3-9-在V-35和V-24规程中，控制信号RTS表示？" class="headerlink" title="2.3.9 在V.35和V.24规程中，控制信号RTS表示？"></a>2.3.9 在V.35和V.24规程中，控制信号RTS表示？</h5><h5 id="2-4-0-路由器作为网络互连设备，必须具备以下哪些特点？"><a href="#2-4-0-路由器作为网络互连设备，必须具备以下哪些特点？" class="headerlink" title="2.4.0 路由器作为网络互连设备，必须具备以下哪些特点？"></a>2.4.0 路由器作为网络互连设备，必须具备以下哪些特点？</h5><h5 id="2-4-1-路由器的作用有？"><a href="#2-4-1-路由器的作用有？" class="headerlink" title="2.4.1 路由器的作用有？"></a>2.4.1 路由器的作用有？</h5><h5 id="2-4-2-调用上一条历史命令的快捷键是？"><a href="#2-4-2-调用上一条历史命令的快捷键是？" class="headerlink" title="2.4.2 调用上一条历史命令的快捷键是？"></a>2.4.2 调用上一条历史命令的快捷键是？</h5><h5 id="2-4-3-交换机工作在OSI七层的哪一层？"><a href="#2-4-3-交换机工作在OSI七层的哪一层？" class="headerlink" title="2.4.3 交换机工作在OSI七层的哪一层？"></a>2.4.3 交换机工作在OSI七层的哪一层？</h5><h5 id="2-4-4-以下对CSMA-CD描述正确的是？"><a href="#2-4-4-以下对CSMA-CD描述正确的是？" class="headerlink" title="2.4.4 以下对CSMA/CD描述正确的是？"></a>2.4.4 以下对CSMA/CD描述正确的是？</h5><h5 id="2-4-5-以下对STORE-ANDFORWARD描述正确的是？"><a href="#2-4-5-以下对STORE-ANDFORWARD描述正确的是？" class="headerlink" title="2.4.5 以下对STORE ANDFORWARD描述正确的是？"></a>2.4.5 以下对STORE ANDFORWARD描述正确的是？</h5><h5 id="2-4-6-以下对交换机工作方式描述正确的是？"><a href="#2-4-6-以下对交换机工作方式描述正确的是？" class="headerlink" title="2.4.6 以下对交换机工作方式描述正确的是？"></a>2.4.6 以下对交换机工作方式描述正确的是？</h5><h5 id="2-4-7-VLAN的主要作用有？"><a href="#2-4-7-VLAN的主要作用有？" class="headerlink" title="2.4.7 VLAN的主要作用有？"></a>2.4.7 VLAN的主要作用有？</h5><h5 id="2-4-8-在交换机中用户权限分为几个级别？"><a href="#2-4-8-在交换机中用户权限分为几个级别？" class="headerlink" title="2.4.8 在交换机中用户权限分为几个级别？"></a>2.4.8 在交换机中用户权限分为几个级别？</h5><h5 id="2-4-9-在路由器的配置过程中查询以S开头所有命令的方法是？"><a href="#2-4-9-在路由器的配置过程中查询以S开头所有命令的方法是？" class="headerlink" title="2.4.9 在路由器的配置过程中查询以S开头所有命令的方法是？"></a>2.4.9 在路由器的配置过程中查询以S开头所有命令的方法是？</h5><h5 id="2-5-0-第一次配置路由器时可以使用的方法为？"><a href="#2-5-0-第一次配置路由器时可以使用的方法为？" class="headerlink" title="2.5.0 第一次配置路由器时可以使用的方法为？"></a>2.5.0 第一次配置路由器时可以使用的方法为？</h5><h5 id="2-5-1-在何种状态下可以为路由器改名？"><a href="#2-5-1-在何种状态下可以为路由器改名？" class="headerlink" title="2.5.1 在何种状态下可以为路由器改名？"></a>2.5.1 在何种状态下可以为路由器改名？</h5><h5 id="2-5-2-某公司申请到一个C类IP地址，但要连接6个的子公司，最大的一个子公司有-26台计算机，每个子公司在一个网段中，则子网掩码应设为？"><a href="#2-5-2-某公司申请到一个C类IP地址，但要连接6个的子公司，最大的一个子公司有-26台计算机，每个子公司在一个网段中，则子网掩码应设为？" class="headerlink" title="2.5.2 某公司申请到一个C类IP地址，但要连接6个的子公司，最大的一个子公司有 26台计算机，每个子公司在一个网段中，则子网掩码应设为？"></a>2.5.2 某公司申请到一个C类IP地址，但要连接6个的子公司，最大的一个子公司有 26台计算机，每个子公司在一个网段中，则子网掩码应设为？</h5><h5 id="2-5-3-与10-110-12-29mask-255-255-255-224属于同一网段的主机IP地址是？"><a href="#2-5-3-与10-110-12-29mask-255-255-255-224属于同一网段的主机IP地址是？" class="headerlink" title="2.5.3 与10.110.12.29mask 255.255.255.224属于同一网段的主机IP地址是？"></a>2.5.3 与10.110.12.29mask 255.255.255.224属于同一网段的主机IP地址是？</h5><h5 id="2-5-4-ARP协议的作用是？"><a href="#2-5-4-ARP协议的作用是？" class="headerlink" title="2.5.4 ARP协议的作用是？"></a>2.5.4 ARP协议的作用是？</h5><h5 id="2-5-5-当路由器接收的IP报文的TTL值等于1时，采取的策略是？"><a href="#2-5-5-当路由器接收的IP报文的TTL值等于1时，采取的策略是？" class="headerlink" title="2.5.5 当路由器接收的IP报文的TTL值等于1时，采取的策略是？"></a>2.5.5 当路由器接收的IP报文的TTL值等于1时，采取的策略是？</h5><h5 id="2-5-6-在NetWare-网络中，客户需要访问某个类型的服务器时，首先要发送一个-（）广播报文来寻找服务器？"><a href="#2-5-6-在NetWare-网络中，客户需要访问某个类型的服务器时，首先要发送一个-（）广播报文来寻找服务器？" class="headerlink" title="2.5.6 在NetWare 网络中，客户需要访问某个类型的服务器时，首先要发送一个 （）广播报文来寻找服务器？"></a>2.5.6 在NetWare 网络中，客户需要访问某个类型的服务器时，首先要发送一个 （）广播报文来寻找服务器？</h5><h5 id="2-5-7-IPX地址网络地址有（-）个字节？"><a href="#2-5-7-IPX地址网络地址有（-）个字节？" class="headerlink" title="2.5.7 IPX地址网络地址有（ ）个字节？"></a>2.5.7 IPX地址网络地址有（ ）个字节？</h5><h5 id="2-5-8-对于帧中继描述正确的是？"><a href="#2-5-8-对于帧中继描述正确的是？" class="headerlink" title="2.5.8 对于帧中继描述正确的是？"></a>2.5.8 对于帧中继描述正确的是？</h5><h5 id="2-5-9-对于INVERSE-ARP的描述正确的是？"><a href="#2-5-9-对于INVERSE-ARP的描述正确的是？" class="headerlink" title="2.5.9 对于INVERSE ARP的描述正确的是？"></a>2.5.9 对于INVERSE ARP的描述正确的是？</h5><br><h3 id="3">百度篇</h3> <hr><h5 id="3-1-0-在函数内定义一个字符数组，用gets函数输入字符串的时候，如果输入越界，为什么程序会崩溃？"><a href="#3-1-0-在函数内定义一个字符数组，用gets函数输入字符串的时候，如果输入越界，为什么程序会崩溃？" class="headerlink" title="3.1.0 在函数内定义一个字符数组，用gets函数输入字符串的时候，如果输入越界，为什么程序会崩溃？"></a>3.1.0 在函数内定义一个字符数组，用gets函数输入字符串的时候，如果输入越界，为什么程序会崩溃？</h5><h5 id="3-1-1-C-中引用与指针的区别"><a href="#3-1-1-C-中引用与指针的区别" class="headerlink" title="3.1.1 C++中引用与指针的区别"></a>3.1.1 C++中引用与指针的区别</h5><h5 id="3-1-2-C-C-程序的内存分区"><a href="#3-1-2-C-C-程序的内存分区" class="headerlink" title="3.1.2 C/C++程序的内存分区"></a>3.1.2 C/C++程序的内存分区</h5><h5 id="3-1-3-快速排序的思想、时间复杂度、实现以及优化方法"><a href="#3-1-3-快速排序的思想、时间复杂度、实现以及优化方法" class="headerlink" title="3.1.3 快速排序的思想、时间复杂度、实现以及优化方法"></a>3.1.3 快速排序的思想、时间复杂度、实现以及优化方法</h5><h5 id="3-1-4-IO模型——IO多路复用机制"><a href="#3-1-4-IO模型——IO多路复用机制" class="headerlink" title="3.1.4 IO模型——IO多路复用机制?"></a>3.1.4 IO模型——IO多路复用机制?</h5><h5 id="3-1-5-常用的Linux命令"><a href="#3-1-5-常用的Linux命令" class="headerlink" title="3.1.5 常用的Linux命令"></a>3.1.5 常用的Linux命令</h5><h5 id="3-1-6-C中变量的存储类型有哪些？"><a href="#3-1-6-C中变量的存储类型有哪些？" class="headerlink" title="3.1.6 C中变量的存储类型有哪些？"></a>3.1.6 C中变量的存储类型有哪些？</h5><h5 id="3-1-7-动态规划的本质"><a href="#3-1-7-动态规划的本质" class="headerlink" title="3.1.7 动态规划的本质"></a>3.1.7 动态规划的本质</h5><h5 id="3-1-8-实践中如何优化MySQL"><a href="#3-1-8-实践中如何优化MySQL" class="headerlink" title="3.1.8 实践中如何优化MySQL?"></a>3.1.8 实践中如何优化MySQL?</h5><h5 id="3-1-9-什么情况下设置了索引但无法使用"><a href="#3-1-9-什么情况下设置了索引但无法使用" class="headerlink" title="3.1.9 什么情况下设置了索引但无法使用?"></a>3.1.9 什么情况下设置了索引但无法使用?</h5><h5 id="3-2-0-SQL语句的优化"><a href="#3-2-0-SQL语句的优化" class="headerlink" title="3.2.0 SQL语句的优化"></a>3.2.0 SQL语句的优化</h5><h5 id="3-2-1-数据库索引的底层实现原理和优化"><a href="#3-2-1-数据库索引的底层实现原理和优化" class="headerlink" title="3.2.1 数据库索引的底层实现原理和优化"></a>3.2.1 数据库索引的底层实现原理和优化</h5><h5 id="3-2-2-HTTP和HTTPS的主要区别"><a href="#3-2-2-HTTP和HTTPS的主要区别" class="headerlink" title="3.2.2 HTTP和HTTPS的主要区别?"></a>3.2.2 HTTP和HTTPS的主要区别?</h5><h5 id="3-2-3-如何设计一个高并发的系统"><a href="#3-2-3-如何设计一个高并发的系统" class="headerlink" title="3.2.3 如何设计一个高并发的系统?"></a>3.2.3 如何设计一个高并发的系统?</h5><h5 id="3-2-4-两条相交的单向链表，如何求他们的第一个公共节点"><a href="#3-2-4-两条相交的单向链表，如何求他们的第一个公共节点" class="headerlink" title="3.2.4 两条相交的单向链表，如何求他们的第一个公共节点?"></a>3.2.4 两条相交的单向链表，如何求他们的第一个公共节点?</h5><h5 id="3-2-5-求单向局部循环链表的环入口"><a href="#3-2-5-求单向局部循环链表的环入口" class="headerlink" title="3.2.5 求单向局部循环链表的环入口?"></a>3.2.5 求单向局部循环链表的环入口?</h5><h5 id="3-2-6-IP地址如何在数据库中存储"><a href="#3-2-6-IP地址如何在数据库中存储" class="headerlink" title="3.2.6 IP地址如何在数据库中存储?"></a>3.2.6 IP地址如何在数据库中存储?</h5><h5 id="3-2-7-new-delete和malloc-free的底层实现"><a href="#3-2-7-new-delete和malloc-free的底层实现" class="headerlink" title="3.2.7 new/delete和malloc/free的底层实现?"></a>3.2.7 new/delete和malloc/free的底层实现?</h5><h5 id="3-2-8-overload、override、overwrite的介绍"><a href="#3-2-8-overload、override、overwrite的介绍" class="headerlink" title="3.2.8 overload、override、overwrite的介绍?"></a>3.2.8 overload、override、overwrite的介绍?</h5><h5 id="3-2-9-小端-大端机器"><a href="#3-2-9-小端-大端机器" class="headerlink" title="3.2.9 小端/大端机器?"></a>3.2.9 小端/大端机器?</h5><h5 id="3-3-0-守护进程"><a href="#3-3-0-守护进程" class="headerlink" title="3.3.0 守护进程"></a>3.3.0 守护进程</h5><h5 id="3-3-1-多线程的优缺点"><a href="#3-3-1-多线程的优缺点" class="headerlink" title="3.3.1 多线程的优缺点"></a>3.3.1 多线程的优缺点</h5><h5 id="3-3-2-长连接与短连接"><a href="#3-3-2-长连接与短连接" class="headerlink" title="3.3.2 长连接与短连接"></a>3.3.2 长连接与短连接</h5><h5 id="3-3-3-二分图应用于最佳匹配问题（游客对房间的满意度之和最大问题）"><a href="#3-3-3-二分图应用于最佳匹配问题（游客对房间的满意度之和最大问题）" class="headerlink" title="3.3.3 二分图应用于最佳匹配问题（游客对房间的满意度之和最大问题）"></a>3.3.3 二分图应用于最佳匹配问题（游客对房间的满意度之和最大问题）</h5><h5 id="3-3-4-class与struct的区别？"><a href="#3-3-4-class与struct的区别？" class="headerlink" title="3.3.4 class与struct的区别？"></a>3.3.4 class与struct的区别？</h5><h5 id="3-3-5-虚函数和纯虚函数"><a href="#3-3-5-虚函数和纯虚函数" class="headerlink" title="3.3.5 虚函数和纯虚函数"></a>3.3.5 虚函数和纯虚函数</h5><h5 id="3-3-6-menset-函数"><a href="#3-3-6-menset-函数" class="headerlink" title="3.3.6 menset()函数"></a>3.3.6 menset()函数</h5><h5 id="3-3-7-实现一个函数，对一个正整数n，算得到1需要的最少操作次数。操作规则为：如果n为偶数，将其除以2；如果n为奇数，可以加1或减1；一直处理下去。"><a href="#3-3-7-实现一个函数，对一个正整数n，算得到1需要的最少操作次数。操作规则为：如果n为偶数，将其除以2；如果n为奇数，可以加1或减1；一直处理下去。" class="headerlink" title="3.3.7 实现一个函数，对一个正整数n，算得到1需要的最少操作次数。操作规则为：如果n为偶数，将其除以2；如果n为奇数，可以加1或减1；一直处理下去。"></a>3.3.7 实现一个函数，对一个正整数n，算得到1需要的最少操作次数。操作规则为：如果n为偶数，将其除以2；如果n为奇数，可以加1或减1；一直处理下去。</h5><h5 id="3-3-8-找到满足条件的数组"><a href="#3-3-8-找到满足条件的数组" class="headerlink" title="3.3.8 找到满足条件的数组"></a>3.3.8 找到满足条件的数组</h5><h5 id="3-3-9-一个大的含有50M个URL的记录，一个小的含有500个URL的记录，找出两个记录里相同的URL"><a href="#3-3-9-一个大的含有50M个URL的记录，一个小的含有500个URL的记录，找出两个记录里相同的URL" class="headerlink" title="3.3.9 一个大的含有50M个URL的记录，一个小的含有500个URL的记录，找出两个记录里相同的URL"></a>3.3.9 一个大的含有50M个URL的记录，一个小的含有500个URL的记录，找出两个记录里相同的URL</h5><h5 id="3-4-0-海量日志数据，提取出某日访问百度次数最多的那个IP"><a href="#3-4-0-海量日志数据，提取出某日访问百度次数最多的那个IP" class="headerlink" title="3.4.0 海量日志数据，提取出某日访问百度次数最多的那个IP"></a>3.4.0 海量日志数据，提取出某日访问百度次数最多的那个IP</h5><h5 id="3-4-1-有10个文件，每个文件1G，每个文件的每一行都存放的是用户的query，每个文件的query都可能重复。如何按照query的频度排序？"><a href="#3-4-1-有10个文件，每个文件1G，每个文件的每一行都存放的是用户的query，每个文件的query都可能重复。如何按照query的频度排序？" class="headerlink" title="3.4.1 有10个文件，每个文件1G，每个文件的每一行都存放的是用户的query，每个文件的query都可能重复。如何按照query的频度排序？"></a>3.4.1 有10个文件，每个文件1G，每个文件的每一行都存放的是用户的query，每个文件的query都可能重复。如何按照query的频度排序？</h5><h5 id="3-4-2-蚂蚁爬杆问题"><a href="#3-4-2-蚂蚁爬杆问题" class="headerlink" title="3.4.2 蚂蚁爬杆问题"></a>3.4.2 蚂蚁爬杆问题</h5><h5 id="3-4-3-当在浏览器中输入一个url后回车，后台发生了什么？比如输入url后，你看到了百度的首页，那么这一切是如何发生的呢？"><a href="#3-4-3-当在浏览器中输入一个url后回车，后台发生了什么？比如输入url后，你看到了百度的首页，那么这一切是如何发生的呢？" class="headerlink" title="3.4.3 当在浏览器中输入一个url后回车，后台发生了什么？比如输入url后，你看到了百度的首页，那么这一切是如何发生的呢？"></a>3.4.3 当在浏览器中输入一个url后回车，后台发生了什么？比如输入url后，你看到了百度的首页，那么这一切是如何发生的呢？</h5><h5 id="3-4-4-判断两棵树是否相等，请实现两棵树是否相等的比较，相等返回1，否则返回其他值，并说明算法复杂度"><a href="#3-4-4-判断两棵树是否相等，请实现两棵树是否相等的比较，相等返回1，否则返回其他值，并说明算法复杂度" class="headerlink" title="3.4.4 判断两棵树是否相等，请实现两棵树是否相等的比较，相等返回1，否则返回其他值，并说明算法复杂度"></a>3.4.4 判断两棵树是否相等，请实现两棵树是否相等的比较，相等返回1，否则返回其他值，并说明算法复杂度</h5><h5 id="3-4-5-三个警察和三个囚徒的过河问题"><a href="#3-4-5-三个警察和三个囚徒的过河问题" class="headerlink" title="3.4.5 三个警察和三个囚徒的过河问题"></a>3.4.5 三个警察和三个囚徒的过河问题</h5><h5 id="3-4-6-从300万字符串中找到最热门的10条"><a href="#3-4-6-从300万字符串中找到最热门的10条" class="headerlink" title="3.4.6 从300万字符串中找到最热门的10条"></a>3.4.6 从300万字符串中找到最热门的10条</h5><h5 id="3-4-7-如何找出字典中的兄弟单词。给定一个单词a，如果通过交换单词中字母的顺序可以得到另外的单词b，那么定义b是a的兄弟单词。现在给定一个字典，用户输入一个单词，如何根据字典找出这个单词有多少个兄弟单词？"><a href="#3-4-7-如何找出字典中的兄弟单词。给定一个单词a，如果通过交换单词中字母的顺序可以得到另外的单词b，那么定义b是a的兄弟单词。现在给定一个字典，用户输入一个单词，如何根据字典找出这个单词有多少个兄弟单词？" class="headerlink" title="3.4.7 如何找出字典中的兄弟单词。给定一个单词a，如果通过交换单词中字母的顺序可以得到另外的单词b，那么定义b是a的兄弟单词。现在给定一个字典，用户输入一个单词，如何根据字典找出这个单词有多少个兄弟单词？"></a>3.4.7 如何找出字典中的兄弟单词。给定一个单词a，如果通过交换单词中字母的顺序可以得到另外的单词b，那么定义b是a的兄弟单词。现在给定一个字典，用户输入一个单词，如何根据字典找出这个单词有多少个兄弟单词？</h5><h5 id="3-4-8-找出数组中出现次数超过一半的数，现在有一个数组，已知一个数出现的次数超过了一半，请用O-n-的复杂度的算法找出这个数。"><a href="#3-4-8-找出数组中出现次数超过一半的数，现在有一个数组，已知一个数出现的次数超过了一半，请用O-n-的复杂度的算法找出这个数。" class="headerlink" title="3.4.8 找出数组中出现次数超过一半的数，现在有一个数组，已知一个数出现的次数超过了一半，请用O(n)的复杂度的算法找出这个数。"></a>3.4.8 找出数组中出现次数超过一半的数，现在有一个数组，已知一个数出现的次数超过了一半，请用O(n)的复杂度的算法找出这个数。</h5><h5 id="3-4-9-找出被修改过的数字"><a href="#3-4-9-找出被修改过的数字" class="headerlink" title="3.4.9 找出被修改过的数字"></a>3.4.9 找出被修改过的数字</h5><h5 id="3-5-0-设计DNS服务器中cache的数据结构。要求设计一个DNS的Cache结构，要求能够满足每秒5000以上的查询，满足IP数据的快速插入，查询的速度要快。（题目还给出了一系列的数据，比如：站点数总共为5000万，IP地址有1000万，等等）"><a href="#3-5-0-设计DNS服务器中cache的数据结构。要求设计一个DNS的Cache结构，要求能够满足每秒5000以上的查询，满足IP数据的快速插入，查询的速度要快。（题目还给出了一系列的数据，比如：站点数总共为5000万，IP地址有1000万，等等）" class="headerlink" title="3.5.0 设计DNS服务器中cache的数据结构。要求设计一个DNS的Cache结构，要求能够满足每秒5000以上的查询，满足IP数据的快速插入，查询的速度要快。（题目还给出了一系列的数据，比如：站点数总共为5000万，IP地址有1000万，等等）"></a>3.5.0 设计DNS服务器中cache的数据结构。要求设计一个DNS的Cache结构，要求能够满足每秒5000以上的查询，满足IP数据的快速插入，查询的速度要快。（题目还给出了一系列的数据，比如：站点数总共为5000万，IP地址有1000万，等等）</h5><h5 id="3-5-1-找出给定字符串对应的序号"><a href="#3-5-1-找出给定字符串对应的序号" class="headerlink" title="3.5.1 找出给定字符串对应的序号"></a>3.5.1 找出给定字符串对应的序号</h5><h5 id="3-5-2-找出第k大的数字所在的位置。写一段程序，找出数组中第k大小的数，输出数所在的位置。例如-2，4，3，4，7-中，第一大的数是7，位置在4。第二大、第三大的数都是4，位置在1、3随便输出哪一个均可。"><a href="#3-5-2-找出第k大的数字所在的位置。写一段程序，找出数组中第k大小的数，输出数所在的位置。例如-2，4，3，4，7-中，第一大的数是7，位置在4。第二大、第三大的数都是4，位置在1、3随便输出哪一个均可。" class="headerlink" title="3.5.2 找出第k大的数字所在的位置。写一段程序，找出数组中第k大小的数，输出数所在的位置。例如{2，4，3，4，7}中，第一大的数是7，位置在4。第二大、第三大的数都是4，位置在1、3随便输出哪一个均可。"></a>3.5.2 找出第k大的数字所在的位置。写一段程序，找出数组中第k大小的数，输出数所在的位置。例如{2，4，3，4，7}中，第一大的数是7，位置在4。第二大、第三大的数都是4，位置在1、3随便输出哪一个均可。</h5><h5 id="3-5-3-给40亿个不重复的unsigned-int的整数，没排过序的，然后再给几个数，如何快速判断这几个数是否在那40亿个数当中"><a href="#3-5-3-给40亿个不重复的unsigned-int的整数，没排过序的，然后再给几个数，如何快速判断这几个数是否在那40亿个数当中" class="headerlink" title="3.5.3 给40亿个不重复的unsigned int的整数，没排过序的，然后再给几个数，如何快速判断这几个数是否在那40亿个数当中?"></a>3.5.3 给40亿个不重复的unsigned int的整数，没排过序的，然后再给几个数，如何快速判断这几个数是否在那40亿个数当中?</h5><h5 id="3-5-4-在一个文件中有10G个整数，乱序排列，要求找出中位数。内存限制为2G。"><a href="#3-5-4-在一个文件中有10G个整数，乱序排列，要求找出中位数。内存限制为2G。" class="headerlink" title="3.5.4 在一个文件中有10G个整数，乱序排列，要求找出中位数。内存限制为2G。"></a>3.5.4 在一个文件中有10G个整数，乱序排列，要求找出中位数。内存限制为2G。</h5><h5 id="3-5-5-时分秒针在一天之类重合多少次？（24小时）"><a href="#3-5-5-时分秒针在一天之类重合多少次？（24小时）" class="headerlink" title="3.5.5 时分秒针在一天之类重合多少次？（24小时）"></a>3.5.5 时分秒针在一天之类重合多少次？（24小时）</h5><h5 id="3-5-6-将多个集合合并成没有交集的集合。"><a href="#3-5-6-将多个集合合并成没有交集的集合。" class="headerlink" title="3.5.6 将多个集合合并成没有交集的集合。"></a>3.5.6 将多个集合合并成没有交集的集合。</h5><h5 id="3-5-7-平面内有11个点，由它们连成48条不同的直线，由这些点可连成多少个三角形？"><a href="#3-5-7-平面内有11个点，由它们连成48条不同的直线，由这些点可连成多少个三角形？" class="headerlink" title="3.5.7 平面内有11个点，由它们连成48条不同的直线，由这些点可连成多少个三角形？"></a>3.5.7 平面内有11个点，由它们连成48条不同的直线，由这些点可连成多少个三角形？</h5><br><h3 id="4">腾讯篇</h3><hr><h4 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h4><h5 id="4-1-0-JAVA中的几种基本数据类型是什么，各自占用多少字节。"><a href="#4-1-0-JAVA中的几种基本数据类型是什么，各自占用多少字节。" class="headerlink" title="4.1.0 JAVA中的几种基本数据类型是什么，各自占用多少字节。"></a>4.1.0 JAVA中的几种基本数据类型是什么，各自占用多少字节。</h5><h5 id="4-1-1-String类能被继承吗，为什么。"><a href="#4-1-1-String类能被继承吗，为什么。" class="headerlink" title="4.1.1 String类能被继承吗，为什么。"></a>4.1.1 String类能被继承吗，为什么。</h5><h5 id="4-1-2-String，Stringbuffer，StringBuilder的区别。"><a href="#4-1-2-String，Stringbuffer，StringBuilder的区别。" class="headerlink" title="4.1.2 String，Stringbuffer，StringBuilder的区别。"></a>4.1.2 String，Stringbuffer，StringBuilder的区别。</h5><h5 id="4-1-3-ArrayList和LinkedList有什么区别。"><a href="#4-1-3-ArrayList和LinkedList有什么区别。" class="headerlink" title="4.1.3 ArrayList和LinkedList有什么区别。"></a>4.1.3 ArrayList和LinkedList有什么区别。</h5><h5 id="4-1-4-讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。"><a href="#4-1-4-讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。" class="headerlink" title="4.1.4 讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。"></a>4.1.4 讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。</h5><h5 id="4-1-5-用过哪些Map类，都有什么区别，HashMap是线程安全的吗-并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。"><a href="#4-1-5-用过哪些Map类，都有什么区别，HashMap是线程安全的吗-并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。" class="headerlink" title="4.1.5 用过哪些Map类，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。"></a>4.1.5 用过哪些Map类，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。</h5><h5 id="4-1-6-JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。"><a href="#4-1-6-JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。" class="headerlink" title="4.1.6 JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。"></a>4.1.6 JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。</h5><h5 id="4-1-7-有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。"><a href="#4-1-7-有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。" class="headerlink" title="4.1.7 有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。"></a>4.1.7 有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。</h5><h5 id="4-1-8-抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么-类可以实现多个接口么。"><a href="#4-1-8-抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么-类可以实现多个接口么。" class="headerlink" title="4.1.8 抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么。"></a>4.1.8 抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么。</h5><h5 id="4-1-9-继承和聚合的区别在哪。"><a href="#4-1-9-继承和聚合的区别在哪。" class="headerlink" title="4.1.9 继承和聚合的区别在哪。"></a>4.1.9 继承和聚合的区别在哪。</h5><h5 id="4-2-0-IO模型有哪些，讲讲你理解的nio-，他和bio，aio的区别是啥，谈谈reactor模型。"><a href="#4-2-0-IO模型有哪些，讲讲你理解的nio-，他和bio，aio的区别是啥，谈谈reactor模型。" class="headerlink" title="4.2.0 IO模型有哪些，讲讲你理解的nio ，他和bio，aio的区别是啥，谈谈reactor模型。"></a>4.2.0 IO模型有哪些，讲讲你理解的nio ，他和bio，aio的区别是啥，谈谈reactor模型。</h5><h5 id="4-2-1-反射的原理，反射创建类实例的三种方式是什么。"><a href="#4-2-1-反射的原理，反射创建类实例的三种方式是什么。" class="headerlink" title="4.2.1 反射的原理，反射创建类实例的三种方式是什么。"></a>4.2.1 反射的原理，反射创建类实例的三种方式是什么。</h5><h5 id="4-2-2-反射中，Class-forName和ClassLoader区别-。"><a href="#4-2-2-反射中，Class-forName和ClassLoader区别-。" class="headerlink" title="4.2.2 反射中，Class.forName和ClassLoader区别 。"></a>4.2.2 反射中，Class.forName和ClassLoader区别 。</h5><h5 id="4-2-3-描述动态代理的几种实现方式，分别说出相应的优缺点。"><a href="#4-2-3-描述动态代理的几种实现方式，分别说出相应的优缺点。" class="headerlink" title="4.2.3 描述动态代理的几种实现方式，分别说出相应的优缺点。"></a>4.2.3 描述动态代理的几种实现方式，分别说出相应的优缺点。</h5><h5 id="4-2-4-动态代理与cglib实现的区别。"><a href="#4-2-4-动态代理与cglib实现的区别。" class="headerlink" title="4.2.4 动态代理与cglib实现的区别。"></a>4.2.4 动态代理与cglib实现的区别。</h5><h5 id="4-2-5-为什么CGlib方式可以对接口实现代理。"><a href="#4-2-5-为什么CGlib方式可以对接口实现代理。" class="headerlink" title="4.2.5 为什么CGlib方式可以对接口实现代理。"></a>4.2.5 为什么CGlib方式可以对接口实现代理。</h5><h5 id="4-2-6-final的用途。"><a href="#4-2-6-final的用途。" class="headerlink" title="4.2.6 final的用途。"></a>4.2.6 final的用途。</h5><h5 id="4-2-7-写出三种单例模式实现-。"><a href="#4-2-7-写出三种单例模式实现-。" class="headerlink" title="4.2.7 写出三种单例模式实现 。"></a>4.2.7 写出三种单例模式实现 。</h5><h5 id="4-2-8-如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。"><a href="#4-2-8-如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。" class="headerlink" title="4.2.8 如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。"></a>4.2.8 如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。</h5><h5 id="4-2-9-请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。"><a href="#4-2-9-请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。" class="headerlink" title="4.2.9 请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。"></a>4.2.9 请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。</h5><h5 id="4-3-0-深拷贝和浅拷贝区别。"><a href="#4-3-0-深拷贝和浅拷贝区别。" class="headerlink" title="4.3.0 深拷贝和浅拷贝区别。"></a>4.3.0 深拷贝和浅拷贝区别。</h5><h5 id="4-3-1-数组和链表数据结构描述，各自的时间复杂度。"><a href="#4-3-1-数组和链表数据结构描述，各自的时间复杂度。" class="headerlink" title="4.3.1 数组和链表数据结构描述，各自的时间复杂度。"></a>4.3.1 数组和链表数据结构描述，各自的时间复杂度。</h5><h5 id="4-3-2-error和exception的区别，CheckedException，RuntimeException的区别。"><a href="#4-3-2-error和exception的区别，CheckedException，RuntimeException的区别。" class="headerlink" title="4.3.2 error和exception的区别，CheckedException，RuntimeException的区别。"></a>4.3.2 error和exception的区别，CheckedException，RuntimeException的区别。</h5><h5 id="4-3-3-请列出5个运行时异常。"><a href="#4-3-3-请列出5个运行时异常。" class="headerlink" title="4.3.3 请列出5个运行时异常。"></a>4.3.3 请列出5个运行时异常。</h5><h5 id="4-3-4-在自己的代码中，如果创建一个java-lang-String类，这个类是否可以被类加载器加载？为什么。"><a href="#4-3-4-在自己的代码中，如果创建一个java-lang-String类，这个类是否可以被类加载器加载？为什么。" class="headerlink" title="4.3.4 在自己的代码中，如果创建一个java.lang.String类，这个类是否可以被类加载器加载？为什么。"></a>4.3.4 在自己的代码中，如果创建一个java.lang.String类，这个类是否可以被类加载器加载？为什么。</h5><h5 id="4-3-5-说一说你对java-lang-Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。"><a href="#4-3-5-说一说你对java-lang-Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。" class="headerlink" title="4.3.5 说一说你对java.lang.Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。"></a>4.3.5 说一说你对java.lang.Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。</h5><h5 id="4-3-6-在jdk1-5中，引入了泛型，泛型的存在是用来解决什么问题。"><a href="#4-3-6-在jdk1-5中，引入了泛型，泛型的存在是用来解决什么问题。" class="headerlink" title="4.3.6 在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题。"></a>4.3.6 在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题。</h5><h5 id="4-3-7-这样的a-hashcode-有什么用，与a-equals-b-有什么关系。"><a href="#4-3-7-这样的a-hashcode-有什么用，与a-equals-b-有什么关系。" class="headerlink" title="4.3.7 这样的a.hashcode() 有什么用，与a.equals(b)有什么关系。"></a>4.3.7 这样的a.hashcode() 有什么用，与a.equals(b)有什么关系。</h5><h5 id="4-3-8-有没有可能2个不相等的对象有相同的hashcode。"><a href="#4-3-8-有没有可能2个不相等的对象有相同的hashcode。" class="headerlink" title="4.3.8 有没有可能2个不相等的对象有相同的hashcode。"></a>4.3.8 有没有可能2个不相等的对象有相同的hashcode。</h5><h5 id="4-3-9-Java中的HashSet内部是如何工作的。"><a href="#4-3-9-Java中的HashSet内部是如何工作的。" class="headerlink" title="4.3.9 Java中的HashSet内部是如何工作的。"></a>4.3.9 Java中的HashSet内部是如何工作的。</h5><h5 id="4-4-0-什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。"><a href="#4-4-0-什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。" class="headerlink" title="4.4.0 什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。"></a>4.4.0 什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。</h5><h5 id="4-4-1-java8的新特性。"><a href="#4-4-1-java8的新特性。" class="headerlink" title="4.4.1 java8的新特性。"></a>4.4.1 java8的新特性。</h5><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><h5 id="4-4-2-什么情况下会发生栈内存溢出。"><a href="#4-4-2-什么情况下会发生栈内存溢出。" class="headerlink" title="4.4.2 什么情况下会发生栈内存溢出。"></a>4.4.2 什么情况下会发生栈内存溢出。</h5><h5 id="4-4-3-JVM的内存结构，Eden和Survivor比例。"><a href="#4-4-3-JVM的内存结构，Eden和Survivor比例。" class="headerlink" title="4.4.3 JVM的内存结构，Eden和Survivor比例。"></a>4.4.3 JVM的内存结构，Eden和Survivor比例。</h5><h5 id="4-4-4-JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。"><a href="#4-4-4-JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。" class="headerlink" title="4.4.4 JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。"></a>4.4.4 JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。</h5><h5 id="4-4-5-JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。"><a href="#4-4-5-JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。" class="headerlink" title="4.4.5 JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。"></a>4.4.5 JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。</h5><h5 id="4-4-6-你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。"><a href="#4-4-6-你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。" class="headerlink" title="4.4.6 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。"></a>4.4.6 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。</h5><h5 id="4-4-7-垃圾回收算法的实现原理。"><a href="#4-4-7-垃圾回收算法的实现原理。" class="headerlink" title="4.4.7 垃圾回收算法的实现原理。"></a>4.4.7 垃圾回收算法的实现原理。</h5><h5 id="4-4-8-当出现了内存溢出，你怎么排错。"><a href="#4-4-8-当出现了内存溢出，你怎么排错。" class="headerlink" title="4.4.8 当出现了内存溢出，你怎么排错。"></a>4.4.8 当出现了内存溢出，你怎么排错。</h5><h5 id="4-4-9-JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。"><a href="#4-4-9-JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。" class="headerlink" title="4.4.9 JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。"></a>4.4.9 JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。</h5><h5 id="4-5-0-简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。"><a href="#4-5-0-简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。" class="headerlink" title="4.5.0 简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。"></a>4.5.0 简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。</h5><h5 id="4-5-1-讲讲JAVA的反射机制。"><a href="#4-5-1-讲讲JAVA的反射机制。" class="headerlink" title="4.5.1 讲讲JAVA的反射机制。"></a>4.5.1 讲讲JAVA的反射机制。</h5><h5 id="4-5-2-你们线上应用的JVM参数有哪些。"><a href="#4-5-2-你们线上应用的JVM参数有哪些。" class="headerlink" title="4.5.2 你们线上应用的JVM参数有哪些。"></a>4.5.2 你们线上应用的JVM参数有哪些。</h5><h5 id="4-5-3-g1和cms区别-吞吐量优先和响应优先的垃圾收集器选择。"><a href="#4-5-3-g1和cms区别-吞吐量优先和响应优先的垃圾收集器选择。" class="headerlink" title="4.5.3 g1和cms区别,吞吐量优先和响应优先的垃圾收集器选择。"></a>4.5.3 g1和cms区别,吞吐量优先和响应优先的垃圾收集器选择。</h5><h5 id="4-5-4-怎么打出线程栈信息。"><a href="#4-5-4-怎么打出线程栈信息。" class="headerlink" title="4.5.4 怎么打出线程栈信息。"></a>4.5.4 怎么打出线程栈信息。</h5><h4 id="开源框架"><a href="#开源框架" class="headerlink" title="开源框架"></a>开源框架</h4><h5 id="4-5-5-简单讲讲tomcat结构，以及其类加载器流程，线程模型等。"><a href="#4-5-5-简单讲讲tomcat结构，以及其类加载器流程，线程模型等。" class="headerlink" title="4.5.5 简单讲讲tomcat结构，以及其类加载器流程，线程模型等。"></a>4.5.5 简单讲讲tomcat结构，以及其类加载器流程，线程模型等。</h5><h5 id="4-5-6-tomcat如何调优，涉及哪些参数-。"><a href="#4-5-6-tomcat如何调优，涉及哪些参数-。" class="headerlink" title="4.5.6 tomcat如何调优，涉及哪些参数 。"></a>4.5.6 tomcat如何调优，涉及哪些参数 。</h5><h5 id="4-5-7-讲讲Spring加载流程。"><a href="#4-5-7-讲讲Spring加载流程。" class="headerlink" title="4.5.7 讲讲Spring加载流程。"></a>4.5.7 讲讲Spring加载流程。</h5><h5 id="4-5-8-Spring-AOP的实现原理。"><a href="#4-5-8-Spring-AOP的实现原理。" class="headerlink" title="4.5.8 Spring AOP的实现原理。"></a>4.5.8 Spring AOP的实现原理。</h5><h5 id="4-5-9-讲讲Spring事务的传播属性。"><a href="#4-5-9-讲讲Spring事务的传播属性。" class="headerlink" title="4.5.9 讲讲Spring事务的传播属性。"></a>4.5.9 讲讲Spring事务的传播属性。</h5><h5 id="4-6-0-Spring如何管理事务的。"><a href="#4-6-0-Spring如何管理事务的。" class="headerlink" title="4.6.0 Spring如何管理事务的。"></a>4.6.0 Spring如何管理事务的。</h5><h5 id="4-6-1-Spring怎么配置事务（具体说出一些关键的xml-元素）。"><a href="#4-6-1-Spring怎么配置事务（具体说出一些关键的xml-元素）。" class="headerlink" title="4.6.1 Spring怎么配置事务（具体说出一些关键的xml 元素）。"></a>4.6.1 Spring怎么配置事务（具体说出一些关键的xml 元素）。</h5><h5 id="4-6-2-说说你对Spring的理解，非单例注入的原理？它的生命周期？循环注入的原理，aop的实现原理，说说aop中的几个术语，它们是怎么相互工作的。"><a href="#4-6-2-说说你对Spring的理解，非单例注入的原理？它的生命周期？循环注入的原理，aop的实现原理，说说aop中的几个术语，它们是怎么相互工作的。" class="headerlink" title="4.6.2 说说你对Spring的理解，非单例注入的原理？它的生命周期？循环注入的原理，aop的实现原理，说说aop中的几个术语，它们是怎么相互工作的。"></a>4.6.2 说说你对Spring的理解，非单例注入的原理？它的生命周期？循环注入的原理，aop的实现原理，说说aop中的几个术语，它们是怎么相互工作的。</h5><h5 id="4-6-3-Springmvc-中DispatcherServlet初始化过程。"><a href="#4-6-3-Springmvc-中DispatcherServlet初始化过程。" class="headerlink" title="4.6.3 Springmvc 中DispatcherServlet初始化过程。"></a>4.6.3 Springmvc 中DispatcherServlet初始化过程。</h5><h5 id="4-6-4-netty的线程模型，netty如何基于reactor模型上实现的。"><a href="#4-6-4-netty的线程模型，netty如何基于reactor模型上实现的。" class="headerlink" title="4.6.4 netty的线程模型，netty如何基于reactor模型上实现的。"></a>4.6.4 netty的线程模型，netty如何基于reactor模型上实现的。</h5><h5 id="4-6-5-为什么选择netty。"><a href="#4-6-5-为什么选择netty。" class="headerlink" title="4.6.5 为什么选择netty。"></a>4.6.5 为什么选择netty。</h5><h5 id="4-6-6-什么是TCP粘包，拆包。解决方式是什么。"><a href="#4-6-6-什么是TCP粘包，拆包。解决方式是什么。" class="headerlink" title="4.6.6 什么是TCP粘包，拆包。解决方式是什么。"></a>4.6.6 什么是TCP粘包，拆包。解决方式是什么。</h5><h5 id="4-6-7-netty的fashwheeltimer的用法，实现原理，是否出现过调用不够准时，怎么解决。"><a href="#4-6-7-netty的fashwheeltimer的用法，实现原理，是否出现过调用不够准时，怎么解决。" class="headerlink" title="4.6.7 netty的fashwheeltimer的用法，实现原理，是否出现过调用不够准时，怎么解决。"></a>4.6.7 netty的fashwheeltimer的用法，实现原理，是否出现过调用不够准时，怎么解决。</h5><h5 id="4-6-8-netty的心跳处理在弱网下怎么办。"><a href="#4-6-8-netty的心跳处理在弱网下怎么办。" class="headerlink" title="4.6.8 netty的心跳处理在弱网下怎么办。"></a>4.6.8 netty的心跳处理在弱网下怎么办。</h5><h5 id="4-6-9-netty的通讯协议是什么样的。"><a href="#4-6-9-netty的通讯协议是什么样的。" class="headerlink" title="4.6.9 netty的通讯协议是什么样的。"></a>4.6.9 netty的通讯协议是什么样的。</h5><h5 id="4-7-0-springmvc用到的注解，作用是什么，原理。"><a href="#4-7-0-springmvc用到的注解，作用是什么，原理。" class="headerlink" title="4.7.0 springmvc用到的注解，作用是什么，原理。"></a>4.7.0 springmvc用到的注解，作用是什么，原理。</h5><h5 id="4-7-1-springboot启动机制。"><a href="#4-7-1-springboot启动机制。" class="headerlink" title="4.7.1 springboot启动机制。"></a>4.7.1 springboot启动机制。</h5><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><h5 id="4-7-2-Linux系统下你关注过哪些内核参数，说说你知道的。"><a href="#4-7-2-Linux系统下你关注过哪些内核参数，说说你知道的。" class="headerlink" title="4.7.2 Linux系统下你关注过哪些内核参数，说说你知道的。"></a>4.7.2 Linux系统下你关注过哪些内核参数，说说你知道的。</h5><h5 id="4-7-3-Linux下IO模型有几种，各自的含义是什么。"><a href="#4-7-3-Linux下IO模型有几种，各自的含义是什么。" class="headerlink" title="4.7.3 Linux下IO模型有几种，各自的含义是什么。"></a>4.7.3 Linux下IO模型有几种，各自的含义是什么。</h5><h5 id="4-7-4-epoll和poll有什么区别。"><a href="#4-7-4-epoll和poll有什么区别。" class="headerlink" title="4.7.4 epoll和poll有什么区别。"></a>4.7.4 epoll和poll有什么区别。</h5><h5 id="4-7-5-平时用到哪些Linux命令。"><a href="#4-7-5-平时用到哪些Linux命令。" class="headerlink" title="4.7.5 平时用到哪些Linux命令。"></a>4.7.5 平时用到哪些Linux命令。</h5><h5 id="4-7-6-用一行命令查看文件的最后五行。"><a href="#4-7-6-用一行命令查看文件的最后五行。" class="headerlink" title="4.7.6 用一行命令查看文件的最后五行。"></a>4.7.6 用一行命令查看文件的最后五行。</h5><h5 id="4-7-7-用一行命令输出正在运行的java进程。"><a href="#4-7-7-用一行命令输出正在运行的java进程。" class="headerlink" title="4.7.7 用一行命令输出正在运行的java进程。"></a>4.7.7 用一行命令输出正在运行的java进程。</h5><h5 id="4-7-8-介绍下你理解的操作系统中线程切换过程。"><a href="#4-7-8-介绍下你理解的操作系统中线程切换过程。" class="headerlink" title="4.7.8 介绍下你理解的操作系统中线程切换过程。"></a>4.7.8 介绍下你理解的操作系统中线程切换过程。</h5><h5 id="4-7-9-进程和线程的区别。"><a href="#4-7-9-进程和线程的区别。" class="headerlink" title="4.7.9 进程和线程的区别。"></a>4.7.9 进程和线程的区别。</h5><h5 id="4-8-0-top-命令之后有哪些内容，有什么作用。"><a href="#4-8-0-top-命令之后有哪些内容，有什么作用。" class="headerlink" title="4.8.0 top 命令之后有哪些内容，有什么作用。"></a>4.8.0 top 命令之后有哪些内容，有什么作用。</h5><h5 id="4-8-1-线上CPU爆高，请问你如何找到问题所在。"><a href="#4-8-1-线上CPU爆高，请问你如何找到问题所在。" class="headerlink" title="4.8.1 线上CPU爆高，请问你如何找到问题所在。"></a>4.8.1 线上CPU爆高，请问你如何找到问题所在。</h5><br><h3 id="5">美团篇</h3><hr><h5 id="5-1-0-java虚拟机内存模型"><a href="#5-1-0-java虚拟机内存模型" class="headerlink" title="5.1.0 java虚拟机内存模型"></a>5.1.0 java虚拟机内存模型</h5><h5 id="5-1-1-内存溢出一般发生在哪个区？永久代会不会导致内存溢出？"><a href="#5-1-1-内存溢出一般发生在哪个区？永久代会不会导致内存溢出？" class="headerlink" title="5.1.1 内存溢出一般发生在哪个区？永久代会不会导致内存溢出？"></a>5.1.1 内存溢出一般发生在哪个区？永久代会不会导致内存溢出？</h5><h5 id="5-1-2-动态加载类的框架了解哪些？"><a href="#5-1-2-动态加载类的框架了解哪些？" class="headerlink" title="5.1.2 动态加载类的框架了解哪些？"></a>5.1.2 动态加载类的框架了解哪些？</h5><h5 id="5-1-3-动态代理一般有哪几种实现方式？动态代理的应用场景有哪些？"><a href="#5-1-3-动态代理一般有哪几种实现方式？动态代理的应用场景有哪些？" class="headerlink" title="5.1.3 动态代理一般有哪几种实现方式？动态代理的应用场景有哪些？"></a>5.1.3 动态代理一般有哪几种实现方式？动态代理的应用场景有哪些？</h5><h5 id="5-1-4-栈会不会溢出？栈溢出一般抛什么异常？jvm在哪里设置栈的大小？设置的参数是什么？"><a href="#5-1-4-栈会不会溢出？栈溢出一般抛什么异常？jvm在哪里设置栈的大小？设置的参数是什么？" class="headerlink" title="5.1.4 栈会不会溢出？栈溢出一般抛什么异常？jvm在哪里设置栈的大小？设置的参数是什么？"></a>5.1.4 栈会不会溢出？栈溢出一般抛什么异常？jvm在哪里设置栈的大小？设置的参数是什么？</h5><h5 id="5-1-5-用过哪些命令查看jvm的状态、堆栈信息？"><a href="#5-1-5-用过哪些命令查看jvm的状态、堆栈信息？" class="headerlink" title="5.1.5 用过哪些命令查看jvm的状态、堆栈信息？"></a>5.1.5 用过哪些命令查看jvm的状态、堆栈信息？</h5><h5 id="5-1-6-jvm的垃圾回收机制？"><a href="#5-1-6-jvm的垃圾回收机制？" class="headerlink" title="5.1.6 jvm的垃圾回收机制？"></a>5.1.6 jvm的垃圾回收机制？</h5><h5 id="5-1-7-java类加载机制？如何实现自定义类加载器？findClass与loadClass的区别？"><a href="#5-1-7-java类加载机制？如何实现自定义类加载器？findClass与loadClass的区别？" class="headerlink" title="5.1.7 java类加载机制？如何实现自定义类加载器？findClass与loadClass的区别？"></a>5.1.7 java类加载机制？如何实现自定义类加载器？findClass与loadClass的区别？</h5><h5 id="5-1-8-String、StringBuffer、StringBuilder的区别？对应的使用场景？"><a href="#5-1-8-String、StringBuffer、StringBuilder的区别？对应的使用场景？" class="headerlink" title="5.1.8 String、StringBuffer、StringBuilder的区别？对应的使用场景？"></a>5.1.8 String、StringBuffer、StringBuilder的区别？对应的使用场景？</h5><h5 id="5-1-9-如何实现不可变的类？"><a href="#5-1-9-如何实现不可变的类？" class="headerlink" title="5.1.9 如何实现不可变的类？"></a>5.1.9 如何实现不可变的类？</h5><h5 id="5-2-0-浅复制和深复制？怎样实现深复制？"><a href="#5-2-0-浅复制和深复制？怎样实现深复制？" class="headerlink" title="5.2.0 浅复制和深复制？怎样实现深复制？"></a>5.2.0 浅复制和深复制？怎样实现深复制？</h5><h5 id="5-2-1-HashMap、HashTable、ConcurrentHashMap的区别？"><a href="#5-2-1-HashMap、HashTable、ConcurrentHashMap的区别？" class="headerlink" title="5.2.1 HashMap、HashTable、ConcurrentHashMap的区别？"></a>5.2.1 HashMap、HashTable、ConcurrentHashMap的区别？</h5><h5 id="5-2-2-CAS是一种什么样的同步机制？"><a href="#5-2-2-CAS是一种什么样的同步机制？" class="headerlink" title="5.2.2 CAS是一种什么样的同步机制？"></a>5.2.2 CAS是一种什么样的同步机制？</h5><h5 id="5-2-3-NIO的原理，包括哪几个组件？"><a href="#5-2-3-NIO的原理，包括哪几个组件？" class="headerlink" title="5.2.3 NIO的原理，包括哪几个组件？"></a>5.2.3 NIO的原理，包括哪几个组件？</h5><h5 id="5-2-4-简单介绍一下java的反射机制？反射在哪些地方有应用场景？"><a href="#5-2-4-简单介绍一下java的反射机制？反射在哪些地方有应用场景？" class="headerlink" title="5.2.4 简单介绍一下java的反射机制？反射在哪些地方有应用场景？"></a>5.2.4 简单介绍一下java的反射机制？反射在哪些地方有应用场景？</h5><h5 id="5-2-5-spring加载bean的流程？"><a href="#5-2-5-spring加载bean的流程？" class="headerlink" title="5.2.5 spring加载bean的流程？"></a>5.2.5 spring加载bean的流程？</h5><h5 id="5-2-6-java线程池？线程池构造函数的几个参数含义？keepAliveTime解释一下？"><a href="#5-2-6-java线程池？线程池构造函数的几个参数含义？keepAliveTime解释一下？" class="headerlink" title="5.2.6 java线程池？线程池构造函数的几个参数含义？keepAliveTime解释一下？"></a>5.2.6 java线程池？线程池构造函数的几个参数含义？keepAliveTime解释一下？</h5><h5 id="5-2-7-一个接口，要去调用另外5个接口，每一个接口都会返回数据给这个调用接口，调用接口要对数据进行合并并返回给上层。这样一种场景可能用到并发包下的哪些类？你会怎么去实现这样的业务场景？"><a href="#5-2-7-一个接口，要去调用另外5个接口，每一个接口都会返回数据给这个调用接口，调用接口要对数据进行合并并返回给上层。这样一种场景可能用到并发包下的哪些类？你会怎么去实现这样的业务场景？" class="headerlink" title="5.2.7 一个接口，要去调用另外5个接口，每一个接口都会返回数据给这个调用接口，调用接口要对数据进行合并并返回给上层。这样一种场景可能用到并发包下的哪些类？你会怎么去实现这样的业务场景？"></a>5.2.7 一个接口，要去调用另外5个接口，每一个接口都会返回数据给这个调用接口，调用接口要对数据进行合并并返回给上层。这样一种场景可能用到并发包下的哪些类？你会怎么去实现这样的业务场景？</h5><h5 id="5-2-8-CountDownLatch和CyclicBarrier的区别？"><a href="#5-2-8-CountDownLatch和CyclicBarrier的区别？" class="headerlink" title="5.2.8 CountDownLatch和CyclicBarrier的区别？"></a>5.2.8 CountDownLatch和CyclicBarrier的区别？</h5><h5 id="5-2-9-线程加锁有哪些方式？synchronized和lock的区别？"><a href="#5-2-9-线程加锁有哪些方式？synchronized和lock的区别？" class="headerlink" title="5.2.9 线程加锁有哪些方式？synchronized和lock的区别？"></a>5.2.9 线程加锁有哪些方式？synchronized和lock的区别？</h5><h5 id="5-3-0-volatile关键字的作用？为什么使用AtomicLong而不使用Long-AtomicLong的底层是怎么实现的？"><a href="#5-3-0-volatile关键字的作用？为什么使用AtomicLong而不使用Long-AtomicLong的底层是怎么实现的？" class="headerlink" title="5.3.0 volatile关键字的作用？为什么使用AtomicLong而不使用Long?AtomicLong的底层是怎么实现的？"></a>5.3.0 volatile关键字的作用？为什么使用AtomicLong而不使用Long?AtomicLong的底层是怎么实现的？</h5><h5 id="5-3-1-mysql的存储引擎有哪几种？"><a href="#5-3-1-mysql的存储引擎有哪几种？" class="headerlink" title="5.3.1 mysql的存储引擎有哪几种？"></a>5.3.1 mysql的存储引擎有哪几种？</h5><h5 id="5-3-2-sql优化有哪些着手点？组合索引的最左前缀原则的含义？"><a href="#5-3-2-sql优化有哪些着手点？组合索引的最左前缀原则的含义？" class="headerlink" title="5.3.2 sql优化有哪些着手点？组合索引的最左前缀原则的含义？"></a>5.3.2 sql优化有哪些着手点？组合索引的最左前缀原则的含义？</h5><h5 id="5-3-3-springmvc处理请求的流程？"><a href="#5-3-3-springmvc处理请求的流程？" class="headerlink" title="5.3.3 springmvc处理请求的流程？"></a>5.3.3 springmvc处理请求的流程？</h5><h5 id="5-3-4-spring的事务怎么使用？事务回滚？自定义异常？"><a href="#5-3-4-spring的事务怎么使用？事务回滚？自定义异常？" class="headerlink" title="5.3.4 spring的事务怎么使用？事务回滚？自定义异常？"></a>5.3.4 spring的事务怎么使用？事务回滚？自定义异常？</h5><h5 id="5-3-5-脏读？幻读？"><a href="#5-3-5-脏读？幻读？" class="headerlink" title="5.3.5 脏读？幻读？"></a>5.3.5 脏读？幻读？</h5><h5 id="5-3-6-tcp四次挥手的过程？TIME-WAIT为什么至少设置两倍的MSL时间？"><a href="#5-3-6-tcp四次挥手的过程？TIME-WAIT为什么至少设置两倍的MSL时间？" class="headerlink" title="5.3.6 tcp四次挥手的过程？TIME_WAIT为什么至少设置两倍的MSL时间？"></a>5.3.6 tcp四次挥手的过程？TIME_WAIT为什么至少设置两倍的MSL时间？</h5><h5 id="5-3-7-get和post请求的区别？"><a href="#5-3-7-get和post请求的区别？" class="headerlink" title="5.3.7 get和post请求的区别？"></a>5.3.7 get和post请求的区别？</h5><h5 id="5-3-8-cookie和session的请求？"><a href="#5-3-8-cookie和session的请求？" class="headerlink" title="5.3.8 cookie和session的请求？"></a>5.3.8 cookie和session的请求？</h5><h5 id="5-3-9-了解哪些开源的中间件？缓存？消息？分布式框架？"><a href="#5-3-9-了解哪些开源的中间件？缓存？消息？分布式框架？" class="headerlink" title="5.3.9 了解哪些开源的中间件？缓存？消息？分布式框架？"></a>5.3.9 了解哪些开源的中间件？缓存？消息？分布式框架？</h5><h5 id="5-4-0-用到过哪些设计模式？单例模式的实现？"><a href="#5-4-0-用到过哪些设计模式？单例模式的实现？" class="headerlink" title="5.4.0 用到过哪些设计模式？单例模式的实现？"></a>5.4.0 用到过哪些设计模式？单例模式的实现？</h5><h5 id="5-4-1-数据库的事务实现原理、操作过程、如何做到事物之间的独立性等问题"><a href="#5-4-1-数据库的事务实现原理、操作过程、如何做到事物之间的独立性等问题" class="headerlink" title="5.4.1 数据库的事务实现原理、操作过程、如何做到事物之间的独立性等问题"></a>5.4.1 数据库的事务实现原理、操作过程、如何做到事物之间的独立性等问题</h5><h5 id="5-4-2-数据库的脏读，幻读，不可重复读出现的原因原理，解决办法"><a href="#5-4-2-数据库的脏读，幻读，不可重复读出现的原因原理，解决办法" class="headerlink" title="5.4.2 数据库的脏读，幻读，不可重复读出现的原因原理，解决办法"></a>5.4.2 数据库的脏读，幻读，不可重复读出现的原因原理，解决办法</h5><h5 id="5-4-3-数据库的隔离级别、MVCC"><a href="#5-4-3-数据库的隔离级别、MVCC" class="headerlink" title="5.4.3 数据库的隔离级别、MVCC"></a>5.4.3 数据库的隔离级别、MVCC</h5><h5 id="5-4-4-乐观锁、悲观锁、互斥锁、读写锁的原理实现与区别"><a href="#5-4-4-乐观锁、悲观锁、互斥锁、读写锁的原理实现与区别" class="headerlink" title="5.4.4 乐观锁、悲观锁、互斥锁、读写锁的原理实现与区别"></a>5.4.4 乐观锁、悲观锁、互斥锁、读写锁的原理实现与区别</h5><h5 id="5-4-5-线程的生命周期"><a href="#5-4-5-线程的生命周期" class="headerlink" title="5.4.5 线程的生命周期"></a>5.4.5 线程的生命周期</h5><h5 id="5-4-6-一致性hash算法原理与应用"><a href="#5-4-6-一致性hash算法原理与应用" class="headerlink" title="5.4.6 一致性hash算法原理与应用"></a>5.4.6 一致性hash算法原理与应用</h5><h5 id="5-4-7-CAP原则"><a href="#5-4-7-CAP原则" class="headerlink" title="5.4.7 CAP原则"></a>5.4.7 CAP原则</h5><h5 id="5-4-8-CAS操作"><a href="#5-4-8-CAS操作" class="headerlink" title="5.4.8 CAS操作"></a>5.4.8 CAS操作</h5><h5 id="5-4-9-分布式raft算法"><a href="#5-4-9-分布式raft算法" class="headerlink" title="5.4.9 分布式raft算法"></a>5.4.9 分布式raft算法</h5><br><h3 id="6">头条篇</h3><hr><h5 id="6-1-0-5个人去一个海岛寻宝，最后一共找到了100枚金币。他们约定了一个分配方案。"><a href="#6-1-0-5个人去一个海岛寻宝，最后一共找到了100枚金币。他们约定了一个分配方案。" class="headerlink" title="6.1.0 5个人去一个海岛寻宝，最后一共找到了100枚金币。他们约定了一个分配方案。"></a>6.1.0 5个人去一个海岛寻宝，最后一共找到了100枚金币。他们约定了一个分配方案。</h5><h5 id="6-1-1-给你一个有序整数数组，数组中的数可以是正数、负数、零，请实现一个函数，这个函数返回一个整数：返回这个数组所有数的平方值中有多少种不同的取值。"><a href="#6-1-1-给你一个有序整数数组，数组中的数可以是正数、负数、零，请实现一个函数，这个函数返回一个整数：返回这个数组所有数的平方值中有多少种不同的取值。" class="headerlink" title="6.1.1 给你一个有序整数数组，数组中的数可以是正数、负数、零，请实现一个函数，这个函数返回一个整数：返回这个数组所有数的平方值中有多少种不同的取值。"></a>6.1.1 给你一个有序整数数组，数组中的数可以是正数、负数、零，请实现一个函数，这个函数返回一个整数：返回这个数组所有数的平方值中有多少种不同的取值。</h5><h5 id="6-1-2-一个环有10个节点，编号0-9。从0点出发，走N步又能回到0点，共有多少种走法？"><a href="#6-1-2-一个环有10个节点，编号0-9。从0点出发，走N步又能回到0点，共有多少种走法？" class="headerlink" title="6.1.2 一个环有10个节点，编号0-9。从0点出发，走N步又能回到0点，共有多少种走法？"></a>6.1.2 一个环有10个节点，编号0-9。从0点出发，走N步又能回到0点，共有多少种走法？</h5><h5 id="6-1-3-一个乱序数组，求第K大的数。排序方式使用字典序。"><a href="#6-1-3-一个乱序数组，求第K大的数。排序方式使用字典序。" class="headerlink" title="6.1.3 一个乱序数组，求第K大的数。排序方式使用字典序。"></a>6.1.3 一个乱序数组，求第K大的数。排序方式使用字典序。</h5><h5 id="6-1-4-一棵二叉树，求最大通路长度。（即最大左右子树高度之和）"><a href="#6-1-4-一棵二叉树，求最大通路长度。（即最大左右子树高度之和）" class="headerlink" title="6.1.4 一棵二叉树，求最大通路长度。（即最大左右子树高度之和）"></a>6.1.4 一棵二叉树，求最大通路长度。（即最大左右子树高度之和）</h5><h5 id="6-1-5-进程和线程的区别，使用线程真的能节省时间？"><a href="#6-1-5-进程和线程的区别，使用线程真的能节省时间？" class="headerlink" title="6.1.5 进程和线程的区别，使用线程真的能节省时间？"></a>6.1.5 进程和线程的区别，使用线程真的能节省时间？</h5><h5 id="6-1-6-go协程的调度方式，使用协程真的能节省时间？"><a href="#6-1-6-go协程的调度方式，使用协程真的能节省时间？" class="headerlink" title="6.1.6 go协程的调度方式，使用协程真的能节省时间？"></a>6.1.6 go协程的调度方式，使用协程真的能节省时间？</h5><h5 id="6-1-7-水平触发边沿触发的区别？在边沿触发下，一个socket有500的数据，已读取200然后不再处理，是不是剩下的300就永远无法读取？"><a href="#6-1-7-水平触发边沿触发的区别？在边沿触发下，一个socket有500的数据，已读取200然后不再处理，是不是剩下的300就永远无法读取？" class="headerlink" title="6.1.7 水平触发边沿触发的区别？在边沿触发下，一个socket有500的数据，已读取200然后不再处理，是不是剩下的300就永远无法读取？"></a>6.1.7 水平触发边沿触发的区别？在边沿触发下，一个socket有500的数据，已读取200然后不再处理，是不是剩下的300就永远无法读取？</h5><h5 id="6-1-8-有函数如下，输入1，返回什么？"><a href="#6-1-8-有函数如下，输入1，返回什么？" class="headerlink" title="6.1.8 有函数如下，输入1，返回什么？"></a>6.1.8 有函数如下，输入1，返回什么？</h5><h5 id="6-1-9-设计http协议，A端发送-AAAA，至少让B端知道AAAA已发送完成。"><a href="#6-1-9-设计http协议，A端发送-AAAA，至少让B端知道AAAA已发送完成。" class="headerlink" title="6.1.9 设计http协议，A端发送 AAAA，至少让B端知道AAAA已发送完成。"></a>6.1.9 设计http协议，A端发送 AAAA，至少让B端知道AAAA已发送完成。</h5><h5 id="6-2-0-流量总入口为api-gateway，api-gateway挂了会导致全部挂挂，用什么机制增大可用性？"><a href="#6-2-0-流量总入口为api-gateway，api-gateway挂了会导致全部挂挂，用什么机制增大可用性？" class="headerlink" title="6.2.0 流量总入口为api_gateway，api_gateway挂了会导致全部挂挂，用什么机制增大可用性？"></a>6.2.0 流量总入口为api_gateway，api_gateway挂了会导致全部挂挂，用什么机制增大可用性？</h5><h5 id="6-2-1-mysql为什么要用b-树，不用平衡二叉树做索引结构？"><a href="#6-2-1-mysql为什么要用b-树，不用平衡二叉树做索引结构？" class="headerlink" title="6.2.1 mysql为什么要用b+树，不用平衡二叉树做索引结构？"></a>6.2.1 mysql为什么要用b+树，不用平衡二叉树做索引结构？</h5><h5 id="6-2-2-创建数据库索引应该怎么考虑？"><a href="#6-2-2-创建数据库索引应该怎么考虑？" class="headerlink" title="6.2.2 创建数据库索引应该怎么考虑？"></a>6.2.2 创建数据库索引应该怎么考虑？</h5><h5 id="6-2-3-使用int-做primary-key和使用string-有什么优劣？"><a href="#6-2-3-使用int-做primary-key和使用string-有什么优劣？" class="headerlink" title="6.2.3 使用int 做primary key和使用string 有什么优劣？"></a>6.2.3 使用int 做primary key和使用string 有什么优劣？</h5><h5 id="6-2-4-数据库分表的方法？"><a href="#6-2-4-数据库分表的方法？" class="headerlink" title="6.2.4 数据库分表的方法？"></a>6.2.4 数据库分表的方法？</h5><h5 id="6-2-5-表结构，订单纪录如下，写一个语句，求卖的最好的-top-10-product-id。"><a href="#6-2-5-表结构，订单纪录如下，写一个语句，求卖的最好的-top-10-product-id。" class="headerlink" title="6.2.5 表结构，订单纪录如下，写一个语句，求卖的最好的 top 10 product_id。"></a>6.2.5 表结构，订单纪录如下，写一个语句，求卖的最好的 top 10 product_id。</h5><h5 id="6-2-6-微服务，A服务请求B服务B1接口，B1接口又请求A服务A2接口。会不会有问题？"><a href="#6-2-6-微服务，A服务请求B服务B1接口，B1接口又请求A服务A2接口。会不会有问题？" class="headerlink" title="6.2.6 微服务，A服务请求B服务B1接口，B1接口又请求A服务A2接口。会不会有问题？"></a>6.2.6 微服务，A服务请求B服务B1接口，B1接口又请求A服务A2接口。会不会有问题？</h5><h5 id="6-2-7-不使用高级工具，只使用Linux自带的工具，你会如何debug"><a href="#6-2-7-不使用高级工具，只使用Linux自带的工具，你会如何debug" class="headerlink" title="6.2.7 不使用高级工具，只使用Linux自带的工具，你会如何debug?"></a>6.2.7 不使用高级工具，只使用Linux自带的工具，你会如何debug?</h5><h5 id="6-2-8-如何预估一个mysql语句的性能？"><a href="#6-2-8-如何预估一个mysql语句的性能？" class="headerlink" title="6.2.8 如何预估一个mysql语句的性能？"></a>6.2.8 如何预估一个mysql语句的性能？</h5><h5 id="6-2-9-go函数中，返回值未命名，发生了panic，但是在函数内recover了。函数返回什么值？"><a href="#6-2-9-go函数中，返回值未命名，发生了panic，但是在函数内recover了。函数返回什么值？" class="headerlink" title="6.2.9 go函数中，返回值未命名，发生了panic，但是在函数内recover了。函数返回什么值？"></a>6.2.9 go函数中，返回值未命名，发生了panic，但是在函数内recover了。函数返回什么值？</h5><h5 id="6-3-0-socket中，在tcp协议层面，数据分为10个报文发放。1-7次很顺利，第8次丢失。这次通信一定失败吗？如果第8次数据会重发，那在接收端是不是：先读取到1-7次的数据，然后读取到8-10次的数据-还是9-10次的数据会先到达？"><a href="#6-3-0-socket中，在tcp协议层面，数据分为10个报文发放。1-7次很顺利，第8次丢失。这次通信一定失败吗？如果第8次数据会重发，那在接收端是不是：先读取到1-7次的数据，然后读取到8-10次的数据-还是9-10次的数据会先到达？" class="headerlink" title="6.3.0 socket中，在tcp协议层面，数据分为10个报文发放。1-7次很顺利，第8次丢失。这次通信一定失败吗？如果第8次数据会重发，那在接收端是不是：先读取到1-7次的数据，然后读取到8-10次的数据?还是9-10次的数据会先到达？"></a>6.3.0 socket中，在tcp协议层面，数据分为10个报文发放。1-7次很顺利，第8次丢失。这次通信一定失败吗？如果第8次数据会重发，那在接收端是不是：先读取到1-7次的数据，然后读取到8-10次的数据?还是9-10次的数据会先到达？</h5><h5 id="6-3-1-free-h，buffers-和cached有什么不同"><a href="#6-3-1-free-h，buffers-和cached有什么不同" class="headerlink" title="6.3.1 free -h，buffers 和cached有什么不同"></a>6.3.1 free -h，buffers 和cached有什么不同</h5><h5 id="6-3-2-后台进程有什么特点，如果要你设计一个进程是后台进程，你会考虑什么"><a href="#6-3-2-后台进程有什么特点，如果要你设计一个进程是后台进程，你会考虑什么" class="headerlink" title="6.3.2 后台进程有什么特点，如果要你设计一个进程是后台进程，你会考虑什么"></a>6.3.2 后台进程有什么特点，如果要你设计一个进程是后台进程，你会考虑什么</h5><h5 id="6-3-3-僵尸进程是什么，如果产生一个僵尸进程，如何查找僵尸进程"><a href="#6-3-3-僵尸进程是什么，如果产生一个僵尸进程，如何查找僵尸进程" class="headerlink" title="6.3.3 僵尸进程是什么，如果产生一个僵尸进程，如何查找僵尸进程"></a>6.3.3 僵尸进程是什么，如果产生一个僵尸进程，如何查找僵尸进程</h5><h5 id="6-3-4-孤儿进程是什么"><a href="#6-3-4-孤儿进程是什么" class="headerlink" title="6.3.4 孤儿进程是什么"></a>6.3.4 孤儿进程是什么</h5><h5 id="6-3-5-一个进程有20个线程，在某个线程中调用fork，新的进程会有20个线程吗？"><a href="#6-3-5-一个进程有20个线程，在某个线程中调用fork，新的进程会有20个线程吗？" class="headerlink" title="6.3.5 一个进程有20个线程，在某个线程中调用fork，新的进程会有20个线程吗？"></a>6.3.5 一个进程有20个线程，在某个线程中调用fork，新的进程会有20个线程吗？</h5><h5 id="6-3-6-tcp-ip-流量控制和拥塞控制"><a href="#6-3-6-tcp-ip-流量控制和拥塞控制" class="headerlink" title="6.3.6 tcp/ip 流量控制和拥塞控制"></a>6.3.6 tcp/ip 流量控制和拥塞控制</h5><h5 id="6-3-7-301-302有什么区别？应用上有什么异同。"><a href="#6-3-7-301-302有什么区别？应用上有什么异同。" class="headerlink" title="6.3.7 301/302有什么区别？应用上有什么异同。"></a>6.3.7 301/302有什么区别？应用上有什么异同。</h5><h5 id="6-3-8-50X相关错误码的内涵是什么？"><a href="#6-3-8-50X相关错误码的内涵是什么？" class="headerlink" title="6.3.8 50X相关错误码的内涵是什么？"></a>6.3.8 50X相关错误码的内涵是什么？</h5><h5 id="6-3-9-close-wait和time-wait是什么？如何排查？有什么意义？"><a href="#6-3-9-close-wait和time-wait是什么？如何排查？有什么意义？" class="headerlink" title="6.3.9 close wait和time wait是什么？如何排查？有什么意义？"></a>6.3.9 close wait和time wait是什么？如何排查？有什么意义？</h5><h5 id="6-4-0-http-req和resp的中数据有哪些"><a href="#6-4-0-http-req和resp的中数据有哪些" class="headerlink" title="6.4.0 http req和resp的中数据有哪些"></a>6.4.0 http req和resp的中数据有哪些</h5><h5 id="6-4-1-什么是连接的半打开，半关闭状态"><a href="#6-4-1-什么是连接的半打开，半关闭状态" class="headerlink" title="6.4.1 什么是连接的半打开，半关闭状态"></a>6.4.1 什么是连接的半打开，半关闭状态</h5><h5 id="6-4-2-假如一个业务依赖单点redis，此redis故障将导致业务不可用，如何改进"><a href="#6-4-2-假如一个业务依赖单点redis，此redis故障将导致业务不可用，如何改进" class="headerlink" title="6.4.2 假如一个业务依赖单点redis，此redis故障将导致业务不可用，如何改进"></a>6.4.2 假如一个业务依赖单点redis，此redis故障将导致业务不可用，如何改进</h5><h5 id="6-4-3-redis-sharding有哪些做法"><a href="#6-4-3-redis-sharding有哪些做法" class="headerlink" title="6.4.3 redis sharding有哪些做法"></a>6.4.3 redis sharding有哪些做法</h5><h5 id="6-4-4-当大量数据要求用redis保存，单机单点难以满足需要，设计（换寻找）一个负载均衡的方案"><a href="#6-4-4-当大量数据要求用redis保存，单机单点难以满足需要，设计（换寻找）一个负载均衡的方案" class="headerlink" title="6.4.4 当大量数据要求用redis保存，单机单点难以满足需要，设计（换寻找）一个负载均衡的方案"></a>6.4.4 当大量数据要求用redis保存，单机单点难以满足需要，设计（换寻找）一个负载均衡的方案</h5><h5 id="6-4-5-当redis-采用hash做sharding，现在有8个节点，负载方案是-pos-hash-key-8，然后保存在pos节点上。这样做有什么好处坏处？当8个节点要扩充到10个节点，应该怎么办？有什么更方便扩充的方案吗？（一致性hash-presharding）"><a href="#6-4-5-当redis-采用hash做sharding，现在有8个节点，负载方案是-pos-hash-key-8，然后保存在pos节点上。这样做有什么好处坏处？当8个节点要扩充到10个节点，应该怎么办？有什么更方便扩充的方案吗？（一致性hash-presharding）" class="headerlink" title="6.4.5 当redis 采用hash做sharding，现在有8个节点，负载方案是 pos = hash(key) % 8，然后保存在pos节点上。这样做有什么好处坏处？当8个节点要扩充到10个节点，应该怎么办？有什么更方便扩充的方案吗？（一致性hash, presharding）"></a>6.4.5 当redis 采用hash做sharding，现在有8个节点，负载方案是 pos = hash(key) % 8，然后保存在pos节点上。这样做有什么好处坏处？当8个节点要扩充到10个节点，应该怎么办？有什么更方便扩充的方案吗？（一致性hash, presharding）</h5><h5 id="6-4-6-如何保证redis和数据库数据的一致性。比如用户名既保存在数据库，又保存在redis做缓存。有如下操作-update-db-username-update-redis-username-。但是执行update-db后故障，update-redis没有执行。有什么简单办法解决这个问题。"><a href="#6-4-6-如何保证redis和数据库数据的一致性。比如用户名既保存在数据库，又保存在redis做缓存。有如下操作-update-db-username-update-redis-username-。但是执行update-db后故障，update-redis没有执行。有什么简单办法解决这个问题。" class="headerlink" title="6.4.6 如何保证redis和数据库数据的一致性。比如用户名既保存在数据库，又保存在redis做缓存。有如下操作 update_db(username); update_redis(username)。但是执行update_db后故障，update_redis没有执行。有什么简单办法解决这个问题。"></a>6.4.6 如何保证redis和数据库数据的一致性。比如用户名既保存在数据库，又保存在redis做缓存。有如下操作 update_db(username); update_redis(username)。但是执行update_db后故障，update_redis没有执行。有什么简单办法解决这个问题。</h5><h3 id="7">滴滴篇</h3><hr><h5 id="7-1-0-B-树、B-树的区别"><a href="#7-1-0-B-树、B-树的区别" class="headerlink" title="7.1.0 B+树、B-树的区别?"></a>7.1.0 B+树、B-树的区别?</h5><h5 id="7-1-1-数据库隔离级别，幻读和不可重复读的区别？"><a href="#7-1-1-数据库隔离级别，幻读和不可重复读的区别？" class="headerlink" title="7.1.1 数据库隔离级别，幻读和不可重复读的区别？"></a>7.1.1 数据库隔离级别，幻读和不可重复读的区别？</h5><h5 id="7-1-2-有hell-well-hello-world等字符串组，现在问能否拼接成helloworld，代码实现。"><a href="#7-1-2-有hell-well-hello-world等字符串组，现在问能否拼接成helloworld，代码实现。" class="headerlink" title="7.1.2 有hell, well, hello, world等字符串组，现在问能否拼接成helloworld，代码实现。"></a>7.1.2 有hell, well, hello, world等字符串组，现在问能否拼接成helloworld，代码实现。</h5><h5 id="7-1-3-快排算法实现"><a href="#7-1-3-快排算法实现" class="headerlink" title="7.1.3 快排算法实现"></a>7.1.3 快排算法实现</h5><h5 id="7-1-4-线程安全的单例模式"><a href="#7-1-4-线程安全的单例模式" class="headerlink" title="7.1.4 线程安全的单例模式"></a>7.1.4 线程安全的单例模式</h5><h5 id="7-1-5-25匹马赛跑，有一个赛场，只有五个赛道，没有计时器，只能通过目测来记录快慢，求出第三3快的马要多少场比赛？"><a href="#7-1-5-25匹马赛跑，有一个赛场，只有五个赛道，没有计时器，只能通过目测来记录快慢，求出第三3快的马要多少场比赛？" class="headerlink" title="7.1.5 25匹马赛跑，有一个赛场，只有五个赛道，没有计时器，只能通过目测来记录快慢，求出第三3快的马要多少场比赛？"></a>7.1.5 25匹马赛跑，有一个赛场，只有五个赛道，没有计时器，只能通过目测来记录快慢，求出第三3快的马要多少场比赛？</h5><h5 id="7-1-6-kmp算法next数组的求解思路"><a href="#7-1-6-kmp算法next数组的求解思路" class="headerlink" title="7.1.6 kmp算法next数组的求解思路"></a>7.1.6 kmp算法next数组的求解思路</h5><h5 id="7-1-7-数组中有三个数字出现超过3-4，求这三个数字？"><a href="#7-1-7-数组中有三个数字出现超过3-4，求这三个数字？" class="headerlink" title="7.1.7 数组中有三个数字出现超过3/4，求这三个数字？"></a>7.1.7 数组中有三个数字出现超过3/4，求这三个数字？</h5><h5 id="7-1-8-1到n-2个数组中缺了两个数，如何用O-n-时间，O-1-空间找到这两个数字。"><a href="#7-1-8-1到n-2个数组中缺了两个数，如何用O-n-时间，O-1-空间找到这两个数字。" class="headerlink" title="7.1.8 1到n+2个数组中缺了两个数，如何用O(n)时间，O(1)空间找到这两个数字。"></a>7.1.8 1到n+2个数组中缺了两个数，如何用O(n)时间，O(1)空间找到这两个数字。</h5><h5 id="7-1-9-一条线段长为1，随机选两个点，将改线段分为三段，三段能成三角形的概率是多少？"><a href="#7-1-9-一条线段长为1，随机选两个点，将改线段分为三段，三段能成三角形的概率是多少？" class="headerlink" title="7.1.9 一条线段长为1，随机选两个点，将改线段分为三段，三段能成三角形的概率是多少？"></a>7.1.9 一条线段长为1，随机选两个点，将改线段分为三段，三段能成三角形的概率是多少？</h5><h5 id="7-2-0-有一个教授，他三个学生，脑袋背后分别各写了一个数字，其中一个数字是另外两个数字的和，经过几轮后，有一个学生猜出了自己的数字请问是什么原因？"><a href="#7-2-0-有一个教授，他三个学生，脑袋背后分别各写了一个数字，其中一个数字是另外两个数字的和，经过几轮后，有一个学生猜出了自己的数字请问是什么原因？" class="headerlink" title="7.2.0 有一个教授，他三个学生，脑袋背后分别各写了一个数字，其中一个数字是另外两个数字的和，经过几轮后，有一个学生猜出了自己的数字请问是什么原因？"></a>7.2.0 有一个教授，他三个学生，脑袋背后分别各写了一个数字，其中一个数字是另外两个数字的和，经过几轮后，有一个学生猜出了自己的数字请问是什么原因？</h5><h5 id="7-2-1-B-树做索引时，B-树通常高度为多少层？要参考哪些条件？"><a href="#7-2-1-B-树做索引时，B-树通常高度为多少层？要参考哪些条件？" class="headerlink" title="7.2.1 B+树做索引时，B+树通常高度为多少层？要参考哪些条件？"></a>7.2.1 B+树做索引时，B+树通常高度为多少层？要参考哪些条件？</h5><br><h3 id="8">京东篇</h3><hr><h5 id="8-1-0-一般sql注入怎么发现触点的，从源码阐述sqlmap如何测试注入点的。"><a href="#8-1-0-一般sql注入怎么发现触点的，从源码阐述sqlmap如何测试注入点的。" class="headerlink" title="8.1.0 一般sql注入怎么发现触点的，从源码阐述sqlmap如何测试注入点的。"></a>8.1.0 一般sql注入怎么发现触点的，从源码阐述sqlmap如何测试注入点的。</h5><h5 id="8-1-1-masscan扫描端口时靠什么检测，为什么这么快-请详述"><a href="#8-1-1-masscan扫描端口时靠什么检测，为什么这么快-请详述" class="headerlink" title="8.1.1 masscan扫描端口时靠什么检测，为什么这么快? 请详述."></a>8.1.1 masscan扫描端口时靠什么检测，为什么这么快? 请详述.</h5><h5 id="8-1-2-你写过哪些小工具，你为你使用过的工具做过什么修改"><a href="#8-1-2-你写过哪些小工具，你为你使用过的工具做过什么修改" class="headerlink" title="8.1.2 你写过哪些小工具，你为你使用过的工具做过什么修改."></a>8.1.2 你写过哪些小工具，你为你使用过的工具做过什么修改.</h5><h5 id="8-1-3-如何提高采用python编写的扫描速度，谈谈对GIL锁的了解"><a href="#8-1-3-如何提高采用python编写的扫描速度，谈谈对GIL锁的了解" class="headerlink" title="8.1.3 如何提高采用python编写的扫描速度，谈谈对GIL锁的了解."></a>8.1.3 如何提高采用python编写的扫描速度，谈谈对GIL锁的了解.</h5><h5 id="8-1-4-你觉得你发现的那个漏洞影响比较大"><a href="#8-1-4-你觉得你发现的那个漏洞影响比较大" class="headerlink" title="8.1.4 你觉得你发现的那个漏洞影响比较大."></a>8.1.4 你觉得你发现的那个漏洞影响比较大.</h5><h5 id="8-1-5-常见的web漏洞有哪些"><a href="#8-1-5-常见的web漏洞有哪些" class="headerlink" title="8.1.5 常见的web漏洞有哪些."></a>8.1.5 常见的web漏洞有哪些.</h5><h5 id="8-1-6-有没有玩过硬件安全，研究程度如何"><a href="#8-1-6-有没有玩过硬件安全，研究程度如何" class="headerlink" title="8.1.6 有没有玩过硬件安全，研究程度如何."></a>8.1.6 有没有玩过硬件安全，研究程度如何.</h5><h5 id="8-1-7-反爬虫，如果是你如何进行反爬虫，如何绕过反爬措施。-使用无头浏览器被检测到了，如何绕过"><a href="#8-1-7-反爬虫，如果是你如何进行反爬虫，如何绕过反爬措施。-使用无头浏览器被检测到了，如何绕过" class="headerlink" title="8.1.7 反爬虫，如果是你如何进行反爬虫，如何绕过反爬措施。 使用无头浏览器被检测到了，如何绕过"></a>8.1.7 反爬虫，如果是你如何进行反爬虫，如何绕过反爬措施。 使用无头浏览器被检测到了，如何绕过</h5><h5 id="8-1-8-nmap扫描如何进行扫描。发包与协议，握手和不握手，哪些协议握手，哪些不握手-如何不直接接触目标服务器探测对方端口是否开放"><a href="#8-1-8-nmap扫描如何进行扫描。发包与协议，握手和不握手，哪些协议握手，哪些不握手-如何不直接接触目标服务器探测对方端口是否开放" class="headerlink" title="8.1.8 nmap扫描如何进行扫描。发包与协议，握手和不握手，哪些协议握手，哪些不握手. 如何不直接接触目标服务器探测对方端口是否开放"></a>8.1.8 nmap扫描如何进行扫描。发包与协议，握手和不握手，哪些协议握手，哪些不握手. 如何不直接接触目标服务器探测对方端口是否开放</h5><h5 id="8-1-9-有没有自己编写过yara扫描模块，如果要解决扫描-k1-v1-k2-v2-k3-v3-，保证同时在k1中的v1里出现特定值，k2中出现v2特定值，以及k3-v3。怎么实现"><a href="#8-1-9-有没有自己编写过yara扫描模块，如果要解决扫描-k1-v1-k2-v2-k3-v3-，保证同时在k1中的v1里出现特定值，k2中出现v2特定值，以及k3-v3。怎么实现" class="headerlink" title="8.1.9 有没有自己编写过yara扫描模块，如果要解决扫描{k1:v1, k2:v2, k3:v3} ，保证同时在k1中的v1里出现特定值，k2中出现v2特定值，以及k3,v3。怎么实现"></a>8.1.9 有没有自己编写过yara扫描模块，如果要解决扫描{k1:v1, k2:v2, k3:v3} ，保证同时在k1中的v1里出现特定值，k2中出现v2特定值，以及k3,v3。怎么实现</h5><h5 id="8-2-0-xss什么原理，如何自己实现一个beef类似的xss平台-既然这样实现，面临的跨域如何解决"><a href="#8-2-0-xss什么原理，如何自己实现一个beef类似的xss平台-既然这样实现，面临的跨域如何解决" class="headerlink" title="8.2.0 xss什么原理，如何自己实现一个beef类似的xss平台. 既然这样实现，面临的跨域如何解决?"></a>8.2.0 xss什么原理，如何自己实现一个beef类似的xss平台. 既然这样实现，面临的跨域如何解决?</h5><h5 id="8-2-1-ip-频率限制-ip信誉度模型？"><a href="#8-2-1-ip-频率限制-ip信誉度模型？" class="headerlink" title="8.2.1 ip 频率限制, ip信誉度模型？"></a>8.2.1 ip 频率限制, ip信誉度模型？</h5><h5 id="8-2-2-SCTP协议是什么？如何使用-SCTP-优化网络？"><a href="#8-2-2-SCTP协议是什么？如何使用-SCTP-优化网络？" class="headerlink" title="8.2.2 SCTP协议是什么？如何使用 SCTP 优化网络？"></a>8.2.2 SCTP协议是什么？如何使用 SCTP 优化网络？</h5><br><h3 id="9">mysql篇</h3> <hr><h5 id="9-1-0-主键-超键-候选键-外键"><a href="#9-1-0-主键-超键-候选键-外键" class="headerlink" title="9.1.0 主键 超键 候选键 外键"></a>9.1.0 主键 超键 候选键 外键</h5><h5 id="9-1-1-数据库事务的四个特性及含义"><a href="#9-1-1-数据库事务的四个特性及含义" class="headerlink" title="9.1.1 数据库事务的四个特性及含义"></a>9.1.1 数据库事务的四个特性及含义</h5><h5 id="9-1-2-视图的作用，视图可以更改么？"><a href="#9-1-2-视图的作用，视图可以更改么？" class="headerlink" title="9.1.2 视图的作用，视图可以更改么？"></a>9.1.2 视图的作用，视图可以更改么？</h5><h5 id="9-1-3-drop-delete与truncate的区别"><a href="#9-1-3-drop-delete与truncate的区别" class="headerlink" title="9.1.3 drop,delete与truncate的区别"></a>9.1.3 drop,delete与truncate的区别</h5><h5 id="9-1-4-索引的工作原理及其种类"><a href="#9-1-4-索引的工作原理及其种类" class="headerlink" title="9.1.4 索引的工作原理及其种类"></a>9.1.4 索引的工作原理及其种类</h5><h5 id="9-1-5-连接的种类"><a href="#9-1-5-连接的种类" class="headerlink" title="9.1.5 连接的种类"></a>9.1.5 连接的种类</h5><h5 id="9-1-6-数据库范式"><a href="#9-1-6-数据库范式" class="headerlink" title="9.1.6 数据库范式"></a>9.1.6 数据库范式</h5><h5 id="9-1-7-数据库优化的思路"><a href="#9-1-7-数据库优化的思路" class="headerlink" title="9.1.7 数据库优化的思路"></a>9.1.7 数据库优化的思路</h5><h5 id="9-1-8-存储过程与触发器的区别"><a href="#9-1-8-存储过程与触发器的区别" class="headerlink" title="9.1.8 存储过程与触发器的区别"></a>9.1.8 存储过程与触发器的区别</h5><br><h3 id="10">redis篇</h3> <hr><h5 id="10-1-0-使用Redis有哪些好处？"><a href="#10-1-0-使用Redis有哪些好处？" class="headerlink" title="10.1.0 使用Redis有哪些好处？"></a>10.1.0 使用Redis有哪些好处？</h5><h5 id="10-1-1-redis相比memcached有哪些优势？"><a href="#10-1-1-redis相比memcached有哪些优势？" class="headerlink" title="10.1.1 redis相比memcached有哪些优势？"></a>10.1.1 redis相比memcached有哪些优势？</h5><h5 id="10-1-2-redis常见性能问题和解决方案"><a href="#10-1-2-redis常见性能问题和解决方案" class="headerlink" title="10.1.2 redis常见性能问题和解决方案"></a>10.1.2 redis常见性能问题和解决方案</h5><h5 id="10-1-3-MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"><a href="#10-1-3-MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据" class="headerlink" title="10.1.3 MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"></a>10.1.3 MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据</h5><h5 id="10-1-4-Memcache与Redis的区别都有哪些？"><a href="#10-1-4-Memcache与Redis的区别都有哪些？" class="headerlink" title="10.1.4 Memcache与Redis的区别都有哪些？"></a>10.1.4 Memcache与Redis的区别都有哪些？</h5><h5 id="10-1-5-Redis-常见的性能问题都有哪些？如何解决？"><a href="#10-1-5-Redis-常见的性能问题都有哪些？如何解决？" class="headerlink" title="10.1.5 Redis 常见的性能问题都有哪些？如何解决？"></a>10.1.5 Redis 常见的性能问题都有哪些？如何解决？</h5><h5 id="10-1-6-redis-最适合的场景"><a href="#10-1-6-redis-最适合的场景" class="headerlink" title="10.1.6 redis 最适合的场景"></a>10.1.6 redis 最适合的场景</h5><h5 id="10-1-7-Redis的同步机制了解么？"><a href="#10-1-7-Redis的同步机制了解么？" class="headerlink" title="10.1.7 Redis的同步机制了解么？"></a><a href="https://github.com/0voice/interview_internal_reference/blob/master/3.1.7%20Redis%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F.md" target="_blank" rel="noopener">10.1.7 Redis的同步机制了解么？</a></h5><h5 id="10-1-8-是否使用过Redis集群，集群的原理是什么？"><a href="#10-1-8-是否使用过Redis集群，集群的原理是什么？" class="headerlink" title="10.1.8 是否使用过Redis集群，集群的原理是什么？"></a>10.1.8 是否使用过Redis集群，集群的原理是什么？</h5><h5 id="10-1-9-redis集群如何保证一致性？"><a href="#10-1-9-redis集群如何保证一致性？" class="headerlink" title="10.1.9 redis集群如何保证一致性？"></a>10.1.9 redis集群如何保证一致性？</h5><br><h3 id="11">MongDB篇</h3> <hr><h5 id="11-1-0-什么是MongoDB？"><a href="#11-1-0-什么是MongoDB？" class="headerlink" title="11.1.0 什么是MongoDB？"></a>11.1.0 什么是MongoDB？</h5><h5 id="11-1-1-MongoDB是由哪种语言写的？"><a href="#11-1-1-MongoDB是由哪种语言写的？" class="headerlink" title="11.1.1 MongoDB是由哪种语言写的？"></a>11.1.1 MongoDB是由哪种语言写的？</h5><h5 id="11-1-2-MongoDB的优势有哪些？"><a href="#11-1-2-MongoDB的优势有哪些？" class="headerlink" title="11.1.2 MongoDB的优势有哪些？"></a>11.1.2 MongoDB的优势有哪些？</h5><h5 id="11-1-3-什么是数据库？"><a href="#11-1-3-什么是数据库？" class="headerlink" title="11.1.3 什么是数据库？"></a>11.1.3 什么是数据库？</h5><h5 id="11-1-4-什么是集合？"><a href="#11-1-4-什么是集合？" class="headerlink" title="11.1.4 什么是集合？"></a>11.1.4 什么是集合？</h5><h5 id="11-1-5-什么是文档？"><a href="#11-1-5-什么是文档？" class="headerlink" title="11.1.5 什么是文档？"></a>11.1.5 什么是文档？</h5><h5 id="11-1-6-MongoDB和关系型数据库术语对比图"><a href="#11-1-6-MongoDB和关系型数据库术语对比图" class="headerlink" title="11.1.6 MongoDB和关系型数据库术语对比图"></a>11.1.6 MongoDB和关系型数据库术语对比图</h5><h5 id="11-1-7-什么是“mongod”？"><a href="#11-1-7-什么是“mongod”？" class="headerlink" title="11.1.7 什么是“mongod”？"></a>11.1.7 什么是“mongod”？</h5><h5 id="11-1-8-“mongod”参数有什么？"><a href="#11-1-8-“mongod”参数有什么？" class="headerlink" title="11.1.8 “mongod”参数有什么？"></a>11.1.8 “mongod”参数有什么？</h5><h5 id="11-1-9-什么是“mongo”？"><a href="#11-1-9-什么是“mongo”？" class="headerlink" title="11.1.9 什么是“mongo”？"></a>11.1.9 什么是“mongo”？</h5><h5 id="11-2-0-MongoDB哪个命令可以切换数据库？"><a href="#11-2-0-MongoDB哪个命令可以切换数据库？" class="headerlink" title="11.2.0 MongoDB哪个命令可以切换数据库？"></a>11.2.0 MongoDB哪个命令可以切换数据库？</h5><h5 id="11-2-1-什么是非关系型数据库？"><a href="#11-2-1-什么是非关系型数据库？" class="headerlink" title="11.2.1 什么是非关系型数据库？"></a>11.2.1 什么是非关系型数据库？</h5><h5 id="11-2-2-非关系型数据库有哪些类型？"><a href="#11-2-2-非关系型数据库有哪些类型？" class="headerlink" title="11.2.2 非关系型数据库有哪些类型？"></a>11.2.2 非关系型数据库有哪些类型？</h5><h5 id="11-2-3-为什么用MOngoDB？"><a href="#11-2-3-为什么用MOngoDB？" class="headerlink" title="11.2.3 为什么用MOngoDB？"></a>11.2.3 为什么用MOngoDB？</h5><h5 id="11-2-4-在哪些场景使用MongoDB？"><a href="#11-2-4-在哪些场景使用MongoDB？" class="headerlink" title="11.2.4 在哪些场景使用MongoDB？"></a>11.2.4 在哪些场景使用MongoDB？</h5><h5 id="11-2-5-MongoDB中的命名空间是什么意思"><a href="#11-2-5-MongoDB中的命名空间是什么意思" class="headerlink" title="11.2.5 MongoDB中的命名空间是什么意思?"></a>11.2.5 MongoDB中的命名空间是什么意思?</h5><h5 id="11-2-6-哪些语言支持MongoDB"><a href="#11-2-6-哪些语言支持MongoDB" class="headerlink" title="11.2.6 哪些语言支持MongoDB?"></a>11.2.6 哪些语言支持MongoDB?</h5><h5 id="11-2-7-在MongoDB中如何创建一个新的数据库？"><a href="#11-2-7-在MongoDB中如何创建一个新的数据库？" class="headerlink" title="11.2.7 在MongoDB中如何创建一个新的数据库？"></a>11.2.7 在MongoDB中如何创建一个新的数据库？</h5><h5 id="11-2-8-在MongoDB中如何查看数据库列表？"><a href="#11-2-8-在MongoDB中如何查看数据库列表？" class="headerlink" title="11.2.8 在MongoDB中如何查看数据库列表？"></a>11.2.8 在MongoDB中如何查看数据库列表？</h5><h5 id="11-2-9-MongoDB中的分片是什么意思？"><a href="#11-2-9-MongoDB中的分片是什么意思？" class="headerlink" title="11.2.9 MongoDB中的分片是什么意思？"></a>11.2.9 MongoDB中的分片是什么意思？</h5><h5 id="11-3-0-如何查看使用MongoDB的连接？"><a href="#11-3-0-如何查看使用MongoDB的连接？" class="headerlink" title="11.3.0 如何查看使用MongoDB的连接？"></a>11.3.0 如何查看使用MongoDB的连接？</h5><h5 id="11-3-1-什么是复制？"><a href="#11-3-1-什么是复制？" class="headerlink" title="11.3.1 什么是复制？"></a>11.3.1 什么是复制？</h5><h5 id="11-3-2-在MongoDB中如何在集合中插入一个文档？"><a href="#11-3-2-在MongoDB中如何在集合中插入一个文档？" class="headerlink" title="11.3.2 在MongoDB中如何在集合中插入一个文档？"></a>11.3.2 在MongoDB中如何在集合中插入一个文档？</h5><h5 id="11-3-3-在MongoDB中如何除去一个数据库？"><a href="#11-3-3-在MongoDB中如何除去一个数据库？" class="headerlink" title="11.3.3 在MongoDB中如何除去一个数据库？"></a>11.3.3 在MongoDB中如何除去一个数据库？</h5><h5 id="11-3-4-在MongoDB中如何创建一个集合？"><a href="#11-3-4-在MongoDB中如何创建一个集合？" class="headerlink" title="11.3.4 在MongoDB中如何创建一个集合？"></a>11.3.4 在MongoDB中如何创建一个集合？</h5><h5 id="11-3-5-在MongoDB中如何查看一个已经创建的集合？"><a href="#11-3-5-在MongoDB中如何查看一个已经创建的集合？" class="headerlink" title="11.3.5 在MongoDB中如何查看一个已经创建的集合？"></a>11.3.5 在MongoDB中如何查看一个已经创建的集合？</h5><h5 id="11-3-6-在MongoDB中如何删除一个集合？"><a href="#11-3-6-在MongoDB中如何删除一个集合？" class="headerlink" title="11.3.6 在MongoDB中如何删除一个集合？"></a>11.3.6 在MongoDB中如何删除一个集合？</h5><h5 id="11-3-7-为什么要在MongoDB中使用分析器？"><a href="#11-3-7-为什么要在MongoDB中使用分析器？" class="headerlink" title="11.3.7 为什么要在MongoDB中使用分析器？"></a>11.3.7 为什么要在MongoDB中使用分析器？</h5><h5 id="11-3-8-MongoDB支持主键外键关系吗？"><a href="#11-3-8-MongoDB支持主键外键关系吗？" class="headerlink" title="11.3.8 MongoDB支持主键外键关系吗？"></a>11.3.8 MongoDB支持主键外键关系吗？</h5><h5 id="11-3-9-MongoDB支持哪些数据类型？"><a href="#11-3-9-MongoDB支持哪些数据类型？" class="headerlink" title="11.3.9 MongoDB支持哪些数据类型？"></a>11.3.9 MongoDB支持哪些数据类型？</h5><h5 id="11-4-0-为什么要在MongoDB中用”Code”数据类型？"><a href="#11-4-0-为什么要在MongoDB中用”Code”数据类型？" class="headerlink" title="11.4.0 为什么要在MongoDB中用”Code”数据类型？"></a>11.4.0 为什么要在MongoDB中用”Code”数据类型？</h5><h5 id="11-4-1-为什么要在MongoDB中用”Regular-Expression”数据类型？"><a href="#11-4-1-为什么要在MongoDB中用”Regular-Expression”数据类型？" class="headerlink" title="11.4.1 为什么要在MongoDB中用”Regular Expression”数据类型？"></a>11.4.1 为什么要在MongoDB中用”Regular Expression”数据类型？</h5><h5 id="11-4-2-为什么在MongoDB中使用”Object-ID”数据类型？"><a href="#11-4-2-为什么在MongoDB中使用”Object-ID”数据类型？" class="headerlink" title="11.4.2 为什么在MongoDB中使用”Object ID”数据类型？"></a>11.4.2 为什么在MongoDB中使用”Object ID”数据类型？</h5><h5 id="11-4-3-如何在集合中插入一个文档？"><a href="#11-4-3-如何在集合中插入一个文档？" class="headerlink" title="11.4.3 如何在集合中插入一个文档？"></a>11.4.3 如何在集合中插入一个文档？</h5><h5 id="11-4-4-“ObjectID”有哪些部分组成？"><a href="#11-4-4-“ObjectID”有哪些部分组成？" class="headerlink" title="11.4.4 “ObjectID”有哪些部分组成？"></a>11.4.4 “ObjectID”有哪些部分组成？</h5><h5 id="11-4-5-在MongoDb中什么是索引？"><a href="#11-4-5-在MongoDb中什么是索引？" class="headerlink" title="11.4.5 在MongoDb中什么是索引？"></a>11.4.5 在MongoDb中什么是索引？</h5><h5 id="11-4-6-如何添加索引？"><a href="#11-4-6-如何添加索引？" class="headerlink" title="11.4.6 如何添加索引？"></a>11.4.6 如何添加索引？</h5><h5 id="11-4-7-MongoDB有哪些可替代产品？"><a href="#11-4-7-MongoDB有哪些可替代产品？" class="headerlink" title="11.4.7 MongoDB有哪些可替代产品？"></a>11.4.7 MongoDB有哪些可替代产品？</h5><h5 id="11-4-8-如何查询集合中的文档？"><a href="#11-4-8-如何查询集合中的文档？" class="headerlink" title="11.4.8 如何查询集合中的文档？"></a>11.4.8 如何查询集合中的文档？</h5><h5 id="11-4-9-用什么方法可以格式化输出结果？"><a href="#11-4-9-用什么方法可以格式化输出结果？" class="headerlink" title="11.4.9 用什么方法可以格式化输出结果？"></a>11.4.9 用什么方法可以格式化输出结果？</h5><h5 id="11-5-0-如何使用”AND”或”OR”条件循环查询集合中的文档？"><a href="#11-5-0-如何使用”AND”或”OR”条件循环查询集合中的文档？" class="headerlink" title="11.5.0 如何使用”AND”或”OR”条件循环查询集合中的文档？"></a>11.5.0 如何使用”AND”或”OR”条件循环查询集合中的文档？</h5><h5 id="11-5-1-在MongoDB中如何更新数据？"><a href="#11-5-1-在MongoDB中如何更新数据？" class="headerlink" title="11.5.1 在MongoDB中如何更新数据？"></a>11.5.1 在MongoDB中如何更新数据？</h5><h5 id="11-5-2-如何删除文档？"><a href="#11-5-2-如何删除文档？" class="headerlink" title="11.5.2 如何删除文档？"></a>11.5.2 如何删除文档？</h5><h5 id="11-5-3-在MongoDB中如何排序？"><a href="#11-5-3-在MongoDB中如何排序？" class="headerlink" title="11.5.3 在MongoDB中如何排序？"></a>11.5.3 在MongoDB中如何排序？</h5><h5 id="11-5-4-什么是聚合？"><a href="#11-5-4-什么是聚合？" class="headerlink" title="11.5.4 什么是聚合？"></a>11.5.4 什么是聚合？</h5><h5 id="11-5-5-在MongoDB中什么是副本集？"><a href="#11-5-5-在MongoDB中什么是副本集？" class="headerlink" title="11.5.5 在MongoDB中什么是副本集？"></a>11.5.5 在MongoDB中什么是副本集？</h5><h5 id="11-5-6-Mongodb存储特性与内部原理"><a href="#11-5-6-Mongodb存储特性与内部原理" class="headerlink" title="11.5.6 Mongodb存储特性与内部原理?"></a>11.5.6 Mongodb存储特性与内部原理?</h5><br><h3 id="12">Zookeeper篇</h3> <hr><h5 id="12-1-0-zookeeper是什么？"><a href="#12-1-0-zookeeper是什么？" class="headerlink" title="12.1.0 zookeeper是什么？"></a>12.1.0 zookeeper是什么？</h5><h5 id="12-1-1-zookeeper提供了什么？"><a href="#12-1-1-zookeeper提供了什么？" class="headerlink" title="12.1.1 zookeeper提供了什么？"></a>12.1.1 zookeeper提供了什么？</h5><h5 id="12-1-2-zookeeper文件系统"><a href="#12-1-2-zookeeper文件系统" class="headerlink" title="12.1.2 zookeeper文件系统"></a>12.1.2 zookeeper文件系统</h5><h5 id="12-1-3-zookeeper的四种类型的znode"><a href="#12-1-3-zookeeper的四种类型的znode" class="headerlink" title="12.1.3 zookeeper的四种类型的znode"></a>12.1.3 zookeeper的四种类型的znode</h5><h5 id="12-1-4-zookeeper通知机制"><a href="#12-1-4-zookeeper通知机制" class="headerlink" title="12.1.4 zookeeper通知机制"></a>12.1.4 zookeeper通知机制</h5><h5 id="12-1-5-zookeeper有哪些应用场景？"><a href="#12-1-5-zookeeper有哪些应用场景？" class="headerlink" title="12.1.5 zookeeper有哪些应用场景？"></a>12.1.5 zookeeper有哪些应用场景？</h5><h5 id="12-1-6-zk的命名服务"><a href="#12-1-6-zk的命名服务" class="headerlink" title="12.1.6 zk的命名服务"></a>12.1.6 zk的命名服务</h5><h5 id="12-1-7-zk的配置管理服务"><a href="#12-1-7-zk的配置管理服务" class="headerlink" title="12.1.7 zk的配置管理服务"></a>12.1.7 zk的配置管理服务</h5><h5 id="12-1-8-zk的集群管理"><a href="#12-1-8-zk的集群管理" class="headerlink" title="12.1.8 zk的集群管理"></a>12.1.8 zk的集群管理</h5><h5 id="12-1-9-zk的分布式锁"><a href="#12-1-9-zk的分布式锁" class="headerlink" title="12.1.9 zk的分布式锁"></a>12.1.9 zk的分布式锁</h5><h5 id="12-2-0-zk队列管理"><a href="#12-2-0-zk队列管理" class="headerlink" title="12.2.0 zk队列管理"></a>12.2.0 zk队列管理</h5><h5 id="12-2-1-zk数据复制"><a href="#12-2-1-zk数据复制" class="headerlink" title="12.2.1 zk数据复制"></a>12.2.1 zk数据复制</h5><h5 id="12-2-2-zk的工作原理"><a href="#12-2-2-zk的工作原理" class="headerlink" title="12.2.2 zk的工作原理"></a>12.2.2 zk的工作原理</h5><h5 id="12-2-3-zk是如何保证事物的顺序一致性"><a href="#12-2-3-zk是如何保证事物的顺序一致性" class="headerlink" title="12.2.3 zk是如何保证事物的顺序一致性"></a>12.2.3 zk是如何保证事物的顺序一致性</h5><h5 id="12-2-4-zk集群下server工作状态"><a href="#12-2-4-zk集群下server工作状态" class="headerlink" title="12.2.4 zk集群下server工作状态"></a>12.2.4 zk集群下server工作状态</h5><h5 id="12-2-5-zk是如何选举Leader的？"><a href="#12-2-5-zk是如何选举Leader的？" class="headerlink" title="12.2.5 zk是如何选举Leader的？"></a>12.2.5 zk是如何选举Leader的？</h5><h5 id="12-2-6-zk同步流程"><a href="#12-2-6-zk同步流程" class="headerlink" title="12.2.6 zk同步流程"></a>12.2.6 zk同步流程</h5><h5 id="12-2-7-分布式通知和协调"><a href="#12-2-7-分布式通知和协调" class="headerlink" title="12.2.7 分布式通知和协调"></a>12.2.7 分布式通知和协调</h5><br><h3 id="13">nginx篇</h3> <hr><h5 id="13-1-0-请解释一下什么是Nginx"><a href="#13-1-0-请解释一下什么是Nginx" class="headerlink" title="13.1.0 请解释一下什么是Nginx?"></a>13.1.0 请解释一下什么是Nginx?</h5><h5 id="13-1-1-请列举Nginx的一些特性"><a href="#13-1-1-请列举Nginx的一些特性" class="headerlink" title="13.1.1 请列举Nginx的一些特性?"></a>13.1.1 请列举Nginx的一些特性?</h5><h5 id="13-1-2-请列举Nginx和Apache-之间的不同点"><a href="#13-1-2-请列举Nginx和Apache-之间的不同点" class="headerlink" title="13.1.2 请列举Nginx和Apache 之间的不同点?"></a>13.1.2 请列举Nginx和Apache 之间的不同点?</h5><h5 id="13-1-3-请解释Nginx如何处理HTTP请求。"><a href="#13-1-3-请解释Nginx如何处理HTTP请求。" class="headerlink" title="13.1.3 请解释Nginx如何处理HTTP请求。"></a>13.1.3 请解释Nginx如何处理HTTP请求。</h5><h5 id="13-1-4-在Nginx中，如何使用未定义的服务器名称来阻止处理请求"><a href="#13-1-4-在Nginx中，如何使用未定义的服务器名称来阻止处理请求" class="headerlink" title="13.1.4 在Nginx中，如何使用未定义的服务器名称来阻止处理请求?"></a>13.1.4 在Nginx中，如何使用未定义的服务器名称来阻止处理请求?</h5><h5 id="13-1-5-使用“反向代理服务器”的优点是什么"><a href="#13-1-5-使用“反向代理服务器”的优点是什么" class="headerlink" title="13.1.5 使用“反向代理服务器”的优点是什么?"></a>13.1.5 使用“反向代理服务器”的优点是什么?</h5><h5 id="13-1-6-请列举Nginx服务器的最佳用途。"><a href="#13-1-6-请列举Nginx服务器的最佳用途。" class="headerlink" title="13.1.6 请列举Nginx服务器的最佳用途。"></a>13.1.6 请列举Nginx服务器的最佳用途。</h5><h5 id="13-1-7-请解释Nginx服务器上的Master和Worker进程分别是什么"><a href="#13-1-7-请解释Nginx服务器上的Master和Worker进程分别是什么" class="headerlink" title="13.1.7 请解释Nginx服务器上的Master和Worker进程分别是什么?"></a>13.1.7 请解释Nginx服务器上的Master和Worker进程分别是什么?</h5><h5 id="13-1-8-请解释你如何通过不同于80的端口开启Nginx"><a href="#13-1-8-请解释你如何通过不同于80的端口开启Nginx" class="headerlink" title="13.1.8 请解释你如何通过不同于80的端口开启Nginx?"></a>13.1.8 请解释你如何通过不同于80的端口开启Nginx?</h5><h5 id="13-1-9-请解释是否有可能将Nginx的错误替换为502错误、503"><a href="#13-1-9-请解释是否有可能将Nginx的错误替换为502错误、503" class="headerlink" title="13.1.9  请解释是否有可能将Nginx的错误替换为502错误、503?"></a>13.1.9  请解释是否有可能将Nginx的错误替换为502错误、503?</h5><h5 id="13-2-0-在Nginx中，解释如何在URL中保留双斜线"><a href="#13-2-0-在Nginx中，解释如何在URL中保留双斜线" class="headerlink" title="13.2.0 在Nginx中，解释如何在URL中保留双斜线?"></a>13.2.0 在Nginx中，解释如何在URL中保留双斜线?</h5><h5 id="13-2-1-请解释ngx-http-upstream-module的作用是什么"><a href="#13-2-1-请解释ngx-http-upstream-module的作用是什么" class="headerlink" title="13.2.1 请解释ngx_http_upstream_module的作用是什么?"></a>13.2.1 请解释ngx_http_upstream_module的作用是什么?</h5><h5 id="13-2-2-请解释什么是C10K问题，后来是怎么解决的？"><a href="#13-2-2-请解释什么是C10K问题，后来是怎么解决的？" class="headerlink" title="13.2.2 请解释什么是C10K问题，后来是怎么解决的？"></a>13.2.2 请解释什么是C10K问题，后来是怎么解决的？</h5><h5 id="13-2-3-请陈述stub-status和sub-filter指令的作用是什么"><a href="#13-2-3-请陈述stub-status和sub-filter指令的作用是什么" class="headerlink" title="13.2.3 请陈述stub_status和sub_filter指令的作用是什么?"></a>13.2.3 请陈述stub_status和sub_filter指令的作用是什么?</h5><h5 id="13-2-4-解释Nginx是否支持将请求压缩到上游"><a href="#13-2-4-解释Nginx是否支持将请求压缩到上游" class="headerlink" title="13.2.4 解释Nginx是否支持将请求压缩到上游?"></a>13.2.4 解释Nginx是否支持将请求压缩到上游?</h5><h5 id="13-2-5-解释如何在Nginx中获得当前的时间"><a href="#13-2-5-解释如何在Nginx中获得当前的时间" class="headerlink" title="13.2.5 解释如何在Nginx中获得当前的时间?"></a>13.2.5 解释如何在Nginx中获得当前的时间?</h5><h5 id="13-2-6-用Nginx服务器解释-s的目的是什么"><a href="#13-2-6-用Nginx服务器解释-s的目的是什么" class="headerlink" title="13.2.6 用Nginx服务器解释-s的目的是什么?"></a>13.2.6 用Nginx服务器解释-s的目的是什么?</h5><h5 id="13-2-7-解释如何在Nginx服务器上添加模块"><a href="#13-2-7-解释如何在Nginx服务器上添加模块" class="headerlink" title="13.2.7 解释如何在Nginx服务器上添加模块?"></a>13.2.7 解释如何在Nginx服务器上添加模块?</h5><h5 id="13-2-8-nginx中多个work进程是如何监听同一个端口的？如何处理客户连接的惊群问题？"><a href="#13-2-8-nginx中多个work进程是如何监听同一个端口的？如何处理客户连接的惊群问题？" class="headerlink" title="13.2.8 nginx中多个work进程是如何监听同一个端口的？如何处理客户连接的惊群问题？"></a>13.2.8 nginx中多个work进程是如何监听同一个端口的？如何处理客户连接的惊群问题？</h5><h5 id="13-2-9-nginx程序的热更新是如何做的？"><a href="#13-2-9-nginx程序的热更新是如何做的？" class="headerlink" title="13.2.9 nginx程序的热更新是如何做的？"></a>13.2.9 nginx程序的热更新是如何做的？</h5><br/><br/><img src = "arch.jpg" />]]></content>
    
    
    <categories>
      
      <category>面试题专栏</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>系统网络篇</title>
    <link href="/2019/07/19/%E7%B3%BB%E7%BB%9F%E7%BD%91%E7%BB%9C%E7%AF%87/"/>
    <url>/2019/07/19/%E7%B3%BB%E7%BB%9F%E7%BD%91%E7%BB%9C%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">asdasd<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
